'use strict';

/**
 * Some math utility functions.
 */
class MathUtils {
    /**
     * An alternative of {@link Math.min} that does not require a spread operator, making it
     * more efficient for larger arrays.
     *
     * @param values The values to get the minimum from.
     * @returns One of the following:
     * - The minimum value.
     * - 0 if the iterable is empty.
     * - `NaN` if any of the values are `NaN`.
     */
    static min(values) {
        let hasValue = false;
        let min = Number.POSITIVE_INFINITY;
        for (const value of values) {
            // Optimization - immediately return when the minimum is already negative infinity.
            if (hasValue && min === Number.NEGATIVE_INFINITY) {
                return min;
            }
            hasValue = true;
            if (Number.isNaN(value)) {
                return Number.NaN;
            }
            if (value < min) {
                min = value;
            }
        }
        return hasValue ? min : 0;
    }
    /**
     * An alternative of {@link Math.max} that does not require a spread operator, making it
     * more efficient for larger arrays.
     *
     * @param values The values to get the maximum from.
     * @returns One of the following:
     * - The maximum value.
     * - 0 if the iterable is empty.
     * - `NaN` if any of the values are `NaN`.
     */
    static max(values) {
        let hasValue = false;
        let max = Number.NEGATIVE_INFINITY;
        for (const value of values) {
            // Optimization - immediately return when the maximum is already positive infinity.
            if (hasValue && max === Number.POSITIVE_INFINITY) {
                return max;
            }
            hasValue = true;
            if (Number.isNaN(value)) {
                return Number.NaN;
            }
            if (value > max) {
                max = value;
            }
        }
        return hasValue ? max : 0;
    }
    /**
     * Rounds a specified number with specified amount of fractional digits.
     *
     * @param num The number to round.
     * @param fractionalDigits The amount of fractional digits.
     */
    static round(num, fractionalDigits) {
        return parseFloat(num.toFixed(fractionalDigits));
    }
    /**
     * Limits the specified number on range `[min, max]`.
     *
     * @param num The number to limit.
     * @param min The minimum range.
     * @param max The maximum range.
     */
    static clamp(num, min, max) {
        return Math.max(min, Math.min(num, max));
    }
    /**
     * Calculates the standard deviation of given data.
     *
     * @param data The data to calculate.
     */
    static calculateStandardDeviation(data) {
        if (data.length === 0) {
            return 0;
        }
        const mean = data.reduce((acc, value) => acc + value) / data.length;
        return Math.sqrt(data.reduce((acc, value) => acc + Math.pow(value - mean, 2), 0) /
            data.length);
    }
    /**
     * Converts degrees to radians.
     *
     * @param degrees An angle in degrees.
     * @returns The angle expressed in radians.
     */
    static degreesToRadians(degrees) {
        return (degrees * Math.PI) / 180;
    }
    /**
     * Converts radians to degrees.
     *
     * @param radians An angle in radians.
     * @returns The angle expressed in degrees.
     */
    static radiansToDegrees(radians) {
        return (radians * 180) / Math.PI;
    }
    /**
     * Converts a BPM value to milliseconds.
     *
     * @param bpm The BPM value.
     * @param delimiter The denominator of the time signature. Defaults to 4.
     * @returns The BPM value in milliseconds.
     */
    static bpmToMilliseconds(bpm, delimiter = 4) {
        return 60000 / bpm / delimiter;
    }
    /**
     * Converts milliseconds to BPM.
     *
     * @param milliseconds The milliseconds value.
     * @param delimiter The denominator of the time signature. Defaults to 4.
     * @returns The milliseconds value in BPM.
     */
    static millisecondsToBPM(milliseconds, delimiter = 4) {
        return 60000 / (milliseconds * delimiter);
    }
    /**
     * Calculates an S-shaped {@link https://en.wikipedia.org/wiki/Logistic_function logistic function}
     * with offset at `x`.
     *
     * @param x The value to calculate the function for.
     * @param midpointOffset How much the function midpoint is offset from zero `x`.
     * @param multiplier The growth rate of the function.
     * @param maxValue Maximum value returnable by the function.
     * @returns The output of the logistic function calculated at `x`.
     */
    static offsetLogistic(x, midpointOffset, multiplier, maxValue = 1) {
        return maxValue / (1 + Math.exp(multiplier * (midpointOffset - x)));
    }
    /**
     * Calculates the {@link https://en.wikipedia.org/wiki/Smoothstep smoothstep} function
     * at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the smoothstep function calculated at `x`.
     */
    static smoothstep(x, start, end) {
        x = this.reverseLerp(x, start, end);
        return x * x * (3 - 2 * x);
    }
    /**
     * Calculates the {@link https://en.wikipedia.org/wiki/Smoothstep#Variations smoothstep}
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the smoothstep function calculated at `x`.
     */
    static smootherstep(x, start, end) {
        x = this.reverseLerp(x, start, end);
        return x * x * x * (x * (6 * x - 15) + 10);
    }
    /**
     * Calculates the reverse {@link https://en.wikipedia.org/wiki/Linear_interpolation linear interpolation}
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the reverse lerp function calculated at `x`.
     */
    static reverseLerp(x, start, end) {
        return this.clamp((x - start) / (end - start), 0, 1);
    }
}

/**
 * An accuracy calculator that calculates accuracy based on given parameters.
 */
class Accuracy {
    /**
     * Calculates accuracy based on given parameters.
     *
     * If `percent` and `nobjects` are specified, `n300`, `n100`, and `n50` will
     * be automatically calculated to be the closest to the given
     * acc percent.
     *
     * @param values Function parameters.
     */
    constructor(values) {
        var _a, _b, _c, _d;
        this.nmiss = (_a = values.nmiss) !== null && _a !== void 0 ? _a : 0;
        this.n300 = (_b = values.n300) !== null && _b !== void 0 ? _b : -1;
        this.n100 = (_c = values.n100) !== null && _c !== void 0 ? _c : 0;
        this.n50 = (_d = values.n50) !== null && _d !== void 0 ? _d : 0;
        let nobjects;
        if (values.nobjects) {
            let n300 = this.n300;
            nobjects = values.nobjects;
            let hitcount;
            if (n300 < 0) {
                n300 = Math.max(0, nobjects - this.n100 - this.n50 - this.nmiss);
            }
            hitcount = n300 + this.n100 + this.n50 + this.nmiss;
            if (hitcount > nobjects) {
                n300 -= Math.min(n300, hitcount - nobjects);
            }
            hitcount = n300 + this.n100 + this.n50 + this.nmiss;
            if (hitcount > nobjects) {
                this.n100 -= Math.min(this.n100, hitcount - nobjects);
            }
            hitcount = n300 + this.n100 + this.n50 + this.nmiss;
            if (hitcount > nobjects) {
                this.n50 -= Math.min(this.n50, hitcount - nobjects);
            }
            hitcount = n300 + this.n100 + this.n50 + this.nmiss;
            if (hitcount > nobjects) {
                this.nmiss -= Math.min(this.nmiss, hitcount - nobjects);
            }
            this.n300 = nobjects - this.n100 - this.n50 - this.nmiss;
        }
        if (values.percent) {
            if (!values.nobjects) {
                throw new TypeError("nobjects is required when specifying percent");
            }
            nobjects = values.nobjects;
            const max300 = nobjects - this.nmiss;
            const maxacc = new Accuracy({
                n300: max300,
                n100: 0,
                n50: 0,
                nmiss: this.nmiss,
            }).value() * 100;
            let acc_percent = values.percent;
            acc_percent = Math.max(0, Math.min(maxacc, acc_percent));
            // just some black magic maths from wolfram alpha
            this.n100 = Math.round(-3 * ((acc_percent * 0.01 - 1) * nobjects + this.nmiss) * 0.5);
            if (this.n100 > max300) {
                // acc lower than all 100s, use 50s
                this.n100 = 0;
                this.n50 = Math.round(-6 *
                    ((acc_percent * 0.01 - 1) * nobjects + this.nmiss) *
                    0.5);
                this.n50 = Math.min(max300, this.n50);
            }
            this.n300 = nobjects - this.n100 - this.n50 - this.nmiss;
        }
    }
    /**
     * Calculates the accuracy value (0.0 - 1.0).
     *
     * @param nobjects The amount of objects in the beatmap. If `n300` was not specified in the constructor, this is required.
     */
    value(nobjects) {
        let n300 = this.n300;
        if (n300 < 0) {
            if (!nobjects) {
                throw new TypeError("Either n300 or nobjects must be specified");
            }
            n300 = nobjects - this.n100 - this.n50 - this.nmiss;
        }
        else {
            nobjects !== null && nobjects !== void 0 ? nobjects : (nobjects = n300 + this.n100 + this.n50 + this.nmiss);
        }
        const res = (n300 * 6 + this.n100 * 2 + this.n50) / (nobjects * 6);
        return MathUtils.clamp(res, 0, 1);
    }
    /**
     * Determines whether this accuracy instance is equal to another instance.
     *
     * @param other The other accuracy instance.
     * @returns Whether both instances are equal.
     */
    equals(other) {
        return (this.n300 === other.n300 &&
            this.n100 === other.n100 &&
            this.n50 === other.n50 &&
            this.nmiss === other.nmiss);
    }
}

/**
 * General enum to specify an "anchor" or "origin" point from the standard 9 points on a rectangle.
 */
exports.Anchor = void 0;
(function (Anchor) {
    Anchor["topLeft"] = "TopLeft";
    Anchor["center"] = "Centre";
    Anchor["centerLeft"] = "CentreLeft";
    Anchor["topRight"] = "TopRight";
    Anchor["bottomCenter"] = "BottomCentre";
    Anchor["topCenter"] = "TopCentre";
    /**
     * The user is manually updating the outcome, so we shouldn't.
     */
    Anchor["custom"] = "Custom";
    Anchor["centerRight"] = "CentreRight";
    Anchor["bottomLeft"] = "BottomLeft";
    Anchor["bottomRight"] = "BottomRight";
})(exports.Anchor || (exports.Anchor = {}));

/**
 * Defines available axes.
 */
exports.Axes = void 0;
(function (Axes) {
    /**
     * No axis.
     */
    Axes[Axes["none"] = 0] = "none";
    /**
     * The X axis.
     */
    Axes[Axes["x"] = 1] = "x";
    /**
     * The Y axis.
     */
    Axes[Axes["y"] = 2] = "y";
    /**
     * The X and Y axes.
     */
    Axes[Axes["both"] = 3] = "both";
})(exports.Axes || (exports.Axes = {}));

/**
 * The loop type of storyboard animations.
 */
exports.AnimationLoopType = void 0;
(function (AnimationLoopType) {
    AnimationLoopType["loopForever"] = "LoopForever";
    AnimationLoopType["loopOnce"] = "LoopOnce";
})(exports.AnimationLoopType || (exports.AnimationLoopType = {}));

/**
 * Represents available sample banks.
 */
exports.SampleBank = void 0;
(function (SampleBank) {
    SampleBank[SampleBank["none"] = 0] = "none";
    SampleBank[SampleBank["normal"] = 1] = "normal";
    SampleBank[SampleBank["soft"] = 2] = "soft";
    SampleBank[SampleBank["drum"] = 3] = "drum";
})(exports.SampleBank || (exports.SampleBank = {}));

/**
 * Represents a gameplay hit sample.
 */
class HitSampleInfo {
    constructor(volume = 0) {
        this.volume = volume;
    }
}

/**
 * Represents a pre-determined gameplay hit sample that can be loaded from banks.
 */
class BankHitSampleInfo extends HitSampleInfo {
    get lookupNames() {
        const names = [];
        let prefix;
        switch (this.bank) {
            case exports.SampleBank.none:
                prefix = "";
                break;
            case exports.SampleBank.normal:
                prefix = "normal";
                break;
            case exports.SampleBank.soft:
                prefix = "soft";
                break;
            case exports.SampleBank.drum:
                prefix = "drum";
                break;
        }
        if (this.customSampleBank >= 2) {
            names.push(`${prefix}-${this.name}${this.customSampleBank}`);
        }
        names.push(`${prefix}-${this.name}`, this.name);
        return names;
    }
    constructor(name, bank = exports.SampleBank.none, customSampleBank = 0, volume = 0, isLayered = false) {
        super(volume);
        this.name = name;
        this.bank = bank;
        this.customSampleBank = customSampleBank;
        this.isLayered = isLayered;
    }
}
BankHitSampleInfo.HIT_WHISTLE = "hitwhistle";
BankHitSampleInfo.HIT_FINISH = "hitfinish";
BankHitSampleInfo.HIT_NORMAL = "hitnormal";
BankHitSampleInfo.HIT_CLAP = "hitclap";

/**
 * Mode enum to switch things between osu!droid and osu!standard.
 */
exports.Modes = void 0;
(function (Modes) {
    Modes["droid"] = "droid";
    Modes["osu"] = "osu";
})(exports.Modes || (exports.Modes = {}));

/**
 * Represents a hit window.
 */
class HitWindow {
    /**
     * @param overallDifficulty The overall difficulty of this `HitWindow`. Defaults to 5.
     */
    constructor(overallDifficulty = 5) {
        this.overallDifficulty = overallDifficulty;
    }
}
/**
 * A fixed miss hit window regardless of difficulty settings.
 */
HitWindow.missWindow = 400;

/**
 * Represents the hit window of osu!droid _without_ the Precise mod.
 */
class DroidHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value) {
        return 5 - (value - 75) / 5;
    }
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value) {
        return 5 - (value - 150) / 10;
    }
    /**
     * Calculates the overall difficulty value of a meh (50) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value) {
        return 5 - (value - 250) / 10;
    }
    get greatWindow() {
        return 75 + 5 * (5 - this.overallDifficulty);
    }
    get okWindow() {
        return 150 + 10 * (5 - this.overallDifficulty);
    }
    get mehWindow() {
        return 250 + 10 * (5 - this.overallDifficulty);
    }
}

/**
 * Represents the hit window of osu!standard.
 */
class OsuHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value) {
        return (80 - value) / 6;
    }
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value) {
        return (140 - value) / 8;
    }
    /**
     * Calculates the overall difficulty value of a meh hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value) {
        return (200 - value) / 10;
    }
    get greatWindow() {
        return 80 - 6 * this.overallDifficulty;
    }
    get okWindow() {
        return 140 - 8 * this.overallDifficulty;
    }
    get mehWindow() {
        return 200 - 10 * this.overallDifficulty;
    }
}

/**
 * Represents the hit window of osu!droid _with_ the Precise mod.
 */
class PreciseDroidHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value) {
        return 5 - (value - 55) / 6;
    }
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value) {
        return 5 - (value - 120) / 8;
    }
    /**
     * Calculates the overall difficulty value of a meh (50) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value) {
        return 5 - (value - 180) / 10;
    }
    get greatWindow() {
        return 55 + 6 * (5 - this.overallDifficulty);
    }
    get okWindow() {
        return 120 + 8 * (5 - this.overallDifficulty);
    }
    get mehWindow() {
        return 180 + 10 * (5 - this.overallDifficulty);
    }
}

/**
 * Bitmask constant of object types. This is needed as osu! uses bits to determine object types.
 */
exports.ObjectTypes = void 0;
(function (ObjectTypes) {
    ObjectTypes[ObjectTypes["circle"] = 1] = "circle";
    ObjectTypes[ObjectTypes["slider"] = 2] = "slider";
    ObjectTypes[ObjectTypes["newCombo"] = 4] = "newCombo";
    ObjectTypes[ObjectTypes["spinner"] = 8] = "spinner";
    ObjectTypes[ObjectTypes["comboOffset"] = 112] = "comboOffset";
})(exports.ObjectTypes || (exports.ObjectTypes = {}));

/**
 * Represents a two-dimensional vector.
 */
class Vector2 {
    constructor(valueOrXOrOther, y) {
        if (valueOrXOrOther instanceof Vector2) {
            this.x = valueOrXOrOther.x;
            this.y = valueOrXOrOther.y;
            return;
        }
        if (y === undefined) {
            this.x = valueOrXOrOther;
            this.y = valueOrXOrOther;
            return;
        }
        this.x = valueOrXOrOther;
        this.y = y;
    }
    /**
     * Multiplies this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The multiplied vector.
     */
    multiply(vec) {
        return new Vector2(this.x * vec.x, this.y * vec.y);
    }
    /**
     * Divides this vector with a scalar.
     *
     * Attempting to divide by 0 will throw an error.
     *
     * @param divideFactor The factor to divide the vector by.
     * @returns The divided vector.
     */
    divide(divideFactor) {
        if (divideFactor === 0) {
            throw new Error("Division by 0");
        }
        return new Vector2(this.x / divideFactor, this.y / divideFactor);
    }
    /**
     * Adds this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The added vector.
     */
    add(vec) {
        return new Vector2(this.x + vec.x, this.y + vec.y);
    }
    /**
     * Subtracts this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The subtracted vector.
     */
    subtract(vec) {
        return new Vector2(this.x - vec.x, this.y - vec.y);
    }
    /**
     * The length of this vector.
     */
    get length() {
        return Math.hypot(this.x, this.y);
    }
    /**
     * Performs a dot multiplication with another vector.
     *
     * @param vec The other vector.
     * @returns The dot product of both vectors.
     */
    dot(vec) {
        return this.x * vec.x + this.y * vec.y;
    }
    /**
     * Scales this vector.
     *
     * @param scaleFactor The factor to scale the vector by.
     * @returns The scaled vector.
     */
    scale(scaleFactor) {
        return new Vector2(this.x * scaleFactor, this.y * scaleFactor);
    }
    /**
     * Gets the distance between this vector and another vector.
     *
     * @param vec The other vector.
     * @returns The distance between this vector and the other vector.
     */
    getDistance(vec) {
        return Math.hypot(this.x - vec.x, this.y - vec.y);
    }
    /**
     * Gets the angle between this vector and another vector.
     *
     * @param vec The other vector.
     * @returns The angle between this vector and the other vector.
     */
    getAngle(vec) {
        return Math.atan2(vec.y - this.y, vec.x - this.x);
    }
    /**
     * Normalizes the vector.
     */
    normalize() {
        const length = this.length;
        this.x /= length;
        this.y /= length;
    }
    /**
     * Checks whether this vector is equal to another vector.
     *
     * @param other The other vector.
     * @returns Whether this vector is equal to the other vector.
     */
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Deep clones this vector.
     */
    clone() {
        return new Vector2(this);
    }
    /**
     * Returns a string representation of the vector.
     */
    toString() {
        return `${this.x},${this.y}`;
    }
}

/**
 * Contains difficulty settings of a beatmap.
 */
class BeatmapDifficulty {
    /**
     * The approach rate of the beatmap.
     */
    get ar() {
        var _a;
        return (_a = this._ar) !== null && _a !== void 0 ? _a : this.od;
    }
    /**
     * The approach rate of the beatmap.
     */
    set ar(value) {
        this._ar = value;
    }
    /**
     * Maps a difficulty value [0, 10] to a two-piece linear range of values.
     *
     * @param difficulty The difficulty value to be mapped.
     * @param min Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param mid Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param max Maximum of the resulting range which will be achieved by a difficulty value of 10.
     */
    static difficultyRange(difficulty, min, mid, max) {
        switch (true) {
            case difficulty > 5:
                return mid + ((max - mid) * (difficulty - 5)) / 5;
            case difficulty < 5:
                return mid + ((mid - min) * (difficulty - 5)) / 5;
            default:
                return mid;
        }
    }
    /**
     * Inverse function to `difficultyRange`. Maps a value returned by the function back to the
     * difficulty that produced it.
     *
     * @param difficultyValue The difficulty-dependent value to be unmapped.
     * @param diff0 Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param diff5 Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param diff10 Maximum of the resulting range which will be achieved by a difficulty value of 10.
     * @return The value to which the difficulty value maps in the specified range.
     */
    static inverseDifficultyRange(difficultyValue, diff0, diff5, diff10) {
        if (Math.sign(difficultyValue - diff5) == Math.sign(diff10 - diff0)) {
            return ((difficultyValue - diff5) / (diff10 - diff5)) * 5 + 5;
        }
        else {
            return ((difficultyValue - diff5) / (diff5 - diff0)) * 5 + 5;
        }
    }
    constructor(shallowCopy) {
        /**
         * The circle size of the beatmap.
         */
        this.cs = 5;
        /**
         * The overall difficulty of the beatmap.
         */
        this.od = 5;
        /**
         * The health drain rate of the beatmap.
         */
        this.hp = 5;
        /**
         * The base slider velocity in hundreds of osu! pixels per beat.
         */
        this.sliderMultiplier = 1;
        /**
         * The amount of slider ticks per beat.
         */
        this.sliderTickRate = 1;
        if (!shallowCopy) {
            return;
        }
        this._ar = shallowCopy._ar;
        this.cs = shallowCopy.cs;
        this.od = shallowCopy.od;
        this.hp = shallowCopy.hp;
        this.sliderMultiplier = shallowCopy.sliderMultiplier;
        this.sliderTickRate = shallowCopy.sliderTickRate;
    }
}

/**
 * A utility class for calculating circle sizes across all modes (rimu! and osu!standard).
 */
class CircleSizeCalculator {
    /**
     * Converts osu!droid circle size to osu!droid scale.
     *
     * @param cs The circle size to convert.
     * @returns The calculated osu!droid scale.
     */
    static droidCSToDroidScale(cs) {
        // 6.8556344386 was derived by converting the old osu!droid gameplay scale unit into osu!pixels (by dividing it
        // with (height / 480)) and then fitting the function to the osu!standard scale function. The height in the old
        // osu!droid gameplay scale function was set to 576, which was chosen after sampling the top 100 most used
        // devices by players from Firebase. This is done to ensure that the new scale is as close to the old scale as
        // possible for most players.
        // The fitting of both functions can be found under the following graph: https://www.desmos.com/calculator/rjfxqc3yic
        return Math.max(1e-3, this.standardCSToStandardScale(cs - 6.8556344386, true));
    }
    /**
     * Converts osu!droid scale to osu!droid circle size.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The calculated osu!droid circle size.
     */
    static droidScaleToDroidCS(scale) {
        return (this.standardScaleToStandardCS(Math.max(1e-3, scale), true) +
            6.8556344386);
    }
    /**
     * Converts osu!droid CS to old osu!droid scale.
     *
     * @param cs The CS to convert.
     * @param mods The mods to apply.
     * @returns The calculated osu!droid scale.
     */
    static droidCSToOldDroidScale(cs, mods) {
        // Create a dummy beatmap difficulty for circle size calculation.
        const difficulty = new BeatmapDifficulty();
        difficulty.cs = cs;
        if (mods !== undefined) {
            const adjustmentMods = new ModMap();
            for (const mod of mods.values()) {
                if (mod.facilitatesAdjustment()) {
                    adjustmentMods.set(mod);
                }
            }
            for (const mod of mods.values()) {
                if (mod.isApplicableToDifficulty()) {
                    mod.applyToDifficulty(exports.Modes.droid, difficulty, adjustmentMods);
                }
            }
            for (const mod of mods.values()) {
                if (mod.isApplicableToDifficultyWithMods()) {
                    mod.applyToDifficultyWithMods(exports.Modes.droid, difficulty, mods);
                }
            }
        }
        return Math.max(((this.oldAssumedDroidHeight / 480) *
            (54.42 - difficulty.cs * 4.48)) /
            HitObject.baseRadius +
            this.oldDroidScaleMultiplier, 1e-3);
    }
    /**
     * Converts old osu!droid scale to osu!droid circle size.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The calculated osu!droid circle size.
     */
    static oldDroidScaleToDroidCS(scale) {
        return ((54.42 -
            ((Math.max(1e-3, scale) - this.oldDroidScaleMultiplier) *
                HitObject.baseRadius *
                480) /
                this.oldAssumedDroidHeight) /
            4.48);
    }
    /**
     * Converts old osu!droid difficulty scale that is in **screen pixels** to **osu!pixels**.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The converted scale.
     */
    static oldDroidScaleScreenPixelsToOsuPixels(scale) {
        return (scale * 480) / this.oldAssumedDroidHeight;
    }
    /**
     * Converts old osu!droid scale that is in **osu!pixels** to **screen pixels**.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The converted scale.
     */
    static oldDroidScaleOsuPixelsToScreenPixels(scale) {
        return (scale * this.oldAssumedDroidHeight) / 480;
    }
    /**
     * Converts old osu!droid scale to osu!standard radius.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The osu!standard radius of the given osu!droid scale.
     */
    static oldDroidScaleToStandardRadius(scale) {
        return ((HitObject.baseRadius * Math.max(1e-3, scale)) /
            ((this.oldAssumedDroidHeight * 0.85) / 384));
    }
    /**
     * Converts osu!standard radius to old osu!droid scale.
     *
     * @param radius The osu!standard radius to convert.
     * @returns The osu!droid scale of the given osu!standard radius.
     */
    static standardRadiusToOldDroidScale(radius) {
        return Math.max(1e-3, (radius * ((this.oldAssumedDroidHeight * 0.85) / 384)) /
            HitObject.baseRadius);
    }
    /**
     * Converts osu!standard circle size to osu!standard scale.
     *
     * @param cs The osu!standard circle size to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard scale of the given circle size.
     */
    static standardCSToStandardScale(cs, applyFudge = false) {
        return (((1 - (0.7 * (cs - 5)) / 5) / 2) *
            (applyFudge ? this.brokenGamefieldRoundingAllowance : 1));
    }
    /**
     * Converts osu!standard scale to osu!standard circle size.
     *
     * @param scale The osu!standard scale to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard circle size of the given scale.
     */
    static standardScaleToStandardCS(scale, applyFudge = false) {
        // Inverse operation: https://www.desmos.com/calculator/74xr7tcmek
        return (5 +
            (5 *
                (1 -
                    (2 * scale) /
                        (applyFudge
                            ? this.brokenGamefieldRoundingAllowance
                            : 1))) /
                0.7);
    }
    /**
     * Converts osu!standard radius to osu!standard circle size.
     *
     * @param radius The osu!standard radius to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard circle size of the given radius.
     */
    static standardRadiusToStandardCS(radius, applyFudge = false) {
        return this.standardScaleToStandardCS(radius / HitObject.baseRadius, applyFudge);
    }
    /**
     * Converts osu!standard scale to old osu!droid scale.
     *
     * @param scale The osu!standard scale to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The old osu!droid scale of the given osu!standard scale.
     */
    static standardScaleToOldDroidScale(scale, applyFudge = false) {
        return this.standardRadiusToOldDroidScale((HitObject.baseRadius * scale) /
            (applyFudge ? this.brokenGamefieldRoundingAllowance : 1));
    }
}
/**
 * The following comment is copied verbatim from osu!lazer and osu!stable:
 *
 * > Builds of osu! up to 2013-05-04 had the gamefield being rounded down, which caused incorrect radius calculations
 * > in widescreen cases. This ratio adjusts to allow for old replays to work post-fix, which in turn increases the lenience
 * > for all plays, but by an amount so small it should only be effective in replays.
 *
 * To match expectations of gameplay we need to apply this multiplier to circle scale. It's weird but is what it is.
 * It works out to under 1 game pixel and is generally not meaningful to gameplay, but is to replay playback accuracy.
 */
CircleSizeCalculator.brokenGamefieldRoundingAllowance = 1.00041;
/**
 * This was not the real height that is used in the game, but rather an assumption so that we can treat circle sizes
 * similarly across all devices. This is used in difficulty calculation.
 */
CircleSizeCalculator.oldAssumedDroidHeight = 681;
CircleSizeCalculator.oldDroidScaleMultiplier = (0.5 * (11 - 5.2450170716245195)) / 5;

/**
 * Represents a hitobject in a beatmap.
 */
class HitObject {
    /**
     * The position of the hitobject in osu!pixels.
     */
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value;
    }
    /**
     * The end position of the hitobject in osu!pixels.
     */
    get endPosition() {
        return this.position;
    }
    /**
     * The end time of the hitobject.
     */
    get endTime() {
        return this.startTime;
    }
    /**
     * The duration of the hitobject.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    /**
     * The index of this hitobject in the current combo.
     */
    get indexInCurrentCombo() {
        return this._indexInCurrentCombo;
    }
    /**
     * The index of this hitobject's combo in relation to the beatmap.
     *
     * In other words, this is incremented by 1 each time an `isNewCombo` is reached.
     */
    get comboIndex() {
        return this._comboIndex;
    }
    /**
     * The index of this hitobject's combo in relation to the beatmap, with all aggregates applied.
     */
    get comboIndexWithOffsets() {
        return this._comboIndexWithOffsets;
    }
    /**
     * Whether this hitobject is in kiai time.
     */
    get kiai() {
        return this._kiai;
    }
    /**
     * The stack height of this hitobject.
     */
    get stackHeight() {
        return this._stackHeight;
    }
    set stackHeight(value) {
        this._stackHeight = value;
    }
    /**
     * The osu!standard scale of this hitobject.
     */
    get scale() {
        return this._scale;
    }
    set scale(value) {
        this._scale = value;
    }
    /**
     * The multiplier for the stack offset of this hitobject.
     *
     * This determines how much hitobjects are stacked - and to which direction.
     */
    get stackOffsetMultiplier() {
        return this._stackOffsetMultiplier;
    }
    set stackOffsetMultiplier(value) {
        this._stackOffsetMultiplier = value;
    }
    /**
     * The stack offset vector of this hitobject.
     */
    get stackOffset() {
        return new Vector2(this.stackHeight * this.scale * this.stackOffsetMultiplier);
    }
    /**
     * The stacked position of this hitobject.
     */
    get stackedPosition() {
        return this.evaluateStackedPosition(this.position);
    }
    /**
     * The stacked end position of this hitobject.
     */
    get stackedEndPosition() {
        return this.evaluateStackedPosition(this.endPosition);
    }
    /**
     * The hitobject type (circle, slider, or spinner).
     */
    get typeStr() {
        let res = "";
        if (this.type & exports.ObjectTypes.circle) {
            res += "circle | ";
        }
        if (this.type & exports.ObjectTypes.slider) {
            res += "slider | ";
        }
        if (this.type & exports.ObjectTypes.spinner) {
            res += "spinner | ";
        }
        return res.substring(0, Math.max(0, res.length - 3));
    }
    /**
     * The radius of this hitobject in osu!pixels.
     */
    get radius() {
        return HitObject.baseRadius * this.scale;
    }
    constructor(values) {
        var _a, _b, _c;
        this._indexInCurrentCombo = 0;
        this._comboIndex = 0;
        this._comboIndexWithOffsets = 0;
        /**
         * Whether this is the last hitobject in the current combo.
         */
        this.isLastInCombo = false;
        /**
         * The samples to be played when this hitobject is hit.
         *
         * In the case of sliders, this is the sample of the curve body
         * and can be treated as the default samples for the hitobject.
         */
        this.samples = [];
        /**
         * Any samples which may be used by this hitobject that are non-standard.
         */
        this.auxiliarySamples = [];
        this._kiai = false;
        /**
         * The hit window of this hitobject.
         */
        this.hitWindow = null;
        this._stackHeight = 0;
        this._scale = 1;
        this._stackOffsetMultiplier = 0;
        /**
         * The time at which the approach circle of this hitobject should appear before this hitobject starts.
         */
        this.timePreempt = 600;
        /**
         * The time at which this hitobject should fade after this hitobject appears with respect to its time preempt.
         */
        this.timeFadeIn = 400;
        this.startTime = values.startTime;
        this.type = (_a = values.type) !== null && _a !== void 0 ? _a : exports.ObjectTypes.circle;
        this._position = values.position;
        this.isNewCombo = (_b = values.newCombo) !== null && _b !== void 0 ? _b : false;
        this.comboOffset = (_c = values.comboOffset) !== null && _c !== void 0 ? _c : 0;
    }
    /**
     * Applies default values to this hitobject.
     *
     * @param controlPoints The beatmap control points.
     * @param difficulty The beatmap difficulty settings.
     * @param mode The gamemode to apply defaults for.
     */
    applyDefaults(controlPoints, difficulty, mode) {
        var _a;
        this._kiai = controlPoints.effect.controlPointAt(this.startTime + HitObject.controlPointLeniency).isKiai;
        (_a = this.hitWindow) !== null && _a !== void 0 ? _a : (this.hitWindow = this.createHitWindow(mode));
        if (this.hitWindow) {
            this.hitWindow.overallDifficulty = difficulty.od;
        }
        this.timePreempt = BeatmapDifficulty.difficultyRange(difficulty.ar, HitObject.preemptMax, HitObject.preemptMid, HitObject.preemptMin);
        // Preempt time can go below 450ms. Normally, this is achieved via the DT mod which uniformly speeds up all animations game wide regardless of AR.
        // This uniform speedup is hard to match 1:1, however we can at least make AR>10 (via mods) feel good by extending the upper linear function above.
        // Note that this doesn't exactly match the AR>10 visuals as they're classically known, but it feels good.
        // This adjustment is necessary for AR>10, otherwise timePreempt can become smaller leading to hit circles not fully fading in.
        this.timeFadeIn =
            400 * Math.min(1, this.timePreempt / HitObject.preemptMin);
        switch (mode) {
            case exports.Modes.droid:
                this.scale = CircleSizeCalculator.droidCSToDroidScale(difficulty.cs);
                this.stackOffsetMultiplier = -4;
                break;
            case exports.Modes.osu:
                this.scale = CircleSizeCalculator.standardCSToStandardScale(difficulty.cs, true);
                this.stackOffsetMultiplier = -6.4;
                break;
        }
    }
    /**
     * Applies samples to this hitobject.
     *
     * @param controlPoints The beatmap control points.
     */
    applySamples(controlPoints) {
        const sampleControlPoint = controlPoints.sample.controlPointAt(this.endTime + HitObject.controlPointLeniency);
        this.samples = this.samples.map((v) => sampleControlPoint.applyTo(v));
    }
    /**
     * Given the previous hitobject in the beatmap, update relevant combo information.
     *
     * @param prev The previous hitobject in the beatmap.
     */
    updateComboInformation(prev) {
        var _a, _b;
        this._comboIndex = (_a = prev === null || prev === void 0 ? void 0 : prev.comboIndex) !== null && _a !== void 0 ? _a : 0;
        this._comboIndexWithOffsets = (_b = prev === null || prev === void 0 ? void 0 : prev.comboIndexWithOffsets) !== null && _b !== void 0 ? _b : 0;
        this._indexInCurrentCombo = prev ? prev.indexInCurrentCombo + 1 : 0;
        if (this.isNewCombo || !prev || prev.type & exports.ObjectTypes.spinner) {
            this._indexInCurrentCombo = 0;
            ++this._comboIndex;
            if (!(this.type & exports.ObjectTypes.spinner)) {
                // Spinners do not affect combo color offsets.
                this._comboIndexWithOffsets += this.comboOffset + 1;
            }
            if (prev) {
                prev.isLastInCombo = true;
            }
        }
    }
    /**
     * Creates a hit sample info based on the sample setting of the first `BankHitSampleInfo.HIT_NORMAL` sample in the `samples` array.
     * If no sample is available, sane default settings will be used instead.
     *
     * In the case an existing sample exists, all settings apart from the sample name will be inherited. This includes volume and bank.
     *
     * @param sampleName The name of the sample.
     * @returns The created hit sample info.
     */
    createHitSampleInfo(sampleName) {
        const sample = this.samples.find((s) => s instanceof BankHitSampleInfo &&
            s.name === BankHitSampleInfo.HIT_NORMAL);
        if (sample) {
            return new BankHitSampleInfo(sampleName, sample.bank, sample.customSampleBank, sample.volume);
        }
        return new BankHitSampleInfo(sampleName, exports.SampleBank.none);
    }
    /**
     * Creates the hit window of this hitobject.
     *
     * A `null` return means that this hitobject has no hit window and timing errors should not be displayed to the user.
     *
     * This will only be called if this hitobject's hit window has not been set externally.
     *
     * @param mode The gamemode to create the hit window for.
     * @returns The created hit window.
     */
    createHitWindow(mode) {
        switch (mode) {
            case exports.Modes.droid:
                return new DroidHitWindow();
            case exports.Modes.osu:
                return new OsuHitWindow();
        }
    }
    /**
     * Evaluates the stacked position of the specified position.
     *
     * @param position The position to evaluate.
     * @returns The stacked position.
     */
    evaluateStackedPosition(position) {
        if ((this.type & exports.ObjectTypes.spinner) > 0 || this.stackHeight === 0) {
            return position;
        }
        return position.add(this.stackOffset);
    }
}
/**
 * The base radius of all hitobjects.
 */
HitObject.baseRadius = 64;
/**
 * Maximum preempt time at AR=0.
 */
HitObject.preemptMax = 1800;
/**
 * Median preempt time at AR=5.
 */
HitObject.preemptMid = 1200;
/**
 * Minimum preempt time at AR=10.
 */
HitObject.preemptMin = 450;
/**
 * A small adjustment to the start time of control points to account for rounding/precision errors.
 */
HitObject.controlPointLeniency = 1;

/**
 * Types of easing.
 *
 * See {@link http://easings.net/ this} page for more samples.
 */
exports.Easing = void 0;
(function (Easing) {
    Easing[Easing["none"] = 0] = "none";
    Easing[Easing["out"] = 1] = "out";
    Easing[Easing["in"] = 2] = "in";
    Easing[Easing["inQuad"] = 3] = "inQuad";
    Easing[Easing["outQuad"] = 4] = "outQuad";
    Easing[Easing["inOutQuad"] = 5] = "inOutQuad";
    Easing[Easing["inCubic"] = 6] = "inCubic";
    Easing[Easing["outCubic"] = 7] = "outCubic";
    Easing[Easing["inOutCubic"] = 8] = "inOutCubic";
    Easing[Easing["inQuart"] = 9] = "inQuart";
    Easing[Easing["outQuart"] = 10] = "outQuart";
    Easing[Easing["inOutQuart"] = 11] = "inOutQuart";
    Easing[Easing["inQuint"] = 12] = "inQuint";
    Easing[Easing["outQuint"] = 13] = "outQuint";
    Easing[Easing["inOutQuint"] = 14] = "inOutQuint";
    Easing[Easing["inSine"] = 15] = "inSine";
    Easing[Easing["outSine"] = 16] = "outSine";
    Easing[Easing["inOutSine"] = 17] = "inOutSine";
    Easing[Easing["inExpo"] = 18] = "inExpo";
    Easing[Easing["outExpo"] = 19] = "outExpo";
    Easing[Easing["inOutExpo"] = 20] = "inOutExpo";
    Easing[Easing["inCirc"] = 21] = "inCirc";
    Easing[Easing["outCirc"] = 22] = "outCirc";
    Easing[Easing["inOutCirc"] = 23] = "inOutCirc";
    Easing[Easing["inElastic"] = 24] = "inElastic";
    Easing[Easing["outElastic"] = 25] = "outElastic";
    Easing[Easing["outElasticHalf"] = 26] = "outElasticHalf";
    Easing[Easing["outElasticQuarter"] = 27] = "outElasticQuarter";
    Easing[Easing["inOutElastic"] = 28] = "inOutElastic";
    Easing[Easing["inBack"] = 29] = "inBack";
    Easing[Easing["outBack"] = 30] = "outBack";
    Easing[Easing["inOutBack"] = 31] = "inOutBack";
    Easing[Easing["inBounce"] = 32] = "inBounce";
    Easing[Easing["outBounce"] = 33] = "outBounce";
    Easing[Easing["inOutBounce"] = 34] = "inOutBounce";
    Easing[Easing["outPow10"] = 35] = "outPow10";
})(exports.Easing || (exports.Easing = {}));

/**
 * Represents a `Mod` specific setting.
 */
class ModSetting {
    /**
     * The default value of this `ModSetting`.
     */
    get defaultValue() {
        return this._value;
    }
    set defaultValue(value) {
        this._defaultValue = value;
    }
    /**
     * The value of this `ModSetting`.
     */
    get value() {
        return this._value;
    }
    set value(value) {
        if (this._value !== value) {
            const oldValue = this._value;
            this._value = value;
            for (const listener of this.valueChangedListeners) {
                listener(oldValue, value);
            }
        }
    }
    /**
     * Whether this `ModSetting` is set to its default value.
     */
    get isDefault() {
        return this._value === this.defaultValue;
    }
    constructor(name, description, defaultValue) {
        /**
         * The formatter to display the value of this `ModSetting`.
         */
        this.displayFormatter = (v) => `${v}`;
        this.valueChangedListeners = new Set();
        this.name = name;
        this.description = description;
        this._defaultValue = defaultValue;
        this._value = defaultValue;
    }
    /**
     * Returns a string representation of this `ModSetting`'s value.
     *
     * @returns A string representation of this `ModSetting`'s value.
     */
    toDisplayString() {
        return this.displayFormatter(this.value);
    }
    /**
     * Binds an action that will be called when the value of this `ModSetting` changes.
     *
     * @param listener The action to call when the value of this `ModSetting` changes.
     * @param runOnceImmediately Whether to call the action immediately with the current value of this `ModSetting`.
     */
    bindValueChanged(listener, runOnceImmediately = false) {
        this.valueChangedListeners.add(listener);
        if (runOnceImmediately) {
            listener(this.value, this.value);
        }
    }
    /**
     * Unbinds an action that was previously bound to this `ModSetting`.
     *
     * @param listener The action to unbind.
     */
    unbindValueChanged(listener) {
        this.valueChangedListeners.delete(listener);
    }
}

/**
 * Represents a mod.
 */
class Mod {
    constructor() {
        /**
         * Whether this `Mod` is playable by a real human user.
         *
         * Should be `false` for cases where the user is not meant to apply the `Mod` by themselves.
         */
        this.userPlayable = true;
        /**
         * `Mod`s that are incompatible with this `Mod`.
         */
        this.incompatibleMods = new Set();
        this.settingsBacking = null;
    }
    /**
     * `ModSetting`s that are specific to this `Mod`.
     */
    get settings() {
        if (this.settingsBacking !== null) {
            return this.settingsBacking;
        }
        this.settingsBacking = [];
        for (const prop in this) {
            const value = this[prop];
            if (value instanceof ModSetting) {
                this.settingsBacking.push(value);
            }
        }
        return this.settingsBacking;
    }
    /**
     * Whether all `ModSetting`s of this `Mod` are set to their default values.
     */
    get usesDefaultSettings() {
        return this.settings.every((s) => s.isDefault);
    }
    /**
     * Serializes this `Mod` to a `SerializedMod`.
     */
    serialize() {
        var _a;
        const serialized = {
            acronym: this.acronym,
            settings: (_a = this.serializeSettings()) !== null && _a !== void 0 ? _a : undefined,
        };
        if (!serialized.settings) {
            delete serialized.settings;
        }
        return serialized;
    }
    /**
     * Copies the settings of a `SerializedMod` to this `Mod`.
     *
     * @param mod The `SerializedMod` to copy the settings from. Must be the same `Mod` type.
     * @throws {TypeError} If the `SerializedMod` is not the same type as this `Mod`.
     */
    copySettings(mod) {
        if (mod.acronym !== this.acronym) {
            throw new TypeError(`Cannot copy settings from ${mod.acronym} to ${this.acronym}`);
        }
    }
    /**
     * Whether this `Mod` can be applied to osu!droid.
     */
    isApplicableToDroid() {
        return "droidRanked" in this;
    }
    /**
     * Whether this `Mod` can be applied to osu!standard.
     */
    isApplicableToOsu() {
        return "osuRanked" in this;
    }
    /**
     * Whether this `Mod` can be applied to osu!standard, specifically the osu!stable client.
     */
    isApplicableToOsuStable() {
        return "bitwise" in this;
    }
    /**
     * Whether this `Mod` can be applied to a `Beatmap`.
     */
    isApplicableToBeatmap() {
        return "applyToBeatmap" in this;
    }
    /**
     * Whether this `Mod` can be applied to a `BeatmapDifficulty`.
     */
    isApplicableToDifficulty() {
        return "applyToDifficulty" in this;
    }
    /**
     * Whether this `Mod` can be applied to a `BeatmapDifficulty` relative to other `Mod`s and settings.
     */
    isApplicableToDifficultyWithMods() {
        return "applyToDifficultyWithMods" in this;
    }
    /**
     * Whether this `Mod` can be applied to a `HitObject`.
     */
    isApplicableToHitObject() {
        return "applyToHitObject" in this;
    }
    /**
     * Whether this `Mod` can be applied to a `HitObject` relative to other `Mod`s and settings.
     */
    isApplicableToHitObjectWithMods() {
        return "applyToHitObjectWithMods" in this;
    }
    /**
     * Whether this `Mod` can be applied to a track's playback rate.
     */
    isApplicableToTrackRate() {
        return "applyToRate" in this;
    }
    /**
     * Whether this `Mod` is migratable to a new `Mod` in osu!droid.
     */
    isMigratableDroidMod() {
        return "migrateDroidMod" in this;
    }
    /**
     * Whether this `Mod` facilitates adjustment to a `HitObject` or `BeatmapDifficulty`.
     */
    facilitatesAdjustment() {
        return "facilitateAdjustment" in this;
    }
    /**
     * Serializes the settings of this `Mod` to an object that can be converted to a JSON.
     *
     * @returns The serialized settings of this `Mod`, or `null` if there are no settings.
     */
    serializeSettings() {
        return null;
    }
    /**
     * Compares this `Mod` to another `Mod` for equality.
     *
     * @param other The object to compare to.
     * @returns `true` if the object is the same `Mod`, `false` otherwise.
     */
    equals(other) {
        if (this === other) {
            return true;
        }
        if (this.acronym !== other.acronym) {
            return false;
        }
        const settings = this.settings;
        const otherSettings = other.settings;
        if (settings.length !== otherSettings.length) {
            return false;
        }
        for (const setting of settings) {
            const otherSetting = otherSettings.find((s) => s.name === setting.name);
            if (!otherSetting) {
                return false;
            }
            if (setting.value !== otherSetting.value) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns the string representation of this `Mod`.
     */
    toString() {
        return this.acronym;
    }
}

/**
 * Represents a hitobject that can be nested within a slider.
 */
class SliderNestedHitObject extends HitObject {
    constructor(values) {
        super(values);
        this.spanIndex = values.spanIndex;
        this.spanStartTime = values.spanStartTime;
    }
    toString() {
        return `Position: [${this._position.x}, ${this._position.y}], span index: ${this.spanIndex}, span start time: ${this.spanStartTime}`;
    }
}

/**
 * Represents the head of a slider.
 */
class SliderHead extends SliderNestedHitObject {
    constructor(values) {
        super(Object.assign(Object.assign({}, values), { spanIndex: 0, spanStartTime: values.startTime }));
    }
}

/**
 * An empty `HitWindow` that does not have any hit windows.
 *
 * No time values are provided (meaning instantaneous hit or miss).
 */
class EmptyHitWindow extends HitWindow {
    constructor() {
        super(0);
    }
    get greatWindow() {
        return 0;
    }
    get okWindow() {
        return 0;
    }
    get mehWindow() {
        return 0;
    }
}

/**
 * Represents a nested hit object that is at the end of a slider path (either repeat or tail).
 */
class SliderEndCircle extends SliderNestedHitObject {
    constructor(values) {
        super(values);
        this.sliderSpanDuration = values.sliderSpanDuration;
        this.sliderStartTime = values.sliderStartTime;
    }
    applyDefaults(controlPoints, difficulty, mode) {
        super.applyDefaults(controlPoints, difficulty, mode);
        if (this.spanIndex > 0) {
            // Repeat points after the first span should appear behind the still-visible one.
            this.timeFadeIn = 0;
            // The next end circle should appear exactly after the previous circle (on the same end) is hit.
            this.timePreempt = this.sliderSpanDuration * 2;
        }
        else {
            // The first end circle should fade in with the slider.
            this.timePreempt += this.startTime - this.sliderStartTime;
        }
    }
    createHitWindow() {
        return new EmptyHitWindow();
    }
}

/**
 * Represents a slider repeat.
 */
class SliderRepeat extends SliderEndCircle {
}

/**
 * Represents a slider tick in a slider.
 */
class SliderTick extends SliderNestedHitObject {
    applyDefaults(controlPoints, difficulty, mode) {
        super.applyDefaults(controlPoints, difficulty, mode);
        let offset;
        if (this.spanIndex > 0) {
            // Adding 200 to include the offset stable used.
            // This is so on repeats ticks don't appear too late to be visually processed by the player.
            offset = 200;
        }
        else {
            offset = this.timePreempt * 0.66;
        }
        this.timePreempt = (this.startTime - this.spanStartTime) / 2 + offset;
    }
    createHitWindow() {
        return new EmptyHitWindow();
    }
}

/**
 * Represents the tail of a slider.
 */
class SliderTail extends SliderEndCircle {
}

/**
 * Describes a value that can be cached.
 */
class Cached {
    /**
     * The cached value.
     */
    get value() {
        if (!this._isValid) {
            throw new Error("May not query value of an invalid cache.");
        }
        return this._value;
    }
    /**
     * The cached value.
     */
    set value(value) {
        this._value = value;
        this._isValid = true;
    }
    /**
     * Whether the cache is valid.
     */
    get isValid() {
        return this._isValid;
    }
    constructor(value) {
        this._isValid = true;
        this._value = value;
    }
    /**
     * Invalidates the cache of this `Cached`.
     *
     * @return `true` if the cache was invalidated from a valid state.
     */
    invalidate() {
        if (this._isValid) {
            this._isValid = false;
            return true;
        }
        return false;
    }
}

/**
 * Represents a gameplay hit sample that is meant to be played sequentially at specific times.
 */
class SequenceHitSampleInfo {
    /**
     * Whether this `SequenceHitSampleInfo` contains no `TimedHitSampleInfo`s.
     */
    get isEmpty() {
        return this.samples.length === 0;
    }
    constructor(samples) {
        this.samples = samples;
    }
    /**
     * Obtains the `TimedHitSampleInfo` to play at a given time.
     *
     * @param time The time, in milliseconds.
     * @return The `TimedHitSampleInfo` to play at the given time,
     * or `null` if no `TimedHitSampleInfo`s should be played.
     */
    sampleAt(time) {
        if (this.isEmpty || time < this.samples[0].time) {
            return null;
        }
        const lastSample = this.samples[this.samples.length - 1];
        if (time >= lastSample.time) {
            return lastSample;
        }
        let l = 0;
        let r = this.samples.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            const sample = this.samples[pivot];
            if (sample.time < time) {
                l = pivot + 1;
            }
            else if (sample.time > time) {
                r = pivot - 1;
            }
            else {
                return sample;
            }
        }
        // l will be the first sample with time > sample.time, but we want the one before it
        return this.samples[l - 1];
    }
}

/**
 * A `HitSampleInfo` that has a time associated with it.
 */
class TimedHitSampleInfo {
    constructor(time, sample) {
        this.time = time;
        this.sample = sample;
    }
}

/**
 * Represents a custom gameplay hit sample that can be loaded from files.
 */
class FileHitSampleInfo extends HitSampleInfo {
    get lookupNames() {
        const names = [];
        names.push(this.filename);
        // Fallback to file name without extension.
        const extensionIndex = this.filename.lastIndexOf(".");
        if (extensionIndex !== -1) {
            names.push(this.filename.substring(0, extensionIndex));
        }
        return names;
    }
    constructor(filename, volume = 0) {
        super(volume);
        this.filename = filename;
    }
}

/**
 * Represents a slider in a beatmap.
 */
class Slider extends HitObject {
    get position() {
        return super.position;
    }
    set position(value) {
        super.position = value;
        this.updateNestedPositions();
    }
    get endTime() {
        return (this.startTime + (this.spanCount * this.distance) / this.velocity);
    }
    get endPosition() {
        if (!this.endPositionCache.isValid) {
            this.endPositionCache.value = this.position.add(this.curvePositionAt(1));
        }
        return this.endPositionCache.value;
    }
    /**
     * The slider's path.
     */
    get path() {
        return this._path;
    }
    /**
     * The slider's path.
     */
    set path(value) {
        this._path = value;
        this.updateNestedPositions();
    }
    /**
     * The slider's velocity.
     */
    get velocity() {
        return this._velocity;
    }
    /**
     * The distance of this slider.
     */
    get distance() {
        return this.path.expectedDistance;
    }
    /**
     * The amount of times this slider repeats.
     */
    get repeatCount() {
        return this._repeatCount;
    }
    /**
     * The amount of times this slider repeats.
     */
    set repeatCount(value) {
        this._repeatCount = Math.max(0, value);
        this.updateNestedPositions();
    }
    /**
     * The amount of times the length of this slider spans.
     */
    get spanCount() {
        return this._repeatCount + 1;
    }
    /**
     * The spacing between slider ticks of this slider.
     */
    get tickDistance() {
        return this._tickDistance;
    }
    /**
     * The length of one span of this slider.
     */
    get spanDuration() {
        return this.duration / this.spanCount;
    }
    /**
     * The slider's head.
     */
    get head() {
        return this._head;
    }
    /**
     * The slider's tail.
     */
    get tail() {
        return this._tail;
    }
    /**
     * The amount of slider ticks in this slider.
     *
     * This iterates through all nested objects and should be stored locally or used sparingly.
     */
    get ticks() {
        return this.nestedHitObjects.filter((v) => v instanceof SliderTick)
            .length;
    }
    get stackHeight() {
        return this._stackHeight;
    }
    set stackHeight(value) {
        super.stackHeight = value;
        for (const nestedObject of this.nestedHitObjects) {
            nestedObject.stackHeight = value;
        }
    }
    get scale() {
        return this._scale;
    }
    set scale(value) {
        super.scale = value;
        for (const nestedObject of this.nestedHitObjects) {
            nestedObject.scale = value;
        }
    }
    constructor(values) {
        super(values);
        /**
         * The nested hitobjects of the slider. Consists of headcircle (sliderhead), slider ticks, repeat points, and tailcircle (sliderend).
         */
        this.nestedHitObjects = [];
        /**
         * The slider's velocity.
         */
        this._velocity = 0;
        /**
         * The spacing between slider ticks of this slider.
         */
        this._tickDistance = 0;
        /**
         * Whether slider ticks should be generated by this object.
         *
         * This exists for backwards compatibility with maps that abuse NaN slider velocity behavior on osu!stable (e.g. /b/2628991).
         */
        this.generateTicks = true;
        this._path = values.path;
        this.nodeSamples = values.nodeSamples;
        this._repeatCount = values.repeatCount;
        this.endPositionCache = new Cached(this.position.add(this.curvePositionAt(1)));
        this.tickDistanceMultiplier = values.tickDistanceMultiplier;
        this._head = new SliderHead({
            position: this._position,
            startTime: this.startTime,
        });
        this._tail = new SliderTail({
            sliderStartTime: this.startTime,
            sliderSpanDuration: this.spanDuration,
            position: this.endPosition,
            startTime: this.endTime,
            spanIndex: this.spanCount - 1,
            spanStartTime: this.startTime + this.spanDuration * this.spanCount,
        });
    }
    applyDefaults(controlPoints, difficulty, mode) {
        super.applyDefaults(controlPoints, difficulty, mode);
        const timingPoint = controlPoints.timing.controlPointAt(this.startTime);
        const difficultyPoint = controlPoints.difficulty.controlPointAt(this.startTime);
        const sliderVelocityAsBeatLength = -100 / difficultyPoint.speedMultiplier;
        const bpmMultiplier = sliderVelocityAsBeatLength < 0
            ? MathUtils.clamp(Math.fround(-sliderVelocityAsBeatLength), 10, 1000) / 100
            : 1;
        this._velocity =
            (100 * difficulty.sliderMultiplier) /
                (timingPoint.msPerBeat * bpmMultiplier);
        // WARNING: this is intentionally not computed as `BASE_SCORING_DISTANCE * difficulty.sliderMultiplier`
        // for backwards compatibility reasons (intentionally introducing floating point errors to match osu!stable).
        const scoringDistance = this.velocity * timingPoint.msPerBeat;
        this.generateTicks = difficultyPoint.generateTicks;
        this._tickDistance = this.generateTicks
            ? (scoringDistance / difficulty.sliderTickRate) *
                this.tickDistanceMultiplier
            : Number.POSITIVE_INFINITY;
        this.createNestedHitObjects(controlPoints);
        this.nestedHitObjects.forEach((v) => v.applyDefaults(controlPoints, difficulty, mode));
    }
    applySamples(controlPoints) {
        super.applySamples(controlPoints);
        this.nodeSamples.forEach((nodeSample, i) => {
            const time = this.startTime +
                i * this.spanDuration +
                HitObject.controlPointLeniency;
            const nodeSamplePoint = controlPoints.sample.controlPointAt(time);
            this.nodeSamples[i] = nodeSample.map((v) => nodeSamplePoint.applyTo(v));
        });
        // Create sliding samples
        this.createSlidingSamples(controlPoints);
        this.updateNestedSamples(controlPoints);
    }
    /**
     * Computes the position on this slider relative to how much of the slider has been completed.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns The position on this slider at the given progress.
     */
    curvePositionAt(progress) {
        return this.path.positionAt(this.progressAt(progress));
    }
    /**
     * Computes the progress along this slider relative to how much of the slider has been completed.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns `[0, 1]` where 0 is the beginning of this slider and 1 is the end of this slider.
     */
    progressAt(progress) {
        let p = (progress * this.spanCount) % 1;
        if (this.spanAt(progress) % 2 === 1) {
            p = 1 - p;
        }
        return p;
    }
    /**
     * Determines which span of this slider the progress point is on.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns `[0, spanCount)` where 0 is the first run.
     */
    spanAt(progress) {
        return Math.floor(progress * this.spanCount);
    }
    createHitWindow() {
        return new EmptyHitWindow();
    }
    createNestedHitObjects(controlPoints) {
        this.nestedHitObjects.length = 0;
        this._head = new SliderHead({
            position: this.position,
            startTime: this.startTime,
        });
        this.nestedHitObjects.push(this.head);
        // A very lenient maximum length of a slider for ticks to be generated.
        // This exists for edge cases such as /b/1573664 where the beatmap has been edited by the user, and should never be reached in normal usage.
        const maxLength = 100000;
        const length = Math.min(maxLength, this.path.expectedDistance);
        const tickDistance = MathUtils.clamp(this.tickDistance, 0, length);
        const minDistanceFromEnd = this.velocity * 10;
        for (let span = 0; span < this.spanCount; ++span) {
            const spanStartTime = this.startTime + span * this.spanDuration;
            if (tickDistance !== 0 && this.generateTicks) {
                const reversed = span % 2 === 1;
                const sliderTicks = [];
                for (let d = tickDistance; d <= length; d += tickDistance) {
                    if (d >= length - minDistanceFromEnd) {
                        break;
                    }
                    // Always generate ticks from the start of the path rather than the span to ensure that ticks in repeat spans are positioned identically to those in non-repeat spans
                    const distanceProgress = d / length;
                    const timeProgress = reversed
                        ? 1 - distanceProgress
                        : distanceProgress;
                    const sliderTickPosition = this.position.add(this.path.positionAt(distanceProgress));
                    const sliderTick = new SliderTick({
                        startTime: spanStartTime + timeProgress * this.spanDuration,
                        position: sliderTickPosition,
                        spanIndex: span,
                        spanStartTime: spanStartTime,
                    });
                    // Inherit the slider's preempt and fade in times for now. They may be overridden
                    // in applyDefaults later.
                    sliderTick.timePreempt = this.timePreempt;
                    sliderTick.timeFadeIn = this.timeFadeIn;
                    sliderTicks.push(sliderTick);
                }
                // For repeat spans, ticks are returned in reverse-StartTime order.
                if (reversed) {
                    sliderTicks.reverse();
                }
                this.nestedHitObjects.push(...sliderTicks);
            }
            if (span < this.spanCount - 1) {
                const repeatPosition = this.position.add(this.path.positionAt((span + 1) % 2));
                const repeatPoint = new SliderRepeat({
                    sliderStartTime: this.startTime,
                    sliderSpanDuration: this.spanDuration,
                    position: repeatPosition,
                    startTime: spanStartTime + this.spanDuration,
                    spanIndex: span,
                    spanStartTime: spanStartTime,
                });
                this.nestedHitObjects.push(repeatPoint);
            }
        }
        this._tail = new SliderTail({
            sliderStartTime: this.startTime,
            sliderSpanDuration: this.spanDuration,
            position: this.endPosition,
            startTime: this.endTime,
            spanIndex: this.spanCount - 1,
            spanStartTime: this.startTime + this.spanDuration * this.spanCount,
        });
        this.nestedHitObjects.push(this.tail);
        this.nestedHitObjects.sort((a, b) => a.startTime - b.startTime);
        this.updateNestedSamples(controlPoints);
    }
    updateNestedPositions() {
        this.endPositionCache.invalidate();
        this.head.position = this.position;
        this.tail.position = this.endPosition;
        for (let i = 1; i < this.nestedHitObjects.length - 1; ++i) {
            const nestedObject = this.nestedHitObjects[i];
            const progress = (nestedObject.startTime - this.startTime) / this.duration;
            nestedObject.position = this.position.add(this.curvePositionAt(progress));
        }
    }
    createSlidingSamples(controlPoints) {
        this.auxiliarySamples.length = 0;
        const bankSamples = this.samples.filter((v) => v instanceof BankHitSampleInfo);
        const normalSample = bankSamples.find((v) => v.name === BankHitSampleInfo.HIT_NORMAL);
        const whistleSample = bankSamples.find((v) => v.name === BankHitSampleInfo.HIT_WHISTLE);
        if (!normalSample && !whistleSample) {
            return;
        }
        const samplePoints = controlPoints.sample.between(this.startTime + Slider.controlPointLeniency, this.endTime + Slider.controlPointLeniency);
        if (normalSample) {
            this.auxiliarySamples.push(new SequenceHitSampleInfo(samplePoints.map((s) => new TimedHitSampleInfo(s.time, s.applyTo(Slider.baseNormalSlideSample)))));
        }
        if (whistleSample) {
            this.auxiliarySamples.push(new SequenceHitSampleInfo(samplePoints.map((s) => new TimedHitSampleInfo(s.time, s.applyTo(Slider.baseWhistleSlideSample)))));
        }
    }
    updateNestedSamples(controlPoints) {
        var _a;
        // Ensure that the list of node samples is at least as long as the number of nodes.
        while (this.nodeSamples.length < this.repeatCount + 2) {
            this.nodeSamples.push(this.samples.map((s) => {
                if (s instanceof BankHitSampleInfo) {
                    return new BankHitSampleInfo(s.name, s.bank, s.customSampleBank, s.volume, s.isLayered);
                }
                else if (s instanceof FileHitSampleInfo) {
                    return new FileHitSampleInfo(s.filename, s.volume);
                }
                else {
                    throw new TypeError("Unknown type of hit sample info.");
                }
            }));
        }
        for (const nestedObject of this.nestedHitObjects) {
            nestedObject.samples.length = 0;
            if (nestedObject instanceof SliderHead) {
                nestedObject.samples.push(...this.nodeSamples[0]);
            }
            else if (nestedObject instanceof SliderRepeat) {
                nestedObject.samples.push(...this.nodeSamples[nestedObject.spanIndex + 1]);
            }
            else if (nestedObject instanceof SliderTail) {
                nestedObject.samples.push(...this.nodeSamples[this.spanCount]);
            }
            else {
                const time = nestedObject.startTime + Slider.controlPointLeniency;
                const tickSamplePoint = controlPoints.sample.controlPointAt(time);
                nestedObject.samples.push(tickSamplePoint.applyTo(Slider.baseTickSample));
            }
        }
        const bankSamples = this.samples.filter((v) => v instanceof BankHitSampleInfo);
        const normalSample = (_a = bankSamples.find((v) => v.name === BankHitSampleInfo.HIT_NORMAL)) !== null && _a !== void 0 ? _a : bankSamples.at(0);
        const sampleList = [];
        if (normalSample) {
            sampleList.push(new BankHitSampleInfo("slidertick", normalSample.bank, normalSample.customSampleBank, normalSample.volume, normalSample.isLayered));
        }
        const getSample = (index) => { var _a; return (_a = this.nodeSamples.at(index)) !== null && _a !== void 0 ? _a : this.samples; };
        this.nestedHitObjects.forEach((v) => {
            switch (true) {
                case v instanceof SliderHead:
                    v.samples.push(...getSample(0));
                    break;
                case v instanceof SliderRepeat:
                    v.samples.push(...getSample(v.spanIndex + 1));
                    break;
                case v instanceof SliderTail:
                    v.samples.push(...getSample(this.spanCount));
                    break;
                default:
                    v.samples.push(...sampleList);
            }
        });
    }
    toString() {
        return `Position: [${this.position.x}, ${this.position.y}], distance: ${this.path.expectedDistance}, repeat count: ${this.repeatCount}, slider ticks: ${this.nestedHitObjects.filter((v) => v instanceof SliderTick).length}`;
    }
}
Slider.baseNormalSlideSample = new BankHitSampleInfo("sliderslide");
Slider.baseWhistleSlideSample = new BankHitSampleInfo("sliderwhistle");
Slider.baseTickSample = new BankHitSampleInfo("slidertick");
Slider.legacyLastTickOffset = 36;

/**
 * Represents the Freeze Frame mod.
 */
class ModFreezeFrame extends Mod {
    constructor() {
        super();
        this.name = "Freeze Frame";
        this.acronym = "FR";
        this.lastNewComboTime = 0;
        this.incompatibleMods.add(ModApproachDifferent);
    }
    get droidRanked() {
        return false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get osuRanked() {
        return false;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
    applyToBeatmap(beatmap) {
        this.lastNewComboTime = 0;
        for (const hitObject of beatmap.hitObjects) {
            if (hitObject.isNewCombo) {
                this.lastNewComboTime = hitObject.startTime;
            }
            this.applyFadeInAdjustment(hitObject);
        }
    }
    applyFadeInAdjustment(hitObject) {
        hitObject.timePreempt += hitObject.startTime - this.lastNewComboTime;
        if (hitObject instanceof Slider) {
            // Freezing slider ticks doesn't play well with snaking sliders, and slider repeats will not
            // layer correctly if its preempt is changed.
            this.applyFadeInAdjustment(hitObject.head);
            this.applyFadeInAdjustment(hitObject.tail);
        }
    }
}

/**
 * Represents the Traceable mod.
 */
class ModTraceable extends Mod {
    constructor() {
        super();
        this.acronym = "TC";
        this.name = "Traceable";
        this.droidRanked = false;
        this.osuRanked = false;
        this.incompatibleMods.add(ModHidden);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.06;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents a `Mod` specific setting that is constrained to a boolean value.
 */
class BooleanModSetting extends ModSetting {
    constructor() {
        super(...arguments);
        this.displayFormatter = (v) => v ? "Enabled" : "Disabled";
    }
}

/**
 * Represents the Hidden mod.
 */
class ModHidden extends Mod {
    get droidRanked() {
        return this.usesDefaultSettings;
    }
    get osuRanked() {
        return this.usesDefaultSettings;
    }
    constructor() {
        super();
        this.acronym = "HD";
        this.name = "Hidden";
        this.bitwise = 1 << 3;
        /**
         * Whether to only fade approach circles.
         *
         * The main object body will not fade when enabled.
         */
        this.onlyFadeApproachCircles = new BooleanModSetting("Only fade approach circles", "The main object body will not fade when enabled.", false);
        this.incompatibleMods.add(ModTraceable).add(ModApproachDifferent);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.06;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1.06;
    }
    copySettings(mod) {
        var _a, _b;
        super.copySettings(mod);
        this.onlyFadeApproachCircles.value =
            (_b = (_a = mod.settings) === null || _a === void 0 ? void 0 : _a.onlyFadeApproachCircles) !== null && _b !== void 0 ? _b : this.onlyFadeApproachCircles.value;
    }
    applyToBeatmap(beatmap) {
        const applyFadeInAdjustment = (hitObject) => {
            hitObject.timeFadeIn =
                hitObject.timePreempt * ModHidden.fadeInDurationMultiplier;
            if (hitObject instanceof Slider) {
                hitObject.nestedHitObjects.forEach(applyFadeInAdjustment);
            }
        };
        beatmap.hitObjects.objects.forEach(applyFadeInAdjustment);
    }
    serializeSettings() {
        return this.onlyFadeApproachCircles.value
            ? { onlyFadeApproachCircles: this.onlyFadeApproachCircles.value }
            : null;
    }
    toString() {
        if (!this.onlyFadeApproachCircles.value) {
            return super.toString();
        }
        return `${super.toString()} (approach circles only)`;
    }
}
ModHidden.fadeInDurationMultiplier = 0.4;
ModHidden.fadeOutDurationMultiplier = 0.3;

/**
 * Represents a `Mod` specific setting that is constrained to a range of values.
 */
class RangeConstrainedModSetting extends ModSetting {
    /**
     * The minimum value of this `RangeConstrainedModSetting`.
     */
    get min() {
        return this._min;
    }
    set min(value) {
        this._min = value;
        this.value = this.processValue(this.value);
    }
    /**
     * The maximum value of this `RangeConstrainedModSetting`.
     */
    get max() {
        return this._max;
    }
    set max(value) {
        this._max = value;
        this.value = this.processValue(this.value);
    }
    /**
     * The step size of this `RangeConstrainedModSetting`.
     */
    get step() {
        return this._step;
    }
    set step(value) {
        this._step = value;
        this.value = this.processValue(this.value);
    }
    get value() {
        return super.value;
    }
    set value(value) {
        super.value = this.processValue(value);
    }
    constructor(name, description, defaultValue, min, max, step) {
        super(name, description, defaultValue);
        this._min = min;
        this._max = max;
        this._step = step;
    }
}

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 */
class NumberModSetting extends RangeConstrainedModSetting {
    constructor(name, description, defaultValue, min, max, step) {
        super(name, description, defaultValue, min, max, step);
        this.displayFormatter = (v) => v.toString();
        if (min > max) {
            throw new RangeError(`The minimum value (${min}) must be less than or equal to the maximum value (${max}).`);
        }
        if (step < 0) {
            throw new RangeError(`The step size (${step}) must be greater than or equal to 0.`);
        }
        if (defaultValue < min || defaultValue > max) {
            throw new RangeError(`The default value (${defaultValue}) must be between the minimum (${min}) and maximum (${max}) values.`);
        }
    }
    processValue(value) {
        return MathUtils.clamp(Math.round(value / this.step) * this.step, this.min, this.max);
    }
}

/**
 * Represents a `Mod` specific setting that is constrained to a range of decimal values.
 */
class DecimalModSetting extends NumberModSetting {
    /**
     * The number of decimal places to round the value to.
     *
     * When set to `null`, the value will not be rounded.
     */
    get precision() {
        return this._precision;
    }
    set precision(value) {
        if (value !== null && value < 0) {
            throw new RangeError(`The precision (${value}) must be greater than or equal to 0.`);
        }
        this._precision = value;
        if (value !== null) {
            this.value = this.processValue(this.value);
        }
    }
    constructor(name, description, defaultValue, min = -Number.MAX_VALUE, max = Number.MAX_VALUE, step = 0, precision = null) {
        super(name, description, defaultValue, min, max, step);
        this.displayFormatter = (v) => {
            if (this.precision !== null) {
                return v.toFixed(this.precision);
            }
            return super.toDisplayString();
        };
        if (precision !== null && precision < 0) {
            throw new RangeError(`The precision (${precision}) must be greater than or equal to 0.`);
        }
        this._precision = precision;
    }
    processValue(value) {
        const processedValue = super.processValue(value);
        if (this.precision !== null) {
            return parseFloat(processedValue.toFixed(this.precision));
        }
        return processedValue;
    }
}

/**
 * Represents the Approach Different mod.
 */
class ModApproachDifferent extends Mod {
    /**
     * The {@link Easing} to apply to the approach circle animation.
     */
    get easing() {
        switch (this.style.value) {
            case exports.AnimationStyle.linear:
                return exports.Easing.none;
            case exports.AnimationStyle.gravity:
                return exports.Easing.inBack;
            case exports.AnimationStyle.inOut1:
                return exports.Easing.inOutCubic;
            case exports.AnimationStyle.inOut2:
                return exports.Easing.inOutQuint;
            case exports.AnimationStyle.accelerate1:
                return exports.Easing.in;
            case exports.AnimationStyle.accelerate2:
                return exports.Easing.inCubic;
            case exports.AnimationStyle.accelerate3:
                return exports.Easing.inQuint;
            case exports.AnimationStyle.decelerate1:
                return exports.Easing.out;
            case exports.AnimationStyle.decelerate2:
                return exports.Easing.outCubic;
            case exports.AnimationStyle.decelerate3:
                return exports.Easing.outQuint;
        }
    }
    constructor() {
        super();
        this.name = "Approach Different";
        this.acronym = "AD";
        /**
         * The initial size of the approach circle, relative to hit circles.
         */
        this.scale = new DecimalModSetting("Initial size", "The initial size of the approach circle, relative to hit circles.", 3, 1.5, 10, 0.1, 1);
        /**
         * The animation style of the approach circles.
         */
        this.style = new ModSetting("Style", "The animation style of the approach circles.", exports.AnimationStyle.gravity);
        this.incompatibleMods.add(ModHidden).add(ModFreezeFrame);
    }
    get droidRanked() {
        return false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get osuRanked() {
        return false;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
    copySettings(mod) {
        super.copySettings(mod);
        const { settings } = mod;
        if (typeof (settings === null || settings === void 0 ? void 0 : settings.scale) === "number") {
            this.scale.value = settings.scale;
        }
        if (typeof (settings === null || settings === void 0 ? void 0 : settings.style) === "number") {
            this.style.value = settings.style;
        }
    }
    serializeSettings() {
        return {
            scale: this.scale.value,
            style: this.style.value,
        };
    }
}
exports.AnimationStyle = void 0;
(function (AnimationStyle) {
    AnimationStyle[AnimationStyle["linear"] = 0] = "linear";
    AnimationStyle[AnimationStyle["gravity"] = 1] = "gravity";
    AnimationStyle[AnimationStyle["inOut1"] = 2] = "inOut1";
    AnimationStyle[AnimationStyle["inOut2"] = 3] = "inOut2";
    AnimationStyle[AnimationStyle["accelerate1"] = 4] = "accelerate1";
    AnimationStyle[AnimationStyle["accelerate2"] = 5] = "accelerate2";
    AnimationStyle[AnimationStyle["accelerate3"] = 6] = "accelerate3";
    AnimationStyle[AnimationStyle["decelerate1"] = 7] = "decelerate1";
    AnimationStyle[AnimationStyle["decelerate2"] = 8] = "decelerate2";
    AnimationStyle[AnimationStyle["decelerate3"] = 9] = "decelerate3";
})(exports.AnimationStyle || (exports.AnimationStyle = {}));

/**
 * Represents the Relax mod.
 */
class ModRelax extends Mod {
    constructor() {
        super();
        this.acronym = "RX";
        this.name = "Relax";
        this.droidRanked = false;
        this.osuRanked = false;
        this.bitwise = 1 << 7;
        this.incompatibleMods.add(ModAuto).add(ModAutopilot);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.001;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0;
    }
}

/**
 * Represents the Autopilot mod.
 */
class ModAutopilot extends Mod {
    constructor() {
        super();
        this.acronym = "AP";
        this.name = "Autopilot";
        this.droidRanked = false;
        this.osuRanked = false;
        this.bitwise = 1 << 13;
        this.incompatibleMods.add(ModRelax).add(ModAuto);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.001;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0;
    }
}

/**
 * Represents the Auto mod.
 */
class ModAuto extends Mod {
    constructor() {
        super();
        this.acronym = "AT";
        this.name = "Autoplay";
        this.droidRanked = false;
        this.osuRanked = false;
        this.bitwise = 1 << 11;
        this.incompatibleMods.add(ModAutopilot).add(ModRelax);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents a `Mod` that adjusts the playback rate of a track.
 */
class ModRateAdjust extends Mod {
    /**
     * The generic osu!droid score multiplier of this `Mod`.
     */
    get droidScoreMultiplier() {
        return this.trackRateMultiplier.value >= 1
            ? 1 + (this.trackRateMultiplier.value - 1) * 0.24
            : Math.pow(0.3, (1 - this.trackRateMultiplier.value) * 4);
    }
    /**
     * Generic getter to determine if this `ModRateAdjust` is relevant.
     */
    get isRelevant() {
        return this.trackRateMultiplier.value !== 1;
    }
    constructor(trackRateMultiplier = 1) {
        super();
        this.trackRateMultiplier = new DecimalModSetting("Track rate multiplier", "The multiplier for the track's playback rate after applying this mod.", trackRateMultiplier, 0.5, 2, 0.05, 2);
    }
    applyToRate(_, rate) {
        return rate * this.trackRateMultiplier.value;
    }
}

/**
 * Represents the Custom Speed mod.
 *
 * This is a replacement `Mod` for speed modify in osu!droid and custom rates in osu!lazer.
 */
class ModCustomSpeed extends ModRateAdjust {
    constructor() {
        super(...arguments);
        this.acronym = "CS";
        this.name = "Custom Speed";
        this.droidRanked = true;
        this.osuRanked = false;
    }
    copySettings(mod) {
        var _a, _b;
        super.copySettings(mod);
        this.trackRateMultiplier.value =
            (_b = (_a = mod.settings) === null || _a === void 0 ? void 0 : _a.rateMultiplier) !== null && _b !== void 0 ? _b : this.trackRateMultiplier.value;
    }
    get isDroidRelevant() {
        return this.isRelevant;
    }
    calculateDroidScoreMultiplier() {
        return this.droidScoreMultiplier;
    }
    get isOsuRelevant() {
        return this.isRelevant;
    }
    get osuScoreMultiplier() {
        // Round to the nearest multiple of 0.1.
        let value = Math.trunc(this.trackRateMultiplier.value * 10) / 10;
        // Offset back to 0.
        --value;
        return this.trackRateMultiplier.value >= 1
            ? 1 + value / 5
            : 0.6 + value;
    }
    serializeSettings() {
        return { rateMultiplier: this.trackRateMultiplier.value };
    }
    toString() {
        return `${super.toString()} (${this.trackRateMultiplier.toDisplayString()}x)`;
    }
}

/**
 * Represents a `Mod` that adjusts the size of `HitObject`s during their fade in animation.
 */
class ModObjectScaleTween extends Mod {
    constructor() {
        super();
        /**
         * The final size multiplier applied to all [HitObject]s.
         */
        this.endScale = 1;
        this.incompatibleMods.add(ModObjectScaleTween).add(ModTraceable);
    }
    copySettings(mod) {
        var _a;
        super.copySettings(mod);
        const { settings } = mod;
        this.startScale.value =
            (_a = settings === null || settings === void 0 ? void 0 : settings.startScale) !== null && _a !== void 0 ? _a : this.startScale.value;
    }
    serializeSettings() {
        return { startScale: this.startScale.value };
    }
}

/**
 * Represents the Deflate mod.
 */
class ModDeflate extends ModObjectScaleTween {
    constructor() {
        super(...arguments);
        this.name = "Deflate";
        this.acronym = "DF";
        this.startScale = new DecimalModSetting("Start scale", "The initial size multiplier applied to all hit objects.", 2, 1, 25, 0.1, 1);
    }
    get droidRanked() {
        return false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get osuRanked() {
        return false;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents a circle in a beatmap.
 *
 * All we need from circles is their position. All positions
 * stored in the objects are in playfield coordinates (512*384
 * rectangle).
 */
class Circle extends HitObject {
    constructor(values) {
        super(values);
    }
    toString() {
        return `Position: [${this._position.x}, ${this._position.y}]`;
    }
}

/**
 * Represents the Replay V6 mod.
 *
 * Some behavior of beatmap parsing was changed in replay version 7. More specifically, object stacking
 * behavior now matches osu!stable and osu!lazer.
 *
 * This `Mod` is meant to reapply the stacking behavior prior to replay version 7 to a `Beatmap` that
 * was played in replays recorded in version 6 and older for replayability and difficulty calculation.
 */
class ModReplayV6 extends Mod {
    constructor() {
        super(...arguments);
        this.name = "Replay V6";
        this.acronym = "RV6";
        this.userPlayable = false;
        this.droidRanked = false;
        this.facilitateAdjustment = true;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    applyToBeatmap(beatmap) {
        const { objects } = beatmap.hitObjects;
        if (objects.length === 0) {
            return;
        }
        // Reset stacking
        objects.forEach((h) => {
            h.stackHeight = 0;
        });
        for (let i = 0; i < objects.length - 1; ++i) {
            const current = objects[i];
            const next = objects[i + 1];
            this.revertObjectScale(current, beatmap.difficulty);
            this.revertObjectScale(next, beatmap.difficulty);
            const convertedScale = CircleSizeCalculator.standardScaleToOldDroidScale(objects[0].scale);
            if (current instanceof Circle &&
                next.startTime - current.startTime <
                    2000 * beatmap.general.stackLeniency &&
                next.position.getDistance(current.position) <
                    Math.sqrt(convertedScale)) {
                next.stackHeight = current.stackHeight + 1;
            }
        }
    }
    revertObjectScale(hitObject, difficulty) {
        const droidScale = CircleSizeCalculator.droidCSToOldDroidScale(difficulty.cs);
        const radius = CircleSizeCalculator.oldDroidScaleToStandardRadius(droidScale);
        const standardCS = CircleSizeCalculator.standardRadiusToStandardCS(radius, true);
        hitObject.scale = CircleSizeCalculator.standardCSToStandardScale(standardCS, true);
        hitObject.stackOffsetMultiplier = 4;
    }
}

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 *
 * The value can be `null`, which is treated as a special case.
 */
class NullableDecimalModSetting extends RangeConstrainedModSetting {
    /**
     * The number of decimal places to round the value to.
     *
     * When set to `null`, the value will not be rounded.
     */
    get precision() {
        return this._precision;
    }
    set precision(value) {
        if (value !== null && value < 0) {
            throw new RangeError(`The precision (${value}) must be greater than or equal to 0.`);
        }
        this._precision = value;
        if (value !== null) {
            this.value = this.processValue(this.value);
        }
    }
    constructor(name, description, defaultValue, min = -Number.MAX_VALUE, max = Number.MAX_VALUE, step = 0, precision = null) {
        super(name, description, defaultValue, min, max, step);
        this.displayFormatter = (v) => {
            if (v === null) {
                return "None";
            }
            if (this.precision !== null) {
                return v.toFixed(this.precision);
            }
            return super.toDisplayString();
        };
        if (min > max) {
            throw new RangeError(`The minimum value (${min}) must be less than or equal to the maximum value (${max}).`);
        }
        if (step < 0) {
            throw new RangeError(`The step size (${step}) must be greater than or equal to 0.`);
        }
        if (defaultValue !== null &&
            (defaultValue < min || defaultValue > max)) {
            throw new RangeError(`The default value (${defaultValue}) must be between the minimum (${min}) and maximum (${max}) values.`);
        }
        this._precision = precision;
    }
    processValue(value) {
        if (value === null) {
            return null;
        }
        const processedValue = MathUtils.clamp(Math.round(value / this.step) * this.step, this.min, this.max);
        if (this.precision !== null) {
            return parseFloat(processedValue.toFixed(this.precision));
        }
        return processedValue;
    }
}

/**
 * Represents the Difficulty Adjust mod.
 */
class ModDifficultyAdjust extends Mod {
    get isRelevant() {
        return (this.cs.value !== null ||
            this.ar.value !== null ||
            this.od.value !== null ||
            this.hp.value !== null);
    }
    constructor(values) {
        var _a, _b, _c, _d;
        super();
        this.acronym = "DA";
        this.name = "Difficulty Adjust";
        this.droidRanked = false;
        this.osuRanked = false;
        /**
         * The circle size to enforce.
         */
        this.cs = new NullableDecimalModSetting("Circle size", "The circle size to enforce.", null, 0, 15, 0.1, 1);
        /**
         * The approach rate to enforce.
         */
        this.ar = new NullableDecimalModSetting("Approach rate", "The approach rate to enforce.", null, 0, 11, 0.1, 1);
        /**
         * The overall difficulty to enforce.
         */
        this.od = new NullableDecimalModSetting("Overall difficulty", "The overall difficulty to enforce.", null, 0, 11, 0.1, 1);
        this.hp = new NullableDecimalModSetting("Health drain", "The health drain to enforce.", null, 0, 11, 0.1, 1);
        this.cs.value = (_a = values === null || values === void 0 ? void 0 : values.cs) !== null && _a !== void 0 ? _a : null;
        this.ar.value = (_b = values === null || values === void 0 ? void 0 : values.ar) !== null && _b !== void 0 ? _b : null;
        this.od.value = (_c = values === null || values === void 0 ? void 0 : values.od) !== null && _c !== void 0 ? _c : null;
        this.hp.value = (_d = values === null || values === void 0 ? void 0 : values.hp) !== null && _d !== void 0 ? _d : null;
    }
    copySettings(mod) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super.copySettings(mod);
        this.cs.value = ((_b = (_a = mod.settings) === null || _a === void 0 ? void 0 : _a.cs) !== null && _b !== void 0 ? _b : null);
        this.ar.value = ((_d = (_c = mod.settings) === null || _c === void 0 ? void 0 : _c.ar) !== null && _d !== void 0 ? _d : null);
        this.od.value = ((_f = (_e = mod.settings) === null || _e === void 0 ? void 0 : _e.od) !== null && _f !== void 0 ? _f : null);
        this.hp.value = ((_h = (_g = mod.settings) === null || _g === void 0 ? void 0 : _g.hp) !== null && _h !== void 0 ? _h : null);
    }
    get isDroidRelevant() {
        return this.isRelevant;
    }
    calculateDroidScoreMultiplier(difficulty) {
        // Graph: https://www.desmos.com/calculator/yrggkhrkzz
        let multiplier = 1;
        if (this.cs.value !== null) {
            const diff = this.cs.value - difficulty.cs;
            multiplier *=
                diff >= 0
                    ? 1 + 0.0075 * Math.pow(diff, 1.5)
                    : 2 / (1 + Math.exp(-0.5 * diff));
        }
        if (this.od.value !== null) {
            const diff = this.od.value - difficulty.od;
            multiplier *=
                diff >= 0
                    ? 1 + 0.005 * Math.pow(diff, 1.3)
                    : 2 / (1 + Math.exp(-0.25 * diff));
        }
        return multiplier;
    }
    get isOsuRelevant() {
        return this.isRelevant;
    }
    get osuScoreMultiplier() {
        return 0.5;
    }
    applyToDifficultyWithMods(_, difficulty, mods) {
        var _a, _b, _c, _d;
        difficulty.cs = (_a = this.cs.value) !== null && _a !== void 0 ? _a : difficulty.cs;
        difficulty.ar = (_b = this.ar.value) !== null && _b !== void 0 ? _b : difficulty.ar;
        difficulty.od = (_c = this.od.value) !== null && _c !== void 0 ? _c : difficulty.od;
        difficulty.hp = (_d = this.hp.value) !== null && _d !== void 0 ? _d : difficulty.hp;
        // Special case for force AR in replay version 6 and older, where the AR value is kept constant with
        // respect to game time. This makes the player perceive the AR as is under all speed multipliers.
        if (this.ar.value !== null && mods.has(ModReplayV6)) {
            const preempt = BeatmapDifficulty.difficultyRange(this.ar.value, HitObject.preemptMax, HitObject.preemptMid, HitObject.preemptMin);
            const trackRate = this.calculateTrackRate(mods.values());
            difficulty.ar = BeatmapDifficulty.inverseDifficultyRange(preempt * trackRate, HitObject.preemptMax, HitObject.preemptMid, HitObject.preemptMin);
        }
    }
    applyToHitObjectWithMods(_, hitObject, mods) {
        // Special case for force AR in replay version 6 and older, where the AR value is kept constant with
        // respect to game time. This makes the player perceive the fade in animation as is under all speed
        // multipliers.
        if (this.ar.value === null || !mods.has(ModReplayV6)) {
            return;
        }
        this.applyFadeAdjustment(hitObject, mods);
        if (hitObject instanceof Slider) {
            for (const nested of hitObject.nestedHitObjects) {
                this.applyFadeAdjustment(nested, mods);
            }
        }
    }
    serializeSettings() {
        if (!this.isRelevant) {
            return null;
        }
        const settings = {};
        if (this.cs.value !== null) {
            settings.cs = this.cs.value;
        }
        if (this.ar.value !== null) {
            settings.ar = this.ar.value;
        }
        if (this.od.value !== null) {
            settings.od = this.od.value;
        }
        if (this.hp.value !== null) {
            settings.hp = this.hp.value;
        }
        return settings;
    }
    applyFadeAdjustment(hitObject, mods) {
        // IMPORTANT: These do not use `ModUtil.calculateRateWithMods` to avoid circular dependency.
        const initialTrackRate = this.calculateTrackRate(mods.values());
        const currentTrackRate = this.calculateTrackRate(mods.values(), hitObject.startTime);
        // Cancel the rate that was initially applied to timePreempt (via applyToDifficulty above and
        // HitObject.applyDefaults) and apply the current one.
        hitObject.timePreempt *= currentTrackRate / initialTrackRate;
        hitObject.timeFadeIn *= currentTrackRate;
    }
    calculateTrackRate(mods, time = 0) {
        // IMPORTANT: This does not use `ModUtil.calculateRateWithMods` to avoid circular dependency.
        let rate = 1;
        for (const mod of mods) {
            if (mod.isApplicableToTrackRate()) {
                rate = mod.applyToRate(time, rate);
            }
        }
        return rate;
    }
    toString() {
        if (!this.isRelevant) {
            return super.toString();
        }
        const settings = [];
        if (this.cs.value !== null) {
            settings.push(`CS${this.cs.toDisplayString()}`);
        }
        if (this.ar.value !== null) {
            settings.push(`AR${this.ar.toDisplayString()}`);
        }
        if (this.od.value !== null) {
            settings.push(`OD${this.od.toDisplayString()}`);
        }
        if (this.hp.value !== null) {
            settings.push(`HP${this.hp.toDisplayString()}`);
        }
        return `${super.toString()} (${settings.join(", ")})`;
    }
}

/**
 * Represents the NightCore mod.
 */
class ModNightCore extends ModRateAdjust {
    constructor() {
        super(1.5);
        this.acronym = "NC";
        this.name = "NightCore";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 9;
        this.incompatibleMods.add(ModDoubleTime).add(ModHalfTime);
    }
    get isDroidRelevant() {
        return this.isRelevant;
    }
    calculateDroidScoreMultiplier() {
        return this.droidScoreMultiplier;
    }
    get isOsuRelevant() {
        return this.isRelevant;
    }
    get osuScoreMultiplier() {
        return 1.12;
    }
}

/**
 * Represents the HalfTime mod.
 */
class ModHalfTime extends ModRateAdjust {
    constructor() {
        super(0.75);
        this.acronym = "HT";
        this.name = "HalfTime";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 8;
        this.incompatibleMods.add(ModDoubleTime).add(ModNightCore);
    }
    get isDroidRelevant() {
        return this.isRelevant;
    }
    calculateDroidScoreMultiplier() {
        return this.droidScoreMultiplier;
    }
    get isOsuRelevant() {
        return this.isRelevant;
    }
    get osuScoreMultiplier() {
        return 0.3;
    }
}

/**
 * Represents the DoubleTime mod.
 */
class ModDoubleTime extends ModRateAdjust {
    constructor() {
        super(1.5);
        this.acronym = "DT";
        this.name = "DoubleTime";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 6;
        this.incompatibleMods.add(ModHalfTime).add(ModNightCore);
    }
    get isDroidRelevant() {
        return this.isRelevant;
    }
    calculateDroidScoreMultiplier() {
        return this.droidScoreMultiplier;
    }
    get isOsuRelevant() {
        return this.isRelevant;
    }
    get osuScoreMultiplier() {
        return 1.12;
    }
}

var _a$1;
/**
 * Represents the osu! playfield.
 */
class Playfield {
}
_a$1 = Playfield;
/**
 * The size of the playfield, which is 512x384.
 */
Playfield.baseSize = new Vector2(512, 384);
/**
 * The center of the playfield, which is at (256, 192).
 */
Playfield.center = _a$1.baseSize.scale(0.5);

/**
 * Represents a spinner in a beatmap.
 *
 * All we need from spinners is their duration. The
 * position of a spinner is always at 256x192.
 */
class Spinner extends HitObject {
    get endTime() {
        return this._endTime;
    }
    constructor(values) {
        super(Object.assign(Object.assign({}, values), { position: Playfield.baseSize.divide(2) }));
        this._endTime = values.endTime;
    }
    applySamples(controlPoints) {
        super.applySamples(controlPoints);
        const samplePoints = controlPoints.sample.between(this.startTime + HitObject.controlPointLeniency, this.endTime + HitObject.controlPointLeniency);
        this.auxiliarySamples.length = 0;
        this.auxiliarySamples.push(new SequenceHitSampleInfo(samplePoints.map((s) => new TimedHitSampleInfo(s.time, s.applyTo(Spinner.baseSpinnerSpinSample)))));
        this.auxiliarySamples.push(new SequenceHitSampleInfo(samplePoints.map((s) => new TimedHitSampleInfo(s.time, s.applyTo(Spinner.baseSpinnerBonusSample)))));
    }
    get stackedPosition() {
        return this.position;
    }
    get stackedEndPosition() {
        return this.position;
    }
    createHitWindow() {
        return new EmptyHitWindow();
    }
    toString() {
        return `Position: [${this._position.x}, ${this._position.y}], duration: ${this.duration}`;
    }
}
Spinner.baseSpinnerSpinSample = new BankHitSampleInfo("spinnerspin");
Spinner.baseSpinnerBonusSample = new BankHitSampleInfo("spinnerbonus");

/**
 * Represents a four-dimensional vector.
 */
class Vector4 {
    constructor(xOrValueOrXZ, yOrYW, z, w) {
        if (yOrYW === undefined) {
            this.x = xOrValueOrXZ;
            this.y = xOrValueOrXZ;
            this.z = xOrValueOrXZ;
            this.w = xOrValueOrXZ;
            return;
        }
        if (typeof z === "undefined") {
            this.x = xOrValueOrXZ;
            this.y = yOrYW;
            this.z = xOrValueOrXZ;
            this.w = yOrYW;
            return;
        }
        this.x = xOrValueOrXZ;
        this.y = yOrYW;
        this.z = z;
        this.w = w;
    }
    /**
     * The X coordinate of the left edge of this vector.
     */
    get left() {
        return this.x;
    }
    /**
     * The Y coordinate of the top edge of this vector.
     */
    get top() {
        return this.y;
    }
    /**
     * The X coordinate of the right edge of this vector.
     */
    get right() {
        return this.z;
    }
    /**
     * The Y coordinate of the bottom edge of this vector.
     */
    get bottom() {
        return this.w;
    }
    /**
     * The top left corner of this vector.
     */
    get topLeft() {
        return new Vector2(this.left, this.top);
    }
    /**
     * The top right corner of this vector.
     */
    get topRight() {
        return new Vector2(this.right, this.top);
    }
    /**
     * The bottom left corner of this vector.
     */
    get bottomLeft() {
        return new Vector2(this.left, this.bottom);
    }
    /**
     * The bottom right corner of this vector.
     */
    get bottomRight() {
        return new Vector2(this.right, this.bottom);
    }
    /**
     * The width of the rectangle defined by this vector.
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * The height of the rectangle defined by this vector.
     */
    get height() {
        return this.bottom - this.top;
    }
}

/**
 * Contains infromation about the position of a {@link HitObject}.
 */
class HitObjectPositionInfo {
    constructor(hitObject) {
        /**
         * The jump angle from the previous {@link HitObject} to this one, relative to the previous
         * {@link HitObject}'s jump angle.
         *
         * The `relativeAngle` of the first {@link HitObject} in a beatmap represents the absolute angle from the
         * center of the playfield to the {@link HitObject}.
         *
         * If `relativeAngle` is 0, the player's cursor does not need to change its direction of movement when
         * passing from the previous {@link HitObject} to this one.
         */
        this.relativeAngle = 0;
        /**
         * The jump distance from the previous {@link HitObject} to this one.
         *
         * The `distanceFromPrevious` of the first {@link HitObject} in a beatmap is relative to the center of
         * the playfield.
         */
        this.distanceFromPrevious = 0;
        /**
         * The rotation of this {@link HitObject} relative to its jump angle.
         *
         * For `Slider`s, this is defined as the angle from the `Slider`'s start position to the end of its path
         * relative to its jump angle. For `HitCircle`s and `Spinner`s, this property is ignored.
         */
        this.rotation = 0;
        this.hitObject = hitObject;
    }
}

/**
 * Precision utilities.
 */
class Precision {
    /**
     * Checks if two numbers are equal with a given tolerance.
     *
     * @param value1 The first number.
     * @param value2 The second number.
     * @param acceptableDifference The acceptable difference as threshold. Default is `Precision.FLOAT_EPSILON = 1e-3`.
     */
    static almostEqualsNumber(value1, value2, acceptableDifference = this.FLOAT_EPSILON) {
        return Math.abs(value1 - value2) <= acceptableDifference;
    }
    /**
     * Checks if two vectors are equal with a given tolerance.
     *
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @param acceptableDifference The acceptable difference as threshold. Default is `Precision.FLOAT_EPSILON = 1e-3`.
     */
    static almostEqualsVector(vec1, vec2, acceptableDifference = this.FLOAT_EPSILON) {
        return (this.almostEqualsNumber(vec1.x, vec2.x, acceptableDifference) &&
            this.almostEqualsNumber(vec1.y, vec2.y, acceptableDifference));
    }
    /**
     * Checks whether two real numbers are almost equal.
     *
     * @param a The first number.
     * @param b The second number.
     * @param maximumError The accuracy required for being almost equal. Defaults to `10 * 2^(-53)`.
     * @returns Whether the two values differ by no more than 10 * 2^(-52).
     */
    static almostEqualRelative(a, b, maximumError = 10 * Math.pow(2, -53)) {
        return this.almostEqualNormRelative(a, b, a - b, maximumError);
    }
    /**
     * Compares two numbers and determines if they are equal within the specified maximum error.
     *
     * @param a The norm of the first value (can be negative).
     * @param b The norm of the second value (can be negative).
     * @param diff The norm of the difference of the two values (can be negative).
     * @param maximumError The accuracy required for being almost equal.
     * @returns Whether both numbers are almost equal up to the specified maximum error.
     */
    static almostEqualNormRelative(a, b, diff, maximumError) {
        // If A or B are infinity (positive or negative) then
        // only return true if they are exactly equal to each other -
        // that is, if they are both infinities of the same sign.
        if (!Number.isFinite(a) || !Number.isFinite(b)) {
            return a === b;
        }
        // If A or B are a NAN, return false. NANs are equal to nothing,
        // not even themselves.
        if (Number.isNaN(a) || Number.isNaN(b)) {
            return false;
        }
        // If one is almost zero, fall back to absolute equality.
        const doublePrecision = Math.pow(2, -53);
        if (Math.abs(a) < doublePrecision || Math.abs(b) < doublePrecision) {
            return Math.abs(diff) < maximumError;
        }
        if ((a === 0 && Math.abs(b) < maximumError) ||
            (b === 0 && Math.abs(a) < maximumError)) {
            return true;
        }
        return (Math.abs(diff) < maximumError * Math.max(Math.abs(a), Math.abs(b)));
    }
}
Precision.FLOAT_EPSILON = 1e-3;

/**
 * Types of slider paths.
 */
exports.PathType = void 0;
(function (PathType) {
    PathType["Catmull"] = "C";
    PathType["Bezier"] = "B";
    PathType["Linear"] = "L";
    PathType["PerfectCurve"] = "P";
})(exports.PathType || (exports.PathType = {}));

/**
 * Path approximator for sliders.
 */
class PathApproximator {
    /**
     * Approximates a bezier slider's path.
     *
     * Creates a piecewise-linear approximation of a bezier curve by adaptively repeatedly subdividing
     * the control points until their approximation error vanishes below a given threshold.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateBezier(controlPoints) {
        const output = [];
        const count = controlPoints.length - 1;
        if (count < 0) {
            return output;
        }
        const subdivisionBuffer1 = new Array(count + 1);
        const subdivisionBuffer2 = new Array(count * 2 + 1);
        // "toFlatten" contains all the curves which are not yet approximated well enough.
        // We use a stack to emulate recursion without the risk of running into a stack overflow.
        // (More specifically, we iteratively and adaptively refine our curve with a
        // depth-first search (https://en.wikipedia.org/wiki/Depth-first_search)
        // over the tree resulting from the subdivisions we make.)
        const toFlatten = [controlPoints.slice()];
        const freeBuffers = [];
        const leftChild = subdivisionBuffer2;
        while (toFlatten.length > 0) {
            const parent = toFlatten.pop();
            if (this.bezierIsFlatEnough(parent)) {
                // If the control points we currently operate on are sufficiently "flat", we use
                // an extension to De Casteljau's algorithm to obtain a piecewise-linear approximation
                // of the bezier curve represented by our control points, consisting of the same amount
                // of points as there are control points.
                this.bezierApproximate(parent, output, subdivisionBuffer1, subdivisionBuffer2, count + 1);
                freeBuffers.push(parent);
                continue;
            }
            // If we do not yet have a sufficiently "flat" (in other words, detailed) approximation we keep
            // subdividing the curve we are currently operating on.
            const rightChild = freeBuffers.length > 0
                ? freeBuffers.pop()
                : new Array(count + 1);
            this.bezierSubdivide(parent, leftChild, rightChild, subdivisionBuffer1, count + 1);
            // We re-use the buffer of the parent for one of the children, so that we save one allocation per iteration.
            for (let i = 0; i < count + 1; ++i) {
                parent[i] = leftChild[i];
            }
            toFlatten.push(rightChild);
            toFlatten.push(parent);
        }
        output.push(controlPoints[count]);
        return output;
    }
    /**
     * Approximates a catmull slider's path.
     *
     * Creates a piecewise-linear approximation of a Catmull-Rom spline.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateCatmull(controlPoints) {
        const result = [];
        for (let i = 0; i < controlPoints.length - 1; ++i) {
            const v1 = i > 0 ? controlPoints[i - 1] : controlPoints[i];
            const v2 = controlPoints[i];
            const v3 = controlPoints[i + 1];
            const v4 = i < controlPoints.length - 2
                ? controlPoints[i + 2]
                : v3.add(v3).subtract(v2);
            for (let c = 0; c < this.catmullDetail; ++c) {
                result.push(this.catmullFindPoint(v1, v2, v3, v4, c / this.catmullDetail));
                result.push(this.catmullFindPoint(v1, v2, v3, v4, (c + 1) / this.catmullDetail));
            }
        }
        return result;
    }
    /**
     * Approximates a slider's circular arc.
     *
     * Creates a piecewise-linear approximation of a circular arc curve.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateCircularArc(controlPoints) {
        const a = controlPoints[0];
        const b = controlPoints[1];
        const c = controlPoints[2];
        // If we have a degenerate triangle where a side-length is almost zero, then give up and fall
        // back to a more numerically stable method.
        if (Precision.almostEqualsNumber(0, (b.y - a.y) * (c.x - a.x) - (b.x - a.x) * (c.y - a.y))) {
            return this.approximateBezier(controlPoints);
        }
        // See: https://en.wikipedia.org/wiki/Circumscribed_circle#Cartesian_coordinates_2
        const d = 2 *
            (a.x * b.subtract(c).y +
                b.x * c.subtract(a).y +
                c.x * a.subtract(b).y);
        const aSq = Math.pow(a.length, 2);
        const bSq = Math.pow(b.length, 2);
        const cSq = Math.pow(c.length, 2);
        const center = new Vector2(aSq * b.subtract(c).y +
            bSq * c.subtract(a).y +
            cSq * a.subtract(b).y, aSq * c.subtract(b).x +
            bSq * a.subtract(c).x +
            cSq * b.subtract(a).x).divide(d);
        const dA = a.subtract(center);
        const dC = c.subtract(center);
        const r = dA.length;
        const thetaStart = Math.atan2(dA.y, dA.x);
        let thetaEnd = Math.atan2(dC.y, dC.x);
        while (thetaEnd < thetaStart) {
            thetaEnd += 2 * Math.PI;
        }
        let dir = 1;
        let thetaRange = thetaEnd - thetaStart;
        // Decide in which direction to draw the circle, depending on which side of
        // AC B lies.
        let orthoAtoC = c.subtract(a);
        orthoAtoC = new Vector2(orthoAtoC.y, -orthoAtoC.x);
        if (orthoAtoC.dot(b.subtract(a)) < 0) {
            dir = -dir;
            thetaRange = 2 * Math.PI - thetaRange;
        }
        // We select the amount of points for the approximation by requiring the discrete curvature
        // to be smaller than the provided tolerance. The exact angle required to meet the tolerance
        // is: 2 * Math.Acos(1 - TOLERANCE / r)
        // The special case is required for extremely short sliders where the radius is smaller than
        // the tolerance. This is a pathological rather than a realistic case.
        const amountPoints = 2 * r <= this.circularArcTolerance
            ? 2
            : Math.max(2, Math.ceil(thetaRange /
                (2 *
                    Math.acos(1 - this.circularArcTolerance / r))));
        const output = [];
        for (let i = 0; i < amountPoints; ++i) {
            const fract = i / (amountPoints - 1);
            const theta = thetaStart + dir * fract * thetaRange;
            const o = new Vector2(Math.cos(theta), Math.sin(theta)).scale(r);
            output.push(center.add(o));
        }
        return output;
    }
    /**
     * Approximates a linear slider's path.
     *
     * Creates a piecewise-linear approximation of a linear curve.
     * Basically, returns the input.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateLinear(controlPoints) {
        return controlPoints;
    }
    /**
     * Checks if a bezier slider is flat enough to be approximated.
     *
     * Make sure the 2nd order derivative (approximated using finite elements) is within tolerable bounds.
     *
     * NOTE: The 2nd order derivative of a 2D curve represents its curvature, so intuitively this function
     * checks (as the name suggests) whether our approximation is _locally_ "flat". More curvy parts
     * need to have a denser approximation to be more "flat".
     *
     * @param controlPoints The anchor points of the slider.
     */
    static bezierIsFlatEnough(controlPoints) {
        for (let i = 1; i < controlPoints.length - 1; ++i) {
            const prev = controlPoints[i - 1];
            const current = controlPoints[i];
            const next = controlPoints[i + 1];
            const final = prev.subtract(current.scale(2)).add(next);
            if (Math.pow(final.length, 2) >
                Math.pow(this.bezierTolerance, 2) * 4) {
                return false;
            }
        }
        return true;
    }
    /**
     * Approximates a bezier slider's path.
     *
     * This uses {@link https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm De Casteljau's algorithm} to obtain an optimal
     * piecewise-linear approximation of the bezier curve with the same amount of points as there are control points.
     *
     * @param controlPoints The control points describing the bezier curve to be approximated.
     * @param output The points representing the resulting piecewise-linear approximation.
     * @param subdivisionBuffer1 The first buffer containing the current subdivision state.
     * @param subdivisionBuffer2 The second buffer containing the current subdivision state.
     * @param count The number of control points in the original array.
     */
    static bezierApproximate(controlPoints, output, subdivisionBuffer1, subdivisionBuffer2, count) {
        const l = subdivisionBuffer2;
        const r = subdivisionBuffer1;
        this.bezierSubdivide(controlPoints, l, r, subdivisionBuffer1, count);
        for (let i = 0; i < count - 1; ++i) {
            l[count + i] = r[i + 1];
        }
        output.push(controlPoints[0]);
        for (let i = 1; i < count - 1; ++i) {
            const index = 2 * i;
            const p = l[index - 1]
                .add(l[index].scale(2))
                .add(l[index + 1])
                .scale(0.25);
            output.push(p);
        }
    }
    /**
     * Subdivides `n` control points representing a bezier curve into 2 sets of `n` control points, each
     * describing a bezier curve equivalent to a half of the original curve. Effectively this splits
     * the original curve into 2 curves which result in the original curve when pieced back together.
     *
     * @param controlPoints The anchor points of the slider.
     * @param l Parts of the slider for approximation.
     * @param r Parts of the slider for approximation.
     * @param subdivisionBuffer Parts of the slider for approximation.
     * @param count The amount of anchor points in the slider.
     */
    static bezierSubdivide(controlPoints, l, r, subdivisionBuffer, count) {
        const midpoints = subdivisionBuffer;
        for (let i = 0; i < count; ++i) {
            midpoints[i] = controlPoints[i];
        }
        for (let i = 0; i < count; ++i) {
            l[i] = midpoints[0];
            r[count - i - 1] = midpoints[count - i - 1];
            for (let j = 0; j < count - i - 1; ++j) {
                midpoints[j] = midpoints[j].add(midpoints[j + 1]).divide(2);
            }
        }
    }
    /**
     * Finds a point on the spline at the position of a parameter.
     *
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @param vec3 The third vector.
     * @param vec4 The fourth vector.
     * @param t The parameter at which to find the point on the spline, in the range [0, 1].
     */
    static catmullFindPoint(vec1, vec2, vec3, vec4, t) {
        const t2 = Math.pow(t, 2);
        const t3 = Math.pow(t, 3);
        return new Vector2(0.5 *
            (2 * vec2.x +
                (-vec1.x + vec3.x) * t +
                (2 * vec1.x - 5 * vec2.x + 4 * vec3.x - vec4.x) * t2 +
                (-vec1.x + 3 * vec2.x - 3 * vec3.x + vec4.x) * t3), 0.5 *
            (2 * vec2.y +
                (-vec1.y + vec3.y) * t +
                (2 * vec1.y - 5 * vec2.y + 4 * vec3.y - vec4.y) * t2 +
                (-vec1.y + 3 * vec2.y - 3 * vec3.y + vec4.y) * t3));
    }
}
PathApproximator.bezierTolerance = 0.25;
/**
 * The amount of pieces to calculate for each control point quadruplet.
 */
PathApproximator.catmullDetail = 50;
PathApproximator.circularArcTolerance = 0.1;

/**
 * Represents a slider's path.
 */
class SliderPath {
    constructor(values) {
        /**
         * Whether or not the instance has been initialized.
         */
        this.isInitialized = false;
        /**
         * The calculated path of the slider.
         */
        this.calculatedPath = [];
        /**
         * The cumulative length of the slider.
         */
        this.cumulativeLength = [];
        this.pathType = values.pathType;
        this.controlPoints = values.controlPoints;
        this.expectedDistance = values.expectedDistance;
        this.ensureInitialized();
    }
    /**
     * Initializes the instance.
     */
    ensureInitialized() {
        if (this.isInitialized) {
            return;
        }
        this.isInitialized = true;
        this.calculatedPath.length = 0;
        this.cumulativeLength.length = 0;
        this.calculatePath();
        this.calculateCumulativeLength();
    }
    /**
     * Calculates the slider's path.
     */
    calculatePath() {
        this.calculatedPath.length = 0;
        let spanStart = 0;
        for (let i = 0; i < this.controlPoints.length; i++) {
            if (i === this.controlPoints.length - 1 ||
                this.controlPoints[i].equals(this.controlPoints[i + 1])) {
                const spanEnd = i + 1;
                const cpSpan = this.controlPoints.slice(spanStart, spanEnd);
                this.calculateSubPath(cpSpan).forEach((t) => {
                    if (this.calculatedPath.length === 0 ||
                        !this.calculatedPath.at(-1).equals(t)) {
                        this.calculatedPath.push(t);
                    }
                });
                spanStart = spanEnd;
            }
        }
    }
    /**
     * Calculates the slider's subpath.
     */
    calculateSubPath(subControlPoints) {
        switch (this.pathType) {
            case exports.PathType.Linear:
                return PathApproximator.approximateLinear(subControlPoints);
            case exports.PathType.PerfectCurve: {
                if (subControlPoints.length !== 3) {
                    break;
                }
                const subPath = PathApproximator.approximateCircularArc(subControlPoints);
                // If for some reason a circular arc could not be fit to the 3 given points, fall back to a numerically stable Bézier approximation.
                if (subPath.length === 0) {
                    break;
                }
                return subPath;
            }
            case exports.PathType.Catmull:
                return PathApproximator.approximateCatmull(subControlPoints);
        }
        return PathApproximator.approximateBezier(subControlPoints);
    }
    /**
     * Calculates the slider's cumulative length.
     */
    calculateCumulativeLength() {
        let calculatedLength = 0;
        this.cumulativeLength.length = 0;
        this.cumulativeLength.push(0);
        for (let i = 0; i < this.calculatedPath.length - 1; ++i) {
            const diff = this.calculatedPath[i + 1].subtract(this.calculatedPath[i]);
            calculatedLength += diff.length;
            this.cumulativeLength.push(calculatedLength);
        }
        if (calculatedLength !== this.expectedDistance) {
            // In osu-stable, if the last two path points of a slider are equal, extension is not performed.
            if (this.calculatedPath.length >= 2 &&
                this.calculatedPath
                    .at(-1)
                    .equals(this.calculatedPath.at(-2)) &&
                this.expectedDistance > calculatedLength) {
                this.cumulativeLength.push(calculatedLength);
                return;
            }
            // The last length is always incorrect
            this.cumulativeLength.pop();
            let pathEndIndex = this.calculatedPath.length - 1;
            if (calculatedLength > this.expectedDistance) {
                // The path will be shortened further, in which case we should trim any more unnecessary lengths and their associated path segments
                while (this.cumulativeLength.length > 0 &&
                    this.cumulativeLength.at(-1) >= this.expectedDistance) {
                    this.cumulativeLength.pop();
                    this.calculatedPath.splice(pathEndIndex--, 1);
                }
            }
            if (pathEndIndex <= 0) {
                // The expected distance is negative or zero
                this.cumulativeLength.push(0);
                return;
            }
            // The direction of the segment to shorten or lengthen
            const dir = this.calculatedPath[pathEndIndex].subtract(this.calculatedPath[pathEndIndex - 1]);
            dir.normalize();
            this.calculatedPath[pathEndIndex] = this.calculatedPath[pathEndIndex - 1].add(dir.scale(this.expectedDistance - this.cumulativeLength.at(-1)));
            this.cumulativeLength.push(this.expectedDistance);
        }
    }
    /**
     * Computes the position on the slider at a given progress that ranges from 0 (beginning of the path)
     * to 1 (end of the path).
     *
     * @param progress Ranges from 0 (beginning of the path) to 1 (end of the path).
     */
    positionAt(progress) {
        this.ensureInitialized();
        const d = this.progressToDistance(progress);
        return this.interpolateVerticles(this.indexOfDistance(d), d);
    }
    /**
     * Computes the slider path until a given progress that ranges from 0 (beginning of the slider) to
     * 1 (end of the slider).
     *
     * @param p0 Start progress. Ranges from 0 (beginning of the slider) to 1 (end of the slider).
     * @param p1 End progress. Ranges from 0 (beginning of the slider) to 1 (end of the slider).
     * @return The computed path between the two ranges.
     */
    pathToProgress(p0, p1) {
        const path = [];
        const d0 = this.progressToDistance(p0);
        const d1 = this.progressToDistance(p1);
        let i = 0;
        while (i < this.calculatedPath.length &&
            this.cumulativeLength[i] < d0) {
            ++i;
        }
        path.push(this.interpolateVerticles(i, d0));
        while (i < this.calculatedPath.length &&
            this.cumulativeLength[i] <= d1) {
            path.push(this.calculatedPath[i++]);
        }
        path.push(this.interpolateVerticles(i, d1));
        return path;
    }
    /**
     * Returns the progress of reaching expected distance.
     */
    progressToDistance(progress) {
        return Math.min(Math.max(progress, 0), 1) * this.expectedDistance;
    }
    /**
     * Interpolates verticles of the slider.
     */
    interpolateVerticles(i, d) {
        if (this.calculatedPath.length === 0) {
            return new Vector2(0);
        }
        if (i <= 0) {
            return this.calculatedPath[0];
        }
        if (i >= this.calculatedPath.length) {
            return this.calculatedPath.at(-1);
        }
        const p0 = this.calculatedPath[i - 1];
        const p1 = this.calculatedPath[i];
        const d0 = this.cumulativeLength[i - 1];
        const d1 = this.cumulativeLength[i];
        // Avoid division by and almost-zero number in case two points are extremely close to each other.
        if (Precision.almostEqualsNumber(d0, d1)) {
            return p0;
        }
        const w = (d - d0) / (d1 - d0);
        return p0.add(p1.subtract(p0).scale(w));
    }
    /**
     * Binary searches the cumulative length array and returns the
     * index at which `arr[index] >= d`.
     *
     * @param d The distance to search.
     * @returns The index.
     */
    indexOfDistance(d) {
        if (this.cumulativeLength.length === 0 ||
            d < this.cumulativeLength[0]) {
            return 0;
        }
        if (d >= this.cumulativeLength.at(-1)) {
            return this.cumulativeLength.length;
        }
        let l = 0;
        let r = this.cumulativeLength.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            if (this.cumulativeLength[pivot] < d) {
                l = pivot + 1;
            }
            else if (this.cumulativeLength[pivot] > d) {
                r = pivot - 1;
            }
            else {
                return pivot;
            }
        }
        return l;
    }
}

var _a;
/**
 * Utilities for {@link HitObject} generation.
 */
class HitObjectGenerationUtils {
    //#region Rotation
    /**
     * Rotates a {@link HitObject} away from the edge of the playfield while keeping a constant distance from
     * the previous {@link HitObject}.
     *
     * @param previousObjectPosition The position of the previous {@link HitObject}.
     * @param positionRelativeToPrevious The position of the {@link HitObject} to be rotated relative to the
     * previous {@link HitObject}.
     * @param rotationRatio The extent of the rotation. 0 means the {@link HitObject} is never rotated, while 1
     * means the {@link HitObject} will be fully rotated towards the center of the playfield when it is originally
     * at the edge of the playfield.
     * @return The new position of the {@link HitObject} relative to the previous {@link HitObject}.
     */
    static rotateAwayFromEdge(previousObjectPosition, positionRelativeToPrevious, rotationRatio = 0.5) {
        const relativeRotationDistance = Math.max((previousObjectPosition.x < Playfield.center.x
            ? this.borderDistance.x - previousObjectPosition.x
            : previousObjectPosition.x -
                (Playfield.baseSize.x - this.borderDistance.x)) /
            this.borderDistance.x, (previousObjectPosition.y < Playfield.center.y
            ? this.borderDistance.y - previousObjectPosition.y
            : previousObjectPosition.y -
                (Playfield.baseSize.y - this.borderDistance.y)) /
            this.borderDistance.y, 0);
        return this.rotateVectorTowardsVector(positionRelativeToPrevious, Playfield.center.subtract(previousObjectPosition), Math.min(1, relativeRotationDistance * rotationRatio));
    }
    /**
     * Rotates a {@link Vector2} towards another {@link Vector2}.
     *
     * @param initial The {@link Vector2} to be rotated.
     * @param destination The {@link Vector2} that `initial` should be rotated towards.
     * @param rotationRatio How much `initial` should be rotated. 0 means no rotation. 1 mean `initial` is fully
     * rotated to equal `destination`.
     * @return The rotated {@link Vector2}.
     */
    static rotateVectorTowardsVector(initial, destination, rotationRatio) {
        const initialAngle = Math.atan2(initial.y, initial.x);
        const destinationAngle = Math.atan2(destination.y, destination.x);
        let diff = destinationAngle - initialAngle;
        // Normalize angle
        while (diff < -Math.PI) {
            diff += 2 * Math.PI;
        }
        while (diff > Math.PI) {
            diff -= 2 * Math.PI;
        }
        const finalAngle = initialAngle + diff * rotationRatio;
        return new Vector2(initial.x * Math.cos(finalAngle), initial.y * Math.sin(finalAngle));
    }
    /**
     * Obtains the absolute rotation of a {@link Slider}, defined as the angle from its start position to the
     * end of its path.
     *
     * @param slider The {@link Slider} to obtain the rotation from.
     * @return The angle in radians.
     */
    static getSliderRotation(slider) {
        const pathEndPosition = slider.path.positionAt(1);
        return Math.atan2(pathEndPosition.y, pathEndPosition.x);
    }
    /**
     * Rotates a {@link Vector2} by the specified angle.
     *
     * @param vec The {@link Vector2} to be rotated.
     * @param rotation The angle to rotate `vec` by, in radians.
     * @return The rotated {@link Vector2}.
     */
    static rotateVector(vec, rotation) {
        const angle = Math.atan2(vec.y, vec.x) + rotation;
        const { length } = vec;
        return new Vector2(length * Math.cos(angle), length * Math.sin(angle));
    }
    //#endregion
    //#region Reflection
    /**
     * Reflects the position of a {@link HitObject} horizontally along the playfield.
     *
     * @param hitObject The {@link HitObject} to reflect.
     */
    static reflectHorizontallyAlongPlayfield(hitObject) {
        hitObject.position = this.reflectVectorHorizontallyAlongPlayfield(hitObject.position);
        if (hitObject instanceof Slider) {
            this.modifySlider(hitObject, (v) => new Vector2(-v.x, v.y));
        }
    }
    /**
     * Reflects the position of a {@link HitObject} vertically along the playfield.
     *
     * @param hitObject The {@link HitObject} to reflect.
     */
    static reflectVerticallyAlongPlayfield(hitObject) {
        // Reflect the position of the hit object.
        hitObject.position = this.reflectVectorVerticallyAlongPlayfield(hitObject.position);
        if (hitObject instanceof Slider) {
            this.modifySlider(hitObject, (v) => new Vector2(v.x, -v.y));
        }
    }
    /**
     * Flips the position of a {@link Slider} around its start position horizontally.
     *
     * @param slider The {@link Slider} to be flipped.
     */
    static flipSliderInPlaceHorizontally(slider) {
        this.modifySlider(slider, (v) => new Vector2(-v.x, v.y));
    }
    /**
     * Rotates a {@link Slider} around its start position by the specified angle.
     *
     * @param slider The {@link Slider} to rotate.
     * @param rotation The angle to rotate `slider` by, in radians.
     */
    static rotateSlider(slider, rotation) {
        this.modifySlider(slider, (v) => this.rotateVector(v, rotation));
    }
    static modifySlider(slider, modifyControlPoint) {
        slider.path = new SliderPath({
            pathType: slider.path.pathType,
            controlPoints: slider.path.controlPoints.map(modifyControlPoint),
            expectedDistance: slider.path.expectedDistance,
        });
    }
    static reflectVectorHorizontallyAlongPlayfield(vector) {
        return new Vector2(Playfield.baseSize.x - vector.x, vector.y);
    }
    static reflectVectorVerticallyAlongPlayfield(vector) {
        return new Vector2(vector.x, Playfield.baseSize.y - vector.y);
    }
    //#endregion
    //#region Reposition
    /**
     * Generates a list of {@link HitObjectPositionInfo}s containing information for how the given list of
     * {@link HitObject}s are positioned.
     *
     * @param hitObjects A list of {@link HitObject}s to process.
     * @return A list of {@link HitObjectPositionInfo}s describing how each {@link HitObject} is positioned
     * relative to the previous one.
     */
    static generatePositionInfos(hitObjects) {
        const positionInfos = [];
        let previousPosition = Playfield.center;
        let previousAngle = 0;
        for (const hitObject of hitObjects) {
            const relativePosition = hitObject.position.subtract(previousPosition);
            let absoluteAngle = Math.atan2(relativePosition.y, relativePosition.x);
            const relativeAngle = absoluteAngle - previousAngle;
            const positionInfo = new HitObjectPositionInfo(hitObject);
            positionInfo.relativeAngle = relativeAngle;
            positionInfo.distanceFromPrevious = relativePosition.length;
            if (hitObject instanceof Slider) {
                const absoluteRotation = this.getSliderRotation(hitObject);
                positionInfo.rotation = absoluteRotation - absoluteAngle;
                absoluteAngle = absoluteRotation;
            }
            previousPosition = hitObject.endPosition;
            previousAngle = absoluteAngle;
            positionInfos.push(positionInfo);
        }
        return positionInfos;
    }
    static repositionHitObjects(positionInfos) {
        const workingObjects = positionInfos.map((p) => new WorkingObject(p));
        let previous = null;
        for (let i = 0; i < workingObjects.length; ++i) {
            const current = workingObjects[i];
            const { hitObject } = current;
            if (hitObject instanceof Spinner) {
                previous = current;
                continue;
            }
            this.computeModifiedPosition(current, previous, i > 1 ? workingObjects[i - 2] : null);
            // Move hit objects back into the playfield if they are outside of it.
            let shift;
            if (hitObject instanceof Circle) {
                shift = this.clampHitCircleToPlayfield(current);
            }
            else if (hitObject instanceof Slider) {
                shift = this.clampSliderToPlayfield(current);
            }
            else {
                shift = new Vector2(0);
            }
            if (shift.x !== 0 || shift.y !== 0) {
                const toBeShifted = [];
                for (let j = i - 1; j >= Math.max(0, i - this.precedingObjectsToShift); --j) {
                    // Only shift hit circles.
                    if (!(workingObjects[j].hitObject instanceof Circle)) {
                        break;
                    }
                    toBeShifted.push(workingObjects[j].hitObject);
                }
                this.applyDecreasingShift(toBeShifted, shift);
            }
            previous = current;
        }
        return workingObjects.map((w) => w.hitObject);
    }
    /**
     * Determines whether a {@link HitObject} is on a beat.
     *
     * @param beatmap The {@link Beatmap} the {@link HitObject} is a part of.
     * @param hitObject The {@link HitObject} to check.
     * @param downbeatsOnly If `true`, whether this method only returns `true` is on a downbeat.
     * @return `true` if the {@link HitObject} is on a (down-)beat, `false` otherwise.
     */
    static isHitObjectOnBeat(beatmap, hitObject, downbeatsOnly = false) {
        const timingPoint = beatmap.controlPoints.timing.controlPointAt(hitObject.startTime);
        const timeSinceTimingPoint = hitObject.startTime - timingPoint.time;
        let beatLength = timingPoint.msPerBeat;
        if (downbeatsOnly) {
            beatLength *= timingPoint.timeSignature;
        }
        // Ensure within 1ms of expected location.
        return Math.abs(timeSinceTimingPoint + 1) % beatLength < 2;
    }
    /**
     * Generates a random number from a Normal distribution using the Box-Muller transform.
     *
     * @param random A {@link Random} to get the random number from.
     * @param mean The mean of the distribution.
     * @param stdDev The standard deviation of the distribution.
     * @return The random number.
     */
    static randomGaussian(random, mean = 0, stdDev = 1) {
        // Generate 2 random numbers in the interval (0,1].
        // x1 must not be 0 since log(0) = undefined.
        const x1 = 1 - random.nextDouble();
        const x2 = 1 - random.nextDouble();
        const stdNormal = Math.sqrt(-2 * Math.log(x1)) * Math.sin(2 * Math.PI * x2);
        return mean + stdDev * stdNormal;
    }
    /**
     * Calculates a {@link Vector4} which contains all possible movements of a {@link Slider} (in relative
     * X/Y coordinates) such that the entire {@link Slider} is inside the playfield.
     *
     * If the {@link Slider} is larger than the playfield, the returned {@link Vector4} may have a Z/W component
     * that is smaller than its X/Y component.
     *
     * @param slider The {@link Slider} whose movement bound is to be calculated.
     * @return A {@link Vector4} which contains all possible movements of a {@link Slider} (in relative X/Y
     * coordinates) such that the entire {@link Slider} is inside the playfield.
     */
    static calculatePossibleMovementBounds(slider) {
        const pathPositions = slider.path.pathToProgress(0, 1);
        let minX = Number.POSITIVE_INFINITY;
        let maxX = Number.NEGATIVE_INFINITY;
        let minY = Number.POSITIVE_INFINITY;
        let maxY = Number.NEGATIVE_INFINITY;
        // Compute the bounding box of the slider.
        for (const position of pathPositions) {
            minX = Math.min(minX, position.x);
            maxX = Math.max(maxX, position.x);
            minY = Math.min(minY, position.y);
            maxY = Math.max(maxY, position.y);
        }
        // Take the radius into account.
        const { radius } = slider;
        minX -= radius;
        minY -= radius;
        maxX += radius;
        maxY += radius;
        // Given the bounding box of the slider (via min/max X/Y), the amount that the slider can move to the left is
        // minX (with the sign flipped, since positive X is to the right), and the amount that it can move to the right
        // is WIDTH - maxX. The same calculation applies for the Y axis.
        const left = -minX;
        const right = Playfield.baseSize.x - maxX;
        const top = -minY;
        const bottom = Playfield.baseSize.y - maxY;
        return new Vector4(left, top, right, bottom);
    }
    /**
     * Computes the modified position of a {@link HitObject} while attempting to keep it inside the playfield.
     *
     * @param current The {@link WorkingObject} representing the {@link HitObject} to have the modified
     * position computed for.
     * @param previous The {@link WorkingObject} representing the {@link HitObject} immediately preceding
     * `current`.
     * @param beforePrevious The {@link WorkingObject} representing the {@link HitObject} immediately preceding
     * `previous`.
     */
    static computeModifiedPosition(current, previous, beforePrevious) {
        var _b, _c;
        let previousAbsoluteAngle = 0;
        if (previous !== null) {
            if (previous.hitObject instanceof Slider) {
                previousAbsoluteAngle = this.getSliderRotation(previous.hitObject);
            }
            else {
                const earliestPosition = (_b = beforePrevious === null || beforePrevious === void 0 ? void 0 : beforePrevious.hitObject.endPosition) !== null && _b !== void 0 ? _b : Playfield.center;
                const relativePosition = previous.hitObject.position.subtract(earliestPosition);
                previousAbsoluteAngle = Math.atan2(relativePosition.y, relativePosition.x);
            }
        }
        let absoluteAngle = previousAbsoluteAngle + current.positionInfo.relativeAngle;
        let positionRelativeToPrevious = new Vector2(current.positionInfo.distanceFromPrevious * Math.cos(absoluteAngle), current.positionInfo.distanceFromPrevious * Math.sin(absoluteAngle));
        const lastEndPosition = (_c = previous === null || previous === void 0 ? void 0 : previous.endPositionModified) !== null && _c !== void 0 ? _c : Playfield.center;
        positionRelativeToPrevious = this.rotateAwayFromEdge(lastEndPosition, positionRelativeToPrevious);
        current.positionModified = lastEndPosition.add(positionRelativeToPrevious);
        if (!(current.hitObject instanceof Slider)) {
            return;
        }
        absoluteAngle = Math.atan2(positionRelativeToPrevious.y, positionRelativeToPrevious.x);
        const centerOfMassOriginal = this.calculateCenterOfMass(current.hitObject);
        const centerOfMassModified = this.rotateAwayFromEdge(current.positionModified, this.rotateVector(centerOfMassOriginal, current.positionInfo.rotation +
            absoluteAngle -
            this.getSliderRotation(current.hitObject)));
        const relativeRotation = Math.atan2(centerOfMassModified.y, centerOfMassModified.x) -
            Math.atan2(centerOfMassOriginal.y, centerOfMassOriginal.x);
        if (!Precision.almostEqualsNumber(relativeRotation, 0)) {
            this.rotateSlider(current.hitObject, relativeRotation);
        }
    }
    /**
     * Moves the modified position of a {@link Circle} so that it fits inside the playfield.
     *
     * @param workingObject The {@link WorkingObject} that represents the {@link Circle}.
     * @return The deviation from the original modified position in order to fit within the playfield.
     */
    static clampHitCircleToPlayfield(workingObject) {
        const previousPosition = workingObject.positionModified;
        workingObject.positionModified = this.clampToPlayfield(workingObject.positionModified, workingObject.hitObject.radius);
        workingObject.endPositionModified = workingObject.positionModified;
        workingObject.hitObject.position = workingObject.positionModified;
        return workingObject.positionModified.subtract(previousPosition);
    }
    /**
     * Moves a {@link Slider} and all necessary `SliderHitObject`s into the playfield if they are not in
     * the playfield.
     *
     * @param workingObject The {@link WorkingObject} that represents the {@link Slider}.
     * @return The deviation from the original modified position in order to fit within the playfield.
     */
    static clampSliderToPlayfield(workingObject) {
        const slider = workingObject.hitObject;
        let possibleMovementBounds = this.calculatePossibleMovementBounds(slider);
        // The slider rotation applied in computeModifiedPosition might make it impossible to fit the slider
        // into the playfield. For example, a long horizontal slider will be off-screen when rotated by 90
        // degrees. In this case, limit the rotation to either 0 or 180 degrees.
        if (possibleMovementBounds.width < 0 ||
            possibleMovementBounds.height < 0) {
            const currentRotation = this.getSliderRotation(slider);
            const diff1 = this.getAngleDifference(workingObject.rotationOriginal, currentRotation);
            const diff2 = this.getAngleDifference(workingObject.rotationOriginal + Math.PI, currentRotation);
            if (diff1 < diff2) {
                this.rotateSlider(slider, workingObject.rotationOriginal - currentRotation);
            }
            else {
                this.rotateSlider(slider, workingObject.rotationOriginal + Math.PI - currentRotation);
            }
            possibleMovementBounds =
                this.calculatePossibleMovementBounds(slider);
        }
        const previousPosition = workingObject.positionModified;
        // Clamp slider position to the placement area.
        // If the slider is larger than the playfield, at least make sure that the head circle is
        // inside the playfield.
        const newX = possibleMovementBounds.width < 0
            ? MathUtils.clamp(possibleMovementBounds.left, 0, Playfield.baseSize.x)
            : MathUtils.clamp(previousPosition.x, possibleMovementBounds.left, possibleMovementBounds.right);
        const newY = possibleMovementBounds.height < 0
            ? MathUtils.clamp(possibleMovementBounds.top, 0, Playfield.baseSize.y)
            : MathUtils.clamp(previousPosition.y, possibleMovementBounds.top, possibleMovementBounds.bottom);
        workingObject.positionModified = new Vector2(newX, newY);
        slider.position = workingObject.positionModified;
        workingObject.endPositionModified = slider.endPosition;
        return workingObject.positionModified.subtract(previousPosition);
    }
    /**
     * Clamps a {@link Vector2} into the playfield, keeping a specified distance from the edge of the playfield.
     *
     * @param vec The {@link Vector2} to clamp.
     * @param padding The minimum distance allowed from the edge of the playfield.
     * @return The clamped {@link Vector2}.
     */
    static clampToPlayfield(vec, padding) {
        return new Vector2(MathUtils.clamp(vec.x, padding, Playfield.baseSize.x - padding), MathUtils.clamp(vec.y, padding, Playfield.baseSize.y - padding));
    }
    /**
     * Decreasingly shifts a list of {@link HitObject}s by a specified amount.
     *
     * The first item in the list is shifted by the largest amount, while the last item is shifted by the
     * smallest amount.
     *
     * @param hitObjects The list of {@link HitObject}s to be shifted.
     * @param shift The amount to shift the {@link HitObject}s by.
     */
    static applyDecreasingShift(hitObjects, shift) {
        for (let i = 0; i < hitObjects.length; ++i) {
            const hitObject = hitObjects[i];
            // The first object is shifted by a vector slightly smaller than shift.
            // The last object is shifted by a vector slightly larger than zero.
            const position = hitObject.position.add(shift.scale((hitObjects.length - i) / (hitObjects.length + 1)));
            hitObject.position = this.clampToPlayfield(position, hitObject.radius);
        }
    }
    /**
     * Estimates the center of mass of a {@link Slider} relative to its start position.
     *
     * @param slider The {@link Slider} whose center mass is to be estimated.
     * @return The estimated center of mass of `slider`.
     */
    static calculateCenterOfMass(slider) {
        const sampleStep = 50;
        // Only sample the start and end positions if the slider is too short.
        if (slider.distance <= sampleStep) {
            return slider.path.positionAt(1).divide(2);
        }
        let count = 0;
        let sum = new Vector2(0);
        for (let i = 0; i < slider.distance; i += sampleStep) {
            sum = sum.add(slider.path.positionAt(i / slider.distance));
            ++count;
        }
        return sum.divide(count);
    }
    /**
     * Calculates the absolute difference between two angles in radians.
     *
     * @param angle1 The first angle.
     * @param angle2 The second angle.
     * @return THe absolute difference within interval `[0, Math.PI]`.
     */
    static getAngleDifference(angle1, angle2) {
        const diff = Math.abs(angle1 - angle2) % (2 * Math.PI);
        return Math.min(diff, 2 * Math.PI - diff);
    }
}
_a = HitObjectGenerationUtils;
/**
 * The relative distance to the edge of the playfield before {@link HitObject} positions should start
 * to "turn around" and curve towards the middle. The closer the {@link HitObject}s draw to the border,
 * the sharper the turn.
 */
HitObjectGenerationUtils.playfieldEdgeRatio = 0.375;
/**
 * The amount of previous {@link HitObject}s to be shifted together when a {@link HitObject} is being moved.
 */
HitObjectGenerationUtils.precedingObjectsToShift = 10;
HitObjectGenerationUtils.borderDistance = Playfield.baseSize.scale(_a.playfieldEdgeRatio);
class WorkingObject {
    get hitObject() {
        return this.positionInfo.hitObject;
    }
    constructor(positionInfo) {
        this.rotationOriginal = this.hitObject instanceof Slider
            ? HitObjectGenerationUtils.getSliderRotation(this.hitObject)
            : 0;
        this.positionModified = this.hitObject.position;
        this.endPositionModified = this.hitObject.endPosition;
        this.positionInfo = positionInfo;
    }
}

/**
 * Represents the Mirror mod.
 */
class ModMirror extends Mod {
    constructor() {
        super();
        this.name = "Mirror";
        this.acronym = "MR";
        this.droidRanked = false;
        this.osuRanked = false;
        /**
         * The axes to reflect the `HitObject`s along.
         */
        this.flippedAxes = new ModSetting("Flipped axes", "The axes to reflect the hit objects along.", exports.Axes.x);
        this.incompatibleMods.add(ModHardRock);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
    copySettings(mod) {
        var _a;
        super.copySettings(mod);
        switch ((_a = mod.settings) === null || _a === void 0 ? void 0 : _a.flippedAxes) {
            case 0:
                this.flippedAxes.value = exports.Axes.x;
                break;
            case 1:
                this.flippedAxes.value = exports.Axes.y;
                break;
            case 2:
                this.flippedAxes.value = exports.Axes.both;
                break;
        }
    }
    applyToHitObject(_, hitObject) {
        switch (this.flippedAxes.value) {
            case exports.Axes.x:
                HitObjectGenerationUtils.reflectHorizontallyAlongPlayfield(hitObject);
                break;
            case exports.Axes.y:
                HitObjectGenerationUtils.reflectVerticallyAlongPlayfield(hitObject);
                break;
            case exports.Axes.both:
                HitObjectGenerationUtils.reflectHorizontallyAlongPlayfield(hitObject);
                HitObjectGenerationUtils.reflectVerticallyAlongPlayfield(hitObject);
                break;
        }
    }
    serializeSettings() {
        return { flippedAxes: this.flippedAxes.value - 1 };
    }
    toString() {
        const settings = [];
        if (this.flippedAxes.value === exports.Axes.x ||
            this.flippedAxes.value === exports.Axes.both) {
            settings.push("↔");
        }
        if (this.flippedAxes.value === exports.Axes.y ||
            this.flippedAxes.value === exports.Axes.both) {
            settings.push("↕");
        }
        return `${super.toString()} (${settings.join(", ")})`;
    }
}

/**
 * Represents the HardRock mod.
 */
class ModHardRock extends Mod {
    constructor() {
        super();
        this.acronym = "HR";
        this.name = "HardRock";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 4;
        this.incompatibleMods.add(ModEasy);
        this.incompatibleMods.add(ModMirror);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.06;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1.06;
    }
    applyToDifficulty(mode, difficulty, adjustmentMods) {
        if (mode === exports.Modes.osu || !adjustmentMods.has(ModReplayV6)) {
            difficulty.cs = this.applySetting(difficulty.cs, 1.3);
        }
        else {
            const scale = CircleSizeCalculator.droidCSToOldDroidScale(difficulty.cs);
            // The 0.125 scale that was added before replay version 7 was in screen pixels. We need it in osu! pixels.
            difficulty.cs = CircleSizeCalculator.oldDroidScaleToDroidCS(scale -
                CircleSizeCalculator.oldDroidScaleScreenPixelsToOsuPixels(0.125));
        }
        difficulty.ar = this.applySetting(difficulty.ar);
        difficulty.od = this.applySetting(difficulty.od);
        difficulty.hp = this.applySetting(difficulty.hp);
    }
    applyToHitObject(_, hitObject) {
        HitObjectGenerationUtils.reflectVerticallyAlongPlayfield(hitObject);
    }
    applySetting(value, ratio = 1.4) {
        return Math.min(value * ratio, 10);
    }
}

/**
 * Represents the Easy mod.
 */
class ModEasy extends Mod {
    constructor() {
        super();
        this.acronym = "EZ";
        this.name = "Easy";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 1;
        this.incompatibleMods.add(ModHardRock);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.5;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0.5;
    }
    applyToDifficulty(mode, difficulty, adjustmentMods) {
        if (mode === exports.Modes.osu || !adjustmentMods.has(ModReplayV6)) {
            difficulty.cs /= 2;
        }
        else {
            const scale = CircleSizeCalculator.droidCSToOldDroidScale(difficulty.cs);
            // The 0.125 scale that was added before replay version 7 was in screen pixels. We need it in osu! pixels.
            difficulty.cs = CircleSizeCalculator.oldDroidScaleToDroidCS(scale +
                CircleSizeCalculator.oldDroidScaleScreenPixelsToOsuPixels(0.125));
        }
        difficulty.ar /= 2;
        difficulty.od /= 2;
        difficulty.hp /= 2;
    }
}

/**
 * Represents the Flashlight mod.
 */
class ModFlashlight extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "FL";
        this.name = "Flashlight";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 10;
        /**
         * The amount of seconds until the Flashlight follow area reaches the cursor.
         */
        this.followDelay = new DecimalModSetting("Flashlight follow delay", "The amount of seconds until the Flashlight follow area reaches the cursor.", ModFlashlight.defaultFollowDelay, ModFlashlight.defaultFollowDelay, ModFlashlight.defaultFollowDelay * 10, ModFlashlight.defaultFollowDelay, 2);
    }
    copySettings(mod) {
        var _a, _b;
        super.copySettings(mod);
        this.followDelay.value =
            (_b = (_a = mod.settings) === null || _a === void 0 ? void 0 : _a.areaFollowDelay) !== null && _b !== void 0 ? _b : this.followDelay.value;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.12;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1.12;
    }
    serializeSettings() {
        return { areaFollowDelay: this.followDelay.value };
    }
    toString() {
        if (this.followDelay.value === ModFlashlight.defaultFollowDelay) {
            return super.toString();
        }
        return `${super.toString()} (${this.followDelay.toDisplayString()}s follow delay)`;
    }
}
/**
 * The default amount of seconds until the Flashlight follow area reaches the cursor.
 */
ModFlashlight.defaultFollowDelay = 0.12;

/**
 * Represents the Grow mod.
 */
class ModGrow extends ModObjectScaleTween {
    constructor() {
        super(...arguments);
        this.name = "Grow";
        this.acronym = "GR";
        this.startScale = new DecimalModSetting("Start scale", "The initial size multiplier applied to all hit objects.", 0.5, 0, 0.99, 0.01, 2);
    }
    get droidRanked() {
        return false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get osuRanked() {
        return false;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents a `Mod` specific setting that is constrained to a range of integer values.
 */
class IntegerModSetting extends NumberModSetting {
    constructor(name, description, defaultValue, min = -2147483648, max = 2147483647) {
        super(name, description, defaultValue, min, max, 1);
    }
}

/**
 * Represents the Muted mod.
 */
class ModMuted extends Mod {
    get droidRanked() {
        return false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get osuRanked() {
        return true;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
    constructor() {
        super();
        this.name = "Muted";
        this.acronym = "MU";
        /**
         * Increase volume as combo builds.
         */
        this.inverseMuting = new BooleanModSetting("Start muted", "Increase volume as combo builds.", false);
        /**
         * Add a metronome beat to help the player keep track of the rhythm.
         */
        this.enableMetronome = new BooleanModSetting("Enable metronome", "Add a metronome beat to help you keep track of the rhythm.", true);
        /**
         * The combo count at which point the track reaches its final volume.
         */
        this.muteComboCount = new IntegerModSetting("Final volume at combo", "The combo count at which point the track reaches its final volume.", 100, 0, 500);
        /**
         * Hit sounds are also muted alongside the track.
         */
        this.affectsHitSounds = new BooleanModSetting("Mute hit sounds", "Hit sounds are also muted alongside the track.", true);
        this.inverseMuting.bindValueChanged((_, newValue) => {
            this.muteComboCount.min = newValue ? 1 : 0;
        }, true);
    }
    /**
     * Obtains the volume at a given combo.
     *
     * @param combo The combo.
     * @return The volume at `combo`, where 0 is muted and 1 is full volume.
     */
    volumeAt(combo) {
        const volume = MathUtils.clamp(combo / Math.max(1, this.muteComboCount.value), 0, 1);
        return this.inverseMuting.value ? volume : 1 - volume;
    }
    copySettings(mod) {
        var _a, _b, _c, _d;
        super.copySettings(mod);
        const { settings } = mod;
        this.inverseMuting.value =
            (_a = settings === null || settings === void 0 ? void 0 : settings.inverseMuting) !== null && _a !== void 0 ? _a : this.inverseMuting.value;
        this.enableMetronome.value =
            (_b = settings === null || settings === void 0 ? void 0 : settings.enableMetronome) !== null && _b !== void 0 ? _b : this.enableMetronome.value;
        this.muteComboCount.value =
            (_c = settings === null || settings === void 0 ? void 0 : settings.muteComboCount) !== null && _c !== void 0 ? _c : this.muteComboCount.value;
        this.affectsHitSounds.value =
            (_d = settings === null || settings === void 0 ? void 0 : settings.affectsHitSounds) !== null && _d !== void 0 ? _d : this.affectsHitSounds.value;
    }
    serializeSettings() {
        return {
            inverseMuting: this.inverseMuting.value,
            enableMetronome: this.enableMetronome.value,
            muteComboCount: this.muteComboCount.value,
            affectsHitSounds: this.affectsHitSounds.value,
        };
    }
}

/**
 * Represents the SuddenDeath mod.
 */
class ModSuddenDeath extends Mod {
    constructor() {
        super();
        this.acronym = "SD";
        this.name = "Sudden Death";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 5;
        this.incompatibleMods.add(ModNoFail).add(ModPerfect);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents the Perfect mod.
 */
class ModPerfect extends Mod {
    constructor() {
        super();
        this.acronym = "PF";
        this.name = "Perfect";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 14;
        this.incompatibleMods.add(ModNoFail).add(ModSuddenDeath);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents the NoFail mod.
 */
class ModNoFail extends Mod {
    constructor() {
        super();
        this.acronym = "NF";
        this.name = "NoFail";
        this.droidRanked = true;
        this.osuRanked = true;
        this.bitwise = 1 << 0;
        this.incompatibleMods.add(ModPerfect).add(ModSuddenDeath);
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.5;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0.5;
    }
}

/**
 * Represents the Precise mod.
 */
class ModPrecise extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "PR";
        this.name = "Precise";
        this.droidRanked = true;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.06;
    }
    applyToHitObject(mode, hitObject) {
        var _a, _b;
        if (mode !== exports.Modes.droid || hitObject instanceof Spinner) {
            return;
        }
        if (hitObject instanceof Slider) {
            // For sliders, the hit window is enforced in the head - everything else is an instant hit or miss.
            hitObject.head.hitWindow = new PreciseDroidHitWindow((_a = hitObject.head.hitWindow) === null || _a === void 0 ? void 0 : _a.overallDifficulty);
        }
        else {
            hitObject.hitWindow = new PreciseDroidHitWindow((_b = hitObject.hitWindow) === null || _b === void 0 ? void 0 : _b.overallDifficulty);
        }
    }
}

/**
 * Some utilities, no biggie.
 */
class Utils {
    /**
     * Returns a random element of an array.
     *
     * @param array The array to get the element from.
     */
    static getRandomArrayElement(array) {
        return array[Math.floor(Math.random() * array.length)];
    }
    /**
     * Creates an array with specific length that's prefilled with an initial value.
     *
     * @param length The length of the array.
     * @param initialValue The initial value of each element, or a function that returns the initial value of each element.
     * @returns The array.
     */
    static initializeArray(length, initialValue) {
        const array = new Array(length);
        if (initialValue !== undefined) {
            for (let i = 0; i < length; ++i) {
                array[i] =
                    typeof initialValue === "function"
                        ? initialValue(i)
                        : initialValue;
            }
        }
        return array;
    }
    /**
     * Pauses the execution of a function for
     * the specified duration.
     *
     * @param duration The duration to pause for, in seconds.
     */
    static sleep(duration) {
        return new Promise((resolve) => setTimeout(resolve, duration * 1000));
    }
}

/**
 * A pseudo-random number generator that shares the same implementation with
 * {@link https://github.com/dotnet/runtime/blob/v9.0.4/src/libraries/System.Private.CoreLib/src/System/Random.Net5CompatImpl.cs .NET 5's `System.Random`}.
 *
 * Used in the Random mod to ensure that a seed generates the result that users expect.
 */
class Random {
    /**
     * Constructs a new instance of the `Random` class using the specified seed.
     *
     * @param seed The seed to use for the random number generator. This value is clamped to the range [-2147483648, 2147483647] and must be an integer.
     */
    constructor(seed) {
        this.seedArray = Utils.initializeArray(56, 0);
        this.iNext = 0;
        this.iNextP = 21;
        seed = Math.trunc(seed);
        const subtraction = seed <= Random.MIN_VALUE ? Random.MAX_VALUE : Math.abs(seed);
        // Magic number based on Phi (golden ratio).
        let mj = 161803398 - subtraction;
        this.seedArray[55] = mj;
        let mk = 1;
        let ii = 0;
        for (let i = 1; i < 55; ++i) {
            // The range [1..55] is special (Knuth) and so we're wasting the 0'th position.
            ii = (21 * i) % 55;
            this.seedArray[ii] = mk;
            mk = mj - mk;
            if (mk < 0) {
                mk += Random.MAX_VALUE;
            }
            mj = this.seedArray[ii];
        }
        for (let k = 1; k < 5; ++k) {
            for (let i = 1; i < 56; ++i) {
                const n = (i + 30) % 55;
                this.seedArray[i] -= this.seedArray[n + 1];
                if (this.seedArray[i] < 0) {
                    this.seedArray[i] += Random.MAX_VALUE;
                }
            }
        }
    }
    nextDouble() {
        return this.sample();
    }
    sample() {
        return this.internalSample() / 2147483647;
    }
    internalSample() {
        let locINext = this.iNext;
        if (++locINext >= 56) {
            locINext = 1;
        }
        let locINextP = this.iNextP;
        if (++locINextP >= 56) {
            locINextP = 1;
        }
        let retVal = this.seedArray[locINext] - this.seedArray[locINextP];
        if (retVal === Random.MAX_VALUE) {
            --retVal;
        }
        if (retVal < 0) {
            retVal += Random.MAX_VALUE;
        }
        this.seedArray[locINext] = retVal;
        this.iNext = locINext;
        this.iNextP = locINextP;
        return retVal;
    }
}
Random.MIN_VALUE = -2147483648;
Random.MAX_VALUE = 2147483647;

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 *
 * The value can be `null`, which is treated as a special case.
 */
class NullableIntegerModSetting extends RangeConstrainedModSetting {
    constructor(name, description, defaultValue, min = -2147483648, max = 2147483647) {
        super(name, description, defaultValue, min, max, 1);
        this.displayFormatter = (v) => { var _a; return (_a = v === null || v === void 0 ? void 0 : v.toString()) !== null && _a !== void 0 ? _a : "None"; };
        if (min > max) {
            throw new RangeError(`The minimum value (${min}) must be less than or equal to the maximum value (${max}).`);
        }
        if (defaultValue !== null &&
            (defaultValue < min || defaultValue > max)) {
            throw new RangeError(`The default value (${defaultValue}) must be between the minimum (${min}) and maximum (${max}) values.`);
        }
    }
    processValue(value) {
        if (value === null) {
            return null;
        }
        return Math.trunc(MathUtils.clamp(value, this.min, this.max));
    }
}

/**
 * Represents the Random mod.
 */
class ModRandom extends Mod {
    constructor() {
        super(...arguments);
        this.name = "Random";
        this.acronym = "RD";
        this.droidRanked = false;
        this.osuRanked = false;
        /**
         * The seed to use.
         */
        this.seed = new NullableIntegerModSetting("Seed", "Use a custom seed instead of a random one.", null, 0);
        /**
         * Defines how sharp the angles of `HitObject`s should be.
         */
        this.angleSharpness = new DecimalModSetting("Angle sharpness", "Defines how sharp the angles of hit objects should be.", 7, 1, 10, 0.1, 1);
        this.random = null;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
    copySettings(mod) {
        super.copySettings(mod);
        const { settings } = mod;
        if (typeof (settings === null || settings === void 0 ? void 0 : settings.seed) === "number") {
            this.seed.value = settings.seed;
        }
        if (typeof (settings === null || settings === void 0 ? void 0 : settings.angleSharpness) === "number") {
            this.angleSharpness.value = settings.angleSharpness;
        }
    }
    applyToBeatmap(beatmap) {
        var _a;
        var _b;
        (_a = (_b = this.seed).value) !== null && _a !== void 0 ? _a : (_b.value = Math.floor(Math.random() * 2147483647));
        this.random = new Random(this.seed.value);
        const positionInfos = HitObjectGenerationUtils.generatePositionInfos(beatmap.hitObjects.objects);
        // Offsets the angles of all hit objects in a "section" by the same amount.
        let sectionOffset = 0;
        // Whether the angles are positive or negative (clockwise or counter-clockwise flow).
        let flowDirection = false;
        for (let i = 0; i < positionInfos.length; ++i) {
            const positionInfo = positionInfos[i];
            if (this.shouldStartNewSection(beatmap, positionInfos, i)) {
                sectionOffset = this.getRandomOffset(0.0008);
                flowDirection = !flowDirection;
            }
            if (positionInfo.hitObject instanceof Slider &&
                this.random.nextDouble() < 0.5) {
                HitObjectGenerationUtils.flipSliderInPlaceHorizontally(positionInfo.hitObject);
            }
            if (i === 0) {
                positionInfo.distanceFromPrevious =
                    this.random.nextDouble() * Playfield.center.y;
                positionInfo.relativeAngle =
                    this.random.nextDouble() * 2 * Math.PI - Math.PI;
            }
            else {
                // Offsets only the angle of the current hit object if a flow change occurs.
                let flowChangeOffset = 0;
                // Offsets only the angle of the current hit object.
                const oneTimeOffset = this.getRandomOffset(0.002);
                if (this.shouldApplyFlowChange(positionInfos, i)) {
                    flowChangeOffset = this.getRandomOffset(0.002);
                    flowDirection = !flowDirection;
                }
                const totalOffset = 
                // sectionOffset and oneTimeOffset should mainly affect patterns with large spacing.
                (sectionOffset + oneTimeOffset) *
                    positionInfo.distanceFromPrevious +
                    // flowChangeOffset should mainly affect streams.
                    flowChangeOffset *
                        (ModRandom.playfieldDiagonal -
                            positionInfo.distanceFromPrevious);
                positionInfo.relativeAngle = this.getRelativeTargetAngle(positionInfo.distanceFromPrevious, totalOffset, flowDirection);
            }
        }
        const repositionedHitObjects = HitObjectGenerationUtils.repositionHitObjects(positionInfos);
        for (let i = 0; i < repositionedHitObjects.length; ++i) {
            beatmap.hitObjects.objects[i] = repositionedHitObjects[i];
        }
    }
    serializeSettings() {
        const settings = {};
        if (this.seed.value !== null) {
            settings.seed = this.seed.value;
        }
        settings.angleSharpness = this.angleSharpness.value;
        return settings;
    }
    getRandomOffset(stdDev) {
        // Range: [0.5, 2]
        // Higher angle sharpness -> lower multiplier
        const customMultiplier = (1.5 * this.angleSharpness.max - this.angleSharpness.value) /
            (1.5 * this.angleSharpness.max - this.angleSharpness.defaultValue);
        return HitObjectGenerationUtils.randomGaussian(this.random, 0, stdDev * customMultiplier);
    }
    /**
     * @param targetDistance The target distance between the previous and the current `HitObject`.
     * @param offset The angle (in radians) by which the target angle should be offset.
     * @param flowDirection Whether the relative angle should be positive (`false`) or negative (`true`).
     */
    getRelativeTargetAngle(targetDistance, offset, flowDirection) {
        // Range: [0.1, 1]
        const angleSharpness = this.angleSharpness.value / this.angleSharpness.max;
        // Range: [0, 0.9]
        const angleWideness = 1 - angleSharpness;
        // Range: [-60, 30]
        const customOffsetX = angleSharpness * 100 - 70;
        // Range: [-0.075, 0.15]
        const customOffsetY = angleWideness * 0.25 - 0.075;
        const angle = 2.16 /
            (1 +
                200 *
                    Math.exp(0.036 * (targetDistance + customOffsetX * 2 - 310))) +
            0.5 +
            offset +
            customOffsetY;
        const relativeAngle = Math.PI - angle;
        return flowDirection ? -relativeAngle : relativeAngle;
    }
    /**
     * Determines whether a new section should be started at the current [HitObject].
     */
    shouldStartNewSection(beatmap, positionInfos, i) {
        if (i === 0) {
            return true;
        }
        // Exclude new-combo-spam and 1-2-combos.
        const previousObjectStartedCombo = positionInfos[Math.max(0, i - 2)].hitObject.indexInCurrentCombo >
            1 && positionInfos[i - 1].hitObject.isNewCombo;
        const previousObjectWasOnDownBeat = HitObjectGenerationUtils.isHitObjectOnBeat(beatmap, positionInfos[i - 1].hitObject, true);
        const previousObjectWasOnBeat = HitObjectGenerationUtils.isHitObjectOnBeat(beatmap, positionInfos[i - 1].hitObject);
        return ((previousObjectStartedCombo && this.random.nextDouble() < 0.6) ||
            previousObjectWasOnDownBeat ||
            (previousObjectWasOnBeat && this.random.nextDouble() < 0.4));
    }
    shouldApplyFlowChange(positionInfos, i) {
        // Exclude new-combo-spam and 1-2-combos.
        const previousObjectStartedCombo = positionInfos[Math.max(0, i - 2)].hitObject.indexInCurrentCombo >
            1 && positionInfos[i - 1].hitObject.isNewCombo;
        return previousObjectStartedCombo && this.random.nextDouble() < 0.6;
    }
    toString() {
        const settings = [];
        if (this.seed.value !== null) {
            settings.push(`seed: ${this.seed.value}`);
        }
        settings.push(`angle sharpness: ${this.angleSharpness.toDisplayString()}`);
        return `${super.toString()} (${settings.join(", ")})`;
    }
}
ModRandom.playfieldDiagonal = Playfield.baseSize.length;

/**
 * Represents the ReallyEasy mod.
 */
class ModReallyEasy extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "RE";
        this.name = "ReallyEasy";
        this.droidRanked = false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.4;
    }
    applyToDifficultyWithMods(mode, difficulty, mods) {
        var _a;
        if (mode !== exports.Modes.droid) {
            return;
        }
        const difficultyAdjust = mods.get(ModDifficultyAdjust);
        if (typeof (difficultyAdjust === null || difficultyAdjust === void 0 ? void 0 : difficultyAdjust.ar.value) !== "number") {
            if (mods.has(ModEasy)) {
                difficulty.ar *= 2;
                difficulty.ar -= 0.5;
            }
            const customSpeed = mods.get(ModCustomSpeed);
            difficulty.ar -= 0.5;
            difficulty.ar -= ((_a = customSpeed === null || customSpeed === void 0 ? void 0 : customSpeed.trackRateMultiplier.value) !== null && _a !== void 0 ? _a : 1) - 1;
        }
        if (typeof (difficultyAdjust === null || difficultyAdjust === void 0 ? void 0 : difficultyAdjust.cs.value) !== "number") {
            if (!mods.has(ModReplayV6)) {
                difficulty.cs /= 2;
            }
            else {
                const scale = CircleSizeCalculator.droidCSToOldDroidScale(difficulty.cs);
                // The 0.125 scale that was added before replay version 7 was in screen pixels. We need it in osu! pixels.
                difficulty.cs = CircleSizeCalculator.oldDroidScaleToDroidCS(scale +
                    CircleSizeCalculator.oldDroidScaleScreenPixelsToOsuPixels(0.125));
            }
        }
        if (typeof (difficultyAdjust === null || difficultyAdjust === void 0 ? void 0 : difficultyAdjust.od.value) !== "number") {
            difficulty.od /= 2;
        }
        if (typeof (difficultyAdjust === null || difficultyAdjust === void 0 ? void 0 : difficultyAdjust.hp.value) !== "number") {
            difficulty.hp /= 2;
        }
    }
}

/**
 * Represents the ScoreV2 mod.
 */
class ModScoreV2 extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "V2";
        this.name = "ScoreV2";
        this.droidRanked = false;
        this.osuRanked = false;
        this.bitwise = 1 << 29;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents the SmallCircle mod.
 *
 * This is a legacy osu!droid mod that may still be exist when parsing replays.
 */
class ModSmallCircle extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "SC";
        this.name = "SmallCircle";
        this.droidRanked = false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1.06;
    }
    migrateDroidMod(difficulty) {
        return new ModDifficultyAdjust({ cs: difficulty.cs + 4 });
    }
    applyToDifficulty(mode, difficulty, adjustmentMods) {
        if (mode === exports.Modes.osu || !adjustmentMods.has(ModDifficultyAdjust)) {
            difficulty.cs += 4;
        }
        else {
            const scale = CircleSizeCalculator.droidCSToOldDroidScale(difficulty.cs);
            difficulty.cs = CircleSizeCalculator.oldDroidScaleToDroidCS(scale + CircleSizeCalculator.droidCSToOldDroidScale(4));
        }
    }
}

/**
 * Represents the SpunOut mod.
 */
class ModSpunOut extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "SO";
        this.name = "SpunOut";
        this.osuRanked = true;
        this.bitwise = 1 << 12;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0.9;
    }
}

/**
 * Represents the Synesthesia mod in osu! and osu!droid.
 */
class ModSynesthesia extends Mod {
    constructor() {
        super(...arguments);
        this.name = "Synesthesia";
        this.acronym = "SY";
        this.droidRanked = false;
        this.osuRanked = false;
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 0.8;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 0.8;
    }
}

/**
 * Represents the TouchDevice mod.
 */
class ModTouchDevice extends Mod {
    constructor() {
        super(...arguments);
        this.acronym = "TD";
        this.name = "TouchDevice";
        this.osuRanked = true;
        this.bitwise = 1 << 2;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Holds interpolation methods for numbers and vectors.
 */
class Interpolation {
    static lerp(start, final, amount) {
        if (start instanceof Vector2 && final instanceof Vector2) {
            return new Vector2(this.lerp(start.x, final.x, amount), this.lerp(start.y, final.y, amount));
        }
        else {
            return (start +
                (final - start) * amount);
        }
    }
    /**
     * Calculates the reverse [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation)
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @return The output of the reverse linear interpolation function calculated at `x`.
     */
    static reverseLerp(x, start, end) {
        return MathUtils.clamp((x - start) / (end - start), 0, 1);
    }
    /**
     * Interpolates a value using an easing function.
     *
     * @param easing The easing function to use.
     * @param t The progress of the interpolation, from 0 to 1.
     * @returns The interpolated value.
     */
    static easing(easing, t) {
        switch (easing) {
            case exports.Easing.none:
                return t;
            case exports.Easing.out:
            case exports.Easing.outQuad:
                return t * (2 - t);
            case exports.Easing.in:
            case exports.Easing.inQuad:
                return t * t;
            case exports.Easing.inOutQuad:
                return t < 0.5 ? t * t * 2 : --t * t * -2 + 1;
            case exports.Easing.inCubic:
                return t * t * t;
            case exports.Easing.outCubic:
                return --t * t * t + 1;
            case exports.Easing.inOutCubic:
                return t < 0.5 ? t * t * t * 4 : --t * t * t * 4 + 1;
            case exports.Easing.inQuart:
                return t * t * t * t;
            case exports.Easing.outQuart:
                return 1 - --t * t * t * t;
            case exports.Easing.inOutQuart:
                return t < 0.5 ? t * t * t * t * 8 : --t * t * t * t * -8 + 1;
            case exports.Easing.inQuint:
                return t * t * t * t * t;
            case exports.Easing.outQuint:
                return --t * t * t * t * t + 1;
            case exports.Easing.inOutQuint:
                return t < 0.5
                    ? t * t * t * t * t * 16
                    : --t * t * t * t * t * 16 + 1;
            case exports.Easing.inSine:
                return 1 - Math.cos((t * Math.PI) / 2);
            case exports.Easing.outSine:
                return Math.sin((t * Math.PI) / 2);
            case exports.Easing.inOutSine:
                return 0.5 - 0.5 * Math.cos(Math.PI * t);
            case exports.Easing.inExpo:
                return t === 0 ? 0 : Math.pow(2, 10 * t - 10);
            case exports.Easing.outExpo:
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            case exports.Easing.inOutExpo:
                if (t === 0) {
                    return 0;
                }
                if (t === 1) {
                    return 1;
                }
                if ((t *= 2) < 1) {
                    return 0.5 * Math.pow(2, 10 * t - 10);
                }
                return 0.5 * (2 - Math.pow(2, -10 * --t));
            case exports.Easing.inCirc:
                return 1 - Math.sqrt(1 - t * t);
            case exports.Easing.outCirc:
                return Math.sqrt(1 - --t * t);
            case exports.Easing.inOutCirc:
                return (t *= 2) < 1
                    ? 0.5 - 0.5 * Math.sqrt(1 - t * t)
                    : 0.5 * Math.sqrt(1 - (t -= 2) * t) + 0.5;
            case exports.Easing.inElastic:
                return (-Math.pow(2, -10 + 10 * t) *
                    Math.sin((1 - 0.3 / 4 - t) * ((2 * Math.PI) / 0.3)));
            case exports.Easing.outElastic:
                return (Math.pow(2, -10 * t) *
                    Math.sin((t - 0.3 / 4) * ((2 * Math.PI) / 0.3)) +
                    1);
            case exports.Easing.outElasticHalf:
                return (Math.pow(2, -10 * t) *
                    Math.sin((0.5 * t - 0.3 / 4) * ((2 * Math.PI) / 0.3)) +
                    1);
            case exports.Easing.outElasticQuarter:
                return (Math.pow(2, -10 * t) *
                    Math.sin((0.25 * t - 0.3 / 4) * ((2 * Math.PI) / 0.3)) +
                    1);
            case exports.Easing.inOutElastic:
                if (t === 0) {
                    return 0;
                }
                if (t === 1) {
                    return 1;
                }
                if ((t *= 2) < 1) {
                    return (-0.5 *
                        Math.pow(2, -10 + 10 * t) *
                        Math.sin(((1 - (0.3 / 4) * 1.5 - t) *
                            ((2 * Math.PI) / 0.3)) /
                            1.5));
                }
                return (0.5 *
                    Math.pow(2, -10 * --t) *
                    Math.sin(((t - (0.3 / 4) * 1.5) * ((2 * Math.PI) / 0.3)) /
                        1.5) +
                    1);
            case exports.Easing.inBack:
                return t * t * ((1.70158 + 1) * t - 1.70158);
            case exports.Easing.outBack:
                return --t * t * ((1.70158 + 1) * t + 1.70158) + 1;
            case exports.Easing.inOutBack:
                return (t *= 2) < 1
                    ? 0.5 *
                        t *
                        t *
                        ((1.70158 * 1.525 + 1) * t - 1.70158 * 1.525)
                    : 0.5 *
                        ((t -= 2) *
                            t *
                            ((1.70158 * 1.525 + 1) * t + 1.70158 * 1.525) +
                            2);
            case exports.Easing.inBounce:
                t = 1 - t;
                if (t < 1 / 2.75) {
                    return 1 - 7.5625 * t * t;
                }
                if (t < 2 / 2.75) {
                    return 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75);
                }
                if (t < 2.5 / 2.75) {
                    return 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375);
                }
                return 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375);
            case exports.Easing.outBounce:
                if (t < 1 / 2.75) {
                    return 7.5625 * t * t;
                }
                if (t < 2 / 2.75) {
                    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                }
                if (t < 2.5 / 2.75) {
                    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                }
                return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
            case exports.Easing.inOutBounce:
                return t < 0.5
                    ? 0.5 - 0.5 * this.easing(exports.Easing.outBounce, 1 - t * 2)
                    : 0.5 * this.easing(exports.Easing.outBounce, (t - 0.5) * 2) + 0.5;
            case exports.Easing.outPow10:
                return --t * Math.pow(t, 10) + 1;
        }
    }
}

/**
 * Represents a mod that gradually adjusts the track's playback rate over time.
 */
class ModTimeRamp extends Mod {
    constructor() {
        super();
        this.initialRateTime = 0;
        this.finalRateTime = 0;
        this.incompatibleMods.add(ModTimeRamp);
    }
    copySettings(mod) {
        var _a, _b;
        super.copySettings(mod);
        const { settings } = mod;
        this.initialRate.value =
            (_a = settings === null || settings === void 0 ? void 0 : settings.initialRate) !== null && _a !== void 0 ? _a : this.initialRate.value;
        this.finalRate.value =
            (_b = settings === null || settings === void 0 ? void 0 : settings.finalRate) !== null && _b !== void 0 ? _b : this.finalRate.value;
    }
    applyToBeatmap(beatmap) {
        var _a, _b, _c, _d;
        this.initialRateTime = (_b = (_a = beatmap.hitObjects.objects.at(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0;
        this.finalRateTime = Interpolation.lerp(this.initialRateTime, (_d = (_c = beatmap.hitObjects.objects.at(-1)) === null || _c === void 0 ? void 0 : _c.endTime) !== null && _d !== void 0 ? _d : 0, ModTimeRamp.finalRateProgress);
    }
    applyToRate(time, rate) {
        const amount = (time - this.initialRateTime) /
            (this.finalRateTime - this.initialRateTime);
        return (rate *
            Interpolation.lerp(this.initialRate.value, this.finalRate.value, MathUtils.clamp(amount, 0, 1)));
    }
    serializeSettings() {
        return {
            initialRate: this.initialRate.value,
            finalRate: this.finalRate.value,
        };
    }
    toString() {
        return `${super.toString()} (${this.initialRate.toDisplayString()}x - ${this.finalRate.toDisplayString()}x)`;
    }
}
/**
 * The point in the beatmap at which the final rate should be reached.
 */
ModTimeRamp.finalRateProgress = 0.75;

/**
 * Represents the Wind Down mod.
 */
class ModWindDown extends ModTimeRamp {
    constructor() {
        super();
        this.name = "Wind Down";
        this.acronym = "WD";
        this.droidRanked = false;
        this.osuRanked = false;
        this.initialRate = new DecimalModSetting("Initial rate", "The starting speed of the track.", 1, 0.51, 2, 0.01, 2);
        this.finalRate = new DecimalModSetting("Final rate", "The final speed to ramp to.", 0.75, 0.5, 1.99, 0.01, 2);
        this.initialRate.bindValueChanged((_, value) => {
            if (value <= this.finalRate.value) {
                this.finalRate.value = value - this.finalRate.step;
            }
        });
        this.finalRate.bindValueChanged((_, value) => {
            if (value >= this.initialRate.value) {
                this.initialRate.value = value + this.initialRate.step;
            }
        });
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Represents the Wind Up mod.
 */
class ModWindUp extends ModTimeRamp {
    constructor() {
        super();
        this.name = "Wind Up";
        this.acronym = "WU";
        this.droidRanked = false;
        this.osuRanked = false;
        this.initialRate = new DecimalModSetting("Initial rate", "The starting speed of the track.", 1, 0.5, 1.99, 0.01, 2);
        this.finalRate = new DecimalModSetting("Final rate", "The final speed to ramp to.", 1.5, 0.51, 2, 0.01, 2);
        this.initialRate.bindValueChanged((_, value) => {
            if (value >= this.finalRate.value) {
                this.finalRate.value = value + this.finalRate.step;
            }
        });
        this.finalRate.bindValueChanged((_, value) => {
            if (value <= this.initialRate.value) {
                this.initialRate.value = value - this.initialRate.step;
            }
        });
    }
    get isDroidRelevant() {
        return true;
    }
    calculateDroidScoreMultiplier() {
        return 1;
    }
    get isOsuRelevant() {
        return true;
    }
    get osuScoreMultiplier() {
        return 1;
    }
}

/**
 * Utilities for mods.
 */
class ModUtil {
    /**
     * Gets a list of mods from a PC modbits.
     *
     * @param modbits The modbits.
     * @returns The list of mods.
     */
    static pcModbitsToMods(modbits) {
        const map = new ModMap();
        if (modbits === 0) {
            return map;
        }
        for (const modType of this.allMods.values()) {
            const mod = new modType();
            if (mod.isApplicableToOsuStable() && (mod.bitwise & modbits) > 0) {
                map.set(mod);
            }
        }
        return map;
    }
    /**
     * Serializes a list of `Mod`s.
     *
     * @param mods The list of `Mod`s to serialize.
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns The serialized list of `Mod`s.
     */
    static serializeMods(mods, includeNonUserPlayable = true) {
        const serializedMods = [];
        for (const mod of mods) {
            if (!includeNonUserPlayable && !mod.userPlayable) {
                continue;
            }
            serializedMods.push(mod.serialize());
        }
        return serializedMods;
    }
    /**
     * Deserializes a list of `SerializedMod`s.
     *
     * @param mods The list of `SerializedMod`s to deserialize.
     * @returns The deserialized list of `Mod`s.
     */
    static deserializeMods(mods) {
        const map = new ModMap();
        for (const serializedMod of mods) {
            const modType = this.allMods.get(serializedMod.acronym);
            if (!modType) {
                continue;
            }
            const mod = new modType();
            if (serializedMod.settings) {
                mod.copySettings(serializedMod);
            }
            map.set(mod);
        }
        return map;
    }
    /**
     * Gets a list of mods from a PC mod string, such as "HDHR".
     *
     * @param str The string.
     * @returns The list of mods.
     */
    static pcStringToMods(str) {
        const map = new ModMap();
        str = str.toLowerCase();
        while (str) {
            let nchars = 1;
            for (const [acronym, modType] of this.allMods) {
                if (str.startsWith(acronym.toLowerCase())) {
                    map.set(modType);
                    nchars = acronym.length;
                    break;
                }
            }
            str = str.slice(nchars);
        }
        return map;
    }
    /**
     * Converts a list of mods into its osu!standard string counterpart.
     *
     * @param mods The array of mods to convert.
     * @returns The string representing the mods in osu!standard.
     */
    static modsToOsuString(mods) {
        let str = "";
        for (const mod of mods) {
            if (mod instanceof ModDifficultyAdjust) {
                continue;
            }
            str += mod.acronym;
        }
        return str;
    }
    /**
     * Converts a list of `Mod`s into an ordered string based on {@link allMods}.
     *
     * @param mods The list of `Mod`s to convert.
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns The string representing the `Mod`s in ordered form.
     */
    static modsToOrderedString(mods, includeNonUserPlayable = true) {
        const strs = [];
        for (const modType of this.allMods.values()) {
            const mod = mods instanceof ModMap
                ? mods.get(modType)
                : mods.find((m) => m instanceof modType);
            if (mod && (includeNonUserPlayable || mod.userPlayable)) {
                strs.push(mod.toString());
                continue;
            }
        }
        return strs.join();
    }
    /**
     * Removes speed-changing mods from an array of mods.
     *
     * @param mods The array of mods.
     * @returns A new array with speed changing mods filtered out.
     */
    static removeSpeedChangingMods(mods) {
        return mods.filter((m) => !(m instanceof ModRateAdjust));
    }
    /**
     * Applies the selected `Mod`s to a `BeatmapDifficulty`.
     *
     * @param difficulty The `BeatmapDifficulty` to apply the `Mod`s to.
     * @param mode The game mode to apply the `Mod`s for.
     * @param mods The selected `Mod`s. Defaults to No Mod.
     * @param withRateChange Whether to apply rate changes. Defaults to `false`.
     */
    static applyModsToBeatmapDifficulty(difficulty, mode, mods, withRateChange = false) {
        if (mods !== undefined) {
            const adjustmentMods = new ModMap();
            for (const mod of mods.values()) {
                if (mod.facilitatesAdjustment()) {
                    adjustmentMods.set(mod);
                }
            }
            for (const mod of mods.values()) {
                if (mod.isApplicableToDifficulty()) {
                    mod.applyToDifficulty(mode, difficulty, adjustmentMods);
                }
            }
        }
        let rate = 1;
        if (mods !== undefined) {
            for (const mod of mods.values()) {
                if (mod.isApplicableToDifficultyWithMods()) {
                    mod.applyToDifficultyWithMods(mode, difficulty, mods);
                }
                if (mod.isApplicableToTrackRate()) {
                    rate = mod.applyToRate(0, rate);
                }
            }
        }
        if (!withRateChange) {
            return;
        }
        // Apply rate adjustments
        const preempt = BeatmapDifficulty.difficultyRange(difficulty.ar, HitObject.preemptMax, HitObject.preemptMid, HitObject.preemptMin) / rate;
        difficulty.ar = BeatmapDifficulty.inverseDifficultyRange(preempt, HitObject.preemptMax, HitObject.preemptMid, HitObject.preemptMin);
        switch (mode) {
            case exports.Modes.droid:
                if (mods === null || mods === void 0 ? void 0 : mods.has(ModPrecise)) {
                    const hitWindow = new PreciseDroidHitWindow(difficulty.od);
                    difficulty.od = PreciseDroidHitWindow.greatWindowToOD(hitWindow.greatWindow / rate);
                }
                else {
                    const hitWindow = new DroidHitWindow(difficulty.od);
                    difficulty.od = DroidHitWindow.greatWindowToOD(hitWindow.greatWindow / rate);
                }
                break;
            case exports.Modes.osu: {
                const hitWindow = new OsuHitWindow(difficulty.od);
                difficulty.od = OsuHitWindow.greatWindowToOD(hitWindow.greatWindow / rate);
                break;
            }
        }
    }
    /**
     * Calculates the playback rate for the track with the selected `Mod`s at the given time.
     *
     * @param mods The list of selected `Mod`s.
     * @param time The time at which the playback rate is queried, in milliseconds. Defaults to 0.
     * @returns The rate with `Mod`s.
     */
    static calculateRateWithMods(mods, time = 0) {
        let rate = 1;
        for (const mod of mods) {
            if (mod.isApplicableToTrackRate()) {
                rate = mod.applyToRate(time, rate);
            }
        }
        return rate;
    }
}
/**
 * All `Mod`s that exists, mapped by their acronym.
 */
ModUtil.allMods = (() => {
    const mods = [
        // Janky order to keep the order on what players are used to
        ModAuto,
        ModRelax,
        ModAutopilot,
        ModEasy,
        ModNoFail,
        ModHidden,
        ModApproachDifferent,
        ModFreezeFrame,
        ModTraceable,
        ModDoubleTime,
        ModNightCore,
        ModHalfTime,
        ModCustomSpeed,
        ModWindDown,
        ModWindUp,
        ModHardRock,
        ModMirror,
        ModGrow,
        ModDeflate,
        ModDifficultyAdjust,
        ModFlashlight,
        ModSuddenDeath,
        ModPerfect,
        ModPrecise,
        ModRandom,
        ModReallyEasy,
        ModMuted,
        ModSynesthesia,
        ModReplayV6,
        ModScoreV2,
        ModSmallCircle,
        ModSpunOut,
        ModTouchDevice,
    ];
    const map = new Map();
    for (const mod of mods) {
        map.set(new mod().acronym, mod);
    }
    return map;
})();

/**
 * A map that stores `Mod`s depending on their type.
 *
 * This also has additional utilities to eliminate unnecessary `Mod`s.
 */
class ModMap extends Map {
    /**
     * Whether this map is empty.
     */
    get isEmpty() {
        return this.size === 0;
    }
    constructor(iterable) {
        // We are not passing `iterable` here to preserve mod-specific settings.
        super();
        if (Array.isArray(iterable)) {
            for (const [key, value] of iterable) {
                // Ensure the mod type corresponds to the mod instance.
                if (key !== value.constructor) {
                    throw new TypeError(`Key ${key.name} does not match value ${value.constructor.name}`);
                }
                this.set(value);
            }
        }
    }
    has(keyOrValue) {
        const key = keyOrValue instanceof Mod
            ? keyOrValue.constructor
            : keyOrValue;
        return super.has(key);
    }
    get(key) {
        return super.get(key);
    }
    set(keyOrValue) {
        const key = (keyOrValue instanceof Mod ? keyOrValue.constructor : keyOrValue);
        const value = keyOrValue instanceof Mod ? keyOrValue : new key();
        // Ensure the mod type corresponds to the mod instance.
        if (key !== value.constructor) {
            throw new TypeError(`Key ${key.name} does not match value ${value.constructor.name}`);
        }
        const existing = this.get(key);
        // If all difficulty statistics are set, all other difficulty adjusting mods are irrelevant, so we remove them.
        // This prevents potential abuse cases where score multipliers from non-affecting mods stack (i.e., forcing
        // all difficulty statistics while using the Hard Rock mod).
        const removeDifficultyAdjustmentMods = value instanceof ModDifficultyAdjust &&
            value.cs !== undefined &&
            value.ar !== undefined &&
            value.od !== undefined &&
            value.hp !== undefined;
        if (removeDifficultyAdjustmentMods) {
            this.delete(ModEasy);
            this.delete(ModHardRock);
            this.delete(ModReallyEasy);
            this.delete(ModSmallCircle);
        }
        // Check if there are any mods that are incompatible with the new mod.
        // If so, remove them.
        for (const incompatibleMod of value.incompatibleMods) {
            for (const mod of this.values()) {
                if (mod instanceof incompatibleMod) {
                    this.delete(mod.constructor);
                }
            }
        }
        super.set(key, value);
        return existing !== null && existing !== void 0 ? existing : null;
    }
    /**
     * Serializes all `Mod`s that are in this map.
     *
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     */
    serializeMods(includeNonUserPlayable = true) {
        return ModUtil.serializeMods(this.values(), includeNonUserPlayable);
    }
    /**
     * Determines whether this `ModMap` is equal to another `ModMap`.
     *
     * This equality check succeeds if and only if the two `ModMap`s have the same size and
     * all `Mod`s in this `ModMap` are equal to the corresponding `Mod`s in the other `ModMap`.
     *
     * @param other The other `ModMap` to compare to.
     * @returns Whether the two `ModMap`s are equal.
     */
    equals(other) {
        if (this.size !== other.size) {
            return false;
        }
        for (const [key, value] of this) {
            const otherValue = other.get(key);
            if (!(otherValue === null || otherValue === void 0 ? void 0 : otherValue.equals(value))) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a string representation of this `ModMap`.
     *
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns A string representation of this `ModMap`.
     */
    toString(includeNonUserPlayable = true) {
        return ModUtil.modsToOrderedString(this, includeNonUserPlayable);
    }
}

/**
 * Contains information about hit objects of a beatmap.
 */
class BeatmapHitObjects {
    constructor() {
        /**
         * The objects of the beatmap.
         */
        this.objects = [];
        this._circles = 0;
        this._sliders = 0;
        this._spinners = 0;
    }
    /**
     * The amount of circles in the beatmap.
     */
    get circles() {
        return this._circles;
    }
    /**
     * The amount of sliders in the beatmap.
     */
    get sliders() {
        return this._sliders;
    }
    /**
     * The amount of spinners in the beatmap.
     */
    get spinners() {
        return this._spinners;
    }
    /**
     * The amount of slider ticks in the beatmap.
     *
     * This iterates through all objects and should be stored locally or used sparingly.
     */
    get sliderTicks() {
        return this.objects.reduce((acc, cur) => (cur instanceof Slider ? acc + cur.ticks : acc), 0);
    }
    /**
     * The amount of sliderends in the beatmap.
     */
    get sliderEnds() {
        return this.sliders;
    }
    /**
     * The amount of slider repeat points in the beatmap.
     *
     * This iterates through all objects and should be stored locally or used sparingly.
     */
    get sliderRepeatPoints() {
        return this.objects.reduce((acc, cur) => (cur instanceof Slider ? acc + cur.repeatCount : acc), 0);
    }
    /**
     * Adds hitobjects.
     *
     * The sorting order of hitobjects will be maintained.
     *
     * @param objects The hitobjects to add.
     */
    add(...objects) {
        for (const object of objects) {
            // Objects may be out of order *only* if a user has manually edited an .osu file.
            // Unfortunately there are "ranked" maps in this state (example: https://osu.ppy.sh/s/594828).
            // Finding index is used to guarantee that the parsing order of hitobjects with equal start times is maintained (stably-sorted).
            this.objects.splice(this.findInsertionIndex(object.startTime), 0, object);
            if (object instanceof Circle) {
                ++this._circles;
            }
            else if (object instanceof Slider) {
                ++this._sliders;
            }
            else {
                ++this._spinners;
            }
        }
    }
    /**
     * Removes a hitobject at an index.
     *
     * @param index The index of the hitobject to remove.
     * @returns The hitobject that was removed, `null` if no hitobject was removed.
     */
    removeAt(index) {
        var _a;
        const object = (_a = this.objects.splice(index, 1)[0]) !== null && _a !== void 0 ? _a : null;
        if (object instanceof Circle) {
            --this._circles;
        }
        else if (object instanceof Slider) {
            --this._sliders;
        }
        else if (object instanceof Spinner) {
            --this._spinners;
        }
        return object;
    }
    /**
     * Clears all hitobjects.
     */
    clear() {
        this.objects.length = 0;
        this._circles = 0;
        this._sliders = 0;
        this._spinners = 0;
    }
    [Symbol.iterator]() {
        return this.objects[Symbol.iterator]();
    }
    /**
     * Finds the insertion index of a hitobject in a given time.
     *
     * @param startTime The start time of the hitobject.
     */
    findInsertionIndex(startTime) {
        if (this.objects.length === 0 ||
            startTime < this.objects[0].startTime) {
            return 0;
        }
        if (startTime >= this.objects.at(-1).startTime) {
            return this.objects.length;
        }
        let l = 0;
        let r = this.objects.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            if (this.objects[pivot].startTime < startTime) {
                l = pivot + 1;
            }
            else if (this.objects[pivot].startTime > startTime) {
                r = pivot - 1;
            }
            else {
                return pivot;
            }
        }
        return l;
    }
}

/**
 * Converts a beatmap for another mode.
 */
class BeatmapConverter {
    constructor(beatmap) {
        this.beatmap = beatmap;
    }
    /**
     * Converts the beatmap.
     *
     * @returns The converted beatmap.
     */
    convert() {
        const converted = new Beatmap(this.beatmap);
        // Shallow clone isn't enough to ensure we don't mutate some beatmap properties unexpectedly.
        converted.difficulty = new BeatmapDifficulty(this.beatmap.difficulty);
        converted.hitObjects = this.convertHitObjects();
        return converted;
    }
    convertHitObjects() {
        const hitObjects = new BeatmapHitObjects();
        this.beatmap.hitObjects.objects.forEach((hitObject) => {
            hitObjects.add(this.convertHitObject(hitObject));
        });
        return hitObjects;
    }
    convertHitObject(hitObject) {
        let object;
        if (hitObject instanceof Circle) {
            object = new Circle({
                startTime: hitObject.startTime,
                position: hitObject.position,
                newCombo: hitObject.isNewCombo,
                type: hitObject.type,
                comboOffset: hitObject.comboOffset,
            });
        }
        else if (hitObject instanceof Slider) {
            object = new Slider({
                startTime: hitObject.startTime,
                position: hitObject.position,
                newCombo: hitObject.isNewCombo,
                type: hitObject.type,
                path: hitObject.path,
                repeatCount: hitObject.repeatCount,
                nodeSamples: hitObject.nodeSamples,
                comboOffset: hitObject.comboOffset,
                tickDistanceMultiplier: 
                // Prior to v8, speed multipliers don't adjust for how many ticks are generated over the same distance.
                // This results in more (or less) ticks being generated in <v8 maps for the same time duration.
                this.beatmap.formatVersion < 8
                    ? 1 /
                        this.beatmap.controlPoints.difficulty.controlPointAt(hitObject.startTime).speedMultiplier
                    : 1,
            });
        }
        else {
            object = new Spinner({
                startTime: hitObject.startTime,
                endTime: hitObject.endTime,
                type: hitObject.type,
            });
        }
        object.samples = hitObject.samples;
        object.auxiliarySamples = hitObject.auxiliarySamples;
        return object;
    }
}

/**
 * Provides functionality to alter a beatmap after it has been converted.
 */
class BeatmapProcessor {
    constructor(beatmap) {
        this.beatmap = beatmap;
    }
    /**
     * Processes the converted beatmap prior to `HitObject.applyDefaults` being invoked.
     *
     * Nested hitobjects generated during `HitObject.applyDefaults` will not be present by this point,
     * and no mods will have been applied to the hitobjects.
     *
     * This can only be used to add alterations to hitobjects generated directly through the conversion process.
     */
    preProcess() {
        let last = null;
        for (const object of this.beatmap.hitObjects.objects) {
            object.updateComboInformation(last);
            last = object;
        }
        // Mark the last object in the beatmap as last in combo.
        if (last) {
            last.isLastInCombo = true;
        }
    }
    /**
     * Processes the converted beatmap after `HitObject.applyDefaults` has been invoked.
     *
     * Nested hitobjects generated during `HitObject.applyDefaults` wil be present by this point,
     * and mods will have been applied to all hitobjects.
     *
     * This should be used to add alterations to hitobjects while they are in their most playable state.
     */
    postProcess() {
        const objects = this.beatmap.hitObjects.objects;
        if (objects.length === 0) {
            return;
        }
        // Reset stacking
        objects.forEach((h) => {
            h.stackHeight = 0;
        });
        if (this.beatmap.formatVersion >= 6) {
            this.applyStacking();
        }
        else {
            this.applyOldStacking();
        }
    }
    applyStacking() {
        const objects = this.beatmap.hitObjects.objects;
        const startIndex = 0;
        const endIndex = objects.length - 1;
        let extendedEndIndex = endIndex;
        if (endIndex < objects.length - 1) {
            for (let i = endIndex; i >= startIndex; --i) {
                let stackBaseIndex = i;
                for (let n = stackBaseIndex + 1; n < objects.length; ++n) {
                    const stackBaseObject = objects[stackBaseIndex];
                    if (stackBaseObject instanceof Spinner) {
                        break;
                    }
                    const objectN = objects[n];
                    if (objectN instanceof Spinner) {
                        break;
                    }
                    const stackThreshold = objectN.timePreempt *
                        this.beatmap.general.stackLeniency;
                    if (objectN.startTime - stackBaseObject.endTime >
                        stackThreshold) {
                        // We are no longer within stacking range of the next object.
                        break;
                    }
                    const endPositionDistanceCheck = stackBaseObject instanceof Slider
                        ? stackBaseObject.endPosition.getDistance(objectN.position) < BeatmapProcessor.stackDistance
                        : false;
                    if (stackBaseObject.position.getDistance(objectN.position) <
                        BeatmapProcessor.stackDistance ||
                        endPositionDistanceCheck) {
                        stackBaseIndex = n;
                        // Hit objects after the specified update range haven't been reset yet
                        objectN.stackHeight = 0;
                    }
                }
                if (stackBaseIndex > extendedEndIndex) {
                    extendedEndIndex = stackBaseIndex;
                    if (extendedEndIndex === objects.length - 1) {
                        break;
                    }
                }
            }
        }
        // Reverse pass for stack calculation.
        let extendedStartIndex = startIndex;
        for (let i = extendedEndIndex; i > startIndex; --i) {
            let n = i;
            // We should check every note which has not yet got a stack.
            // Consider the case we have two inter-wound stacks and this will make sense.
            //
            // o <-1      o <-2
            //  o <-3      o <-4
            //
            // We first process starting from 4 and handle 2,
            // then we come backwards on the i loop iteration until we reach 3 and handle 1.
            // 2 and 1 will be ignored in the i loop because they already have a stack value.
            let objectI = objects[i];
            if (objectI.stackHeight !== 0 || objectI instanceof Spinner) {
                continue;
            }
            const stackThreshold = objectI.timePreempt * this.beatmap.general.stackLeniency;
            // If this object is a hit circle, then we enter this "special" case.
            // It either ends with a stack of hit circles only, or a stack of hit circles that are underneath a slider.
            // Any other case is handled by the "instanceof Slider" code below this.
            if (objectI instanceof Circle) {
                while (--n >= 0) {
                    const objectN = objects[n];
                    if (objectN instanceof Spinner) {
                        continue;
                    }
                    if (objectI.startTime - objectN.endTime > stackThreshold) {
                        // We are no longer within stacking range of the previous object.
                        break;
                    }
                    // Hit objects before the specified update range haven't been reset yet
                    if (n < extendedStartIndex) {
                        objectN.stackHeight = 0;
                        extendedStartIndex = n;
                    }
                    // This is a special case where hit circles are moved DOWN and RIGHT (negative stacking) if they are under the *last* slider in a stacked pattern.
                    // o==o <- slider is at original location
                    //     o <- hitCircle has stack of -1
                    //      o <- hitCircle has stack of -2
                    if (objectN instanceof Slider &&
                        objectN.endPosition.getDistance(objectI.position) <
                            BeatmapProcessor.stackDistance) {
                        const offset = objectI.stackHeight - objectN.stackHeight + 1;
                        for (let j = n + 1; j <= i; ++j) {
                            // For each object which was declared under this slider, we will offset it to appear *below* the slider end (rather than above).
                            const objectJ = objects[j];
                            if (objectN.endPosition.getDistance(objectJ.position) < BeatmapProcessor.stackDistance) {
                                objectJ.stackHeight -= offset;
                            }
                        }
                        // We have hit a slider. We should restart calculation using this as the new base.
                        // Breaking here will mean that the slider still has a stack count of 0, so will be handled in the i-outer-loop.
                        break;
                    }
                    if (objectN.position.getDistance(objectI.position) <
                        BeatmapProcessor.stackDistance) {
                        // Keep processing as if there are no sliders. If we come across a slider, this gets cancelled out.
                        // NOTE: Sliders with start positions stacking are a special case that is also handled here.
                        objectN.stackHeight = objectI.stackHeight + 1;
                        objectI = objectN;
                    }
                }
            }
            else if (objectI instanceof Slider) {
                // We have hit the first slider in a possible stack.
                // From this point on, we ALWAYS stack positive regardless.
                while (--n >= startIndex) {
                    const objectN = objects[n];
                    if (objectN instanceof Spinner) {
                        continue;
                    }
                    if (objectI.startTime - objectN.startTime >
                        stackThreshold) {
                        // We are no longer within stacking range of the previous object.
                        break;
                    }
                    if (objectN.endPosition.getDistance(objectI.position) <
                        BeatmapProcessor.stackDistance) {
                        objectN.stackHeight = objectI.stackHeight + 1;
                        objectI = objectN;
                    }
                }
            }
        }
    }
    applyOldStacking() {
        const objects = this.beatmap.hitObjects.objects;
        for (let i = 0; i < objects.length; ++i) {
            const currentObject = objects[i];
            if (currentObject.stackHeight !== 0 &&
                !(currentObject instanceof Slider)) {
                continue;
            }
            let startTime = currentObject.endTime;
            let sliderStack = 0;
            const stackThreshold = currentObject.timePreempt * this.beatmap.general.stackLeniency;
            for (let j = i + 1; j < objects.length; ++j) {
                if (objects[j].startTime - stackThreshold > startTime) {
                    break;
                }
                // Note the use of `startTime` in the code below doesn't match osu!stable's use of `endTime`.
                // This is because in osu!stable's implementation, `UpdateCalculations` is not called on the inner-loop hitobject (j)
                // and therefore it does not have a correct `endTime`, but instead the default of `endTime = startTime`.
                //
                // Effects of this can be seen on https://osu.ppy.sh/beatmapsets/243#osu/1146 at sliders around 86647 ms, where
                // if we use `endTime` here it would result in unexpected stacking.
                //
                // Reference: https://github.com/ppy/osu/pull/24188
                if (objects[j].position.getDistance(currentObject.position) <
                    BeatmapProcessor.stackDistance) {
                    ++currentObject.stackHeight;
                    startTime = objects[j].startTime;
                }
                else if (objects[j].position.getDistance(currentObject.endPosition) <
                    BeatmapProcessor.stackDistance) {
                    // Case for sliders - bump notes down and right, rather than up and left.
                    ++sliderStack;
                    objects[j].stackHeight -= sliderStack;
                    startTime = objects[j].startTime;
                }
            }
        }
    }
}
BeatmapProcessor.stackDistance = 3;

/**
 * Represents a beatmap that is in a playable state for a specific game mode.
 */
class PlayableBeatmap {
    /**
     * The `HitWindow` of this `PlayableBeatmap`.
     */
    get hitWindow() {
        if (this._hitWindow === null) {
            return this.createHitWindow();
        }
        return this._hitWindow;
    }
    /**
     * @param baseBeatmap The base `IBeatmap` that was used to create this `PlayableBeatmap`.
     * @param mods The `Mod`s that were applied to this `PlayableBeatmap`.
     */
    constructor(baseBeatmap, mods) {
        this._hitWindow = null;
        this.formatVersion = baseBeatmap.formatVersion;
        this.general = baseBeatmap.general;
        this.editor = baseBeatmap.editor;
        this.metadata = baseBeatmap.metadata;
        this.difficulty = baseBeatmap.difficulty;
        this.events = baseBeatmap.events;
        this.controlPoints = baseBeatmap.controlPoints;
        this.colors = baseBeatmap.colors;
        this.hitObjects = baseBeatmap.hitObjects;
        this.maxCombo = baseBeatmap.maxCombo;
        this.mods = mods;
        this.speedMultiplier = ModUtil.calculateRateWithMods(this.mods.values(), Number.POSITIVE_INFINITY);
    }
}

/**
 * Representsa a `PlayableBeatmap` for osu!droid.
 */
class DroidPlayableBeatmap extends PlayableBeatmap {
    createHitWindow() {
        if (this.mods.has(ModPrecise)) {
            return new PreciseDroidHitWindow(this.difficulty.od);
        }
        else {
            return new DroidHitWindow(this.difficulty.od);
        }
    }
}

/**
 * Represents a `PlayableBeatmap` for osu!standard.
 */
class OsuPlayableBeatmap extends PlayableBeatmap {
    createHitWindow() {
        return new OsuHitWindow(this.difficulty.od);
    }
}

/**
 * Contains information about combo and skin colors of a beatmap.
 */
class BeatmapColor {
    constructor() {
        /**
         * The combo colors of the beatmap.
         */
        this.combo = [];
    }
}

/**
 * Represents a control point in a beatmap.
 */
class ControlPoint {
    constructor(values) {
        this.time = values.time;
    }
}

/**
 * Represents a control point that changes the beatmap's BPM.
 */
class TimingControlPoint extends ControlPoint {
    constructor(values) {
        super(values);
        this.msPerBeat = values.msPerBeat;
        this.timeSignature = values.timeSignature;
    }
    isRedundant() {
        // Timing points are never redundant as they can change the time signature.
        return false;
    }
    toString() {
        return ("{ time: " +
            this.time +
            ", " +
            "ms_per_beat: " +
            this.msPerBeat.toFixed(2) +
            ", " +
            "timeSignature: " +
            this.timeSignature +
            " }");
    }
}

/**
 * A manager for a control point.
 */
class ControlPointManager {
    constructor() {
        this._points = [];
    }
    /**
     * The control points in this manager.
     */
    get points() {
        return this._points;
    }
    /**
     * Adds a new control point.
     *
     * Note that the provided control point may not be added if the correct state is already present at the control point's time.
     *
     * Additionally, any control point that exists in the same time will be removed.
     *
     * @param controlPoint The control point to add.
     * @returns Whether the control point was added.
     */
    add(controlPoint) {
        let existing = this.controlPointAt(controlPoint.time);
        // Timing points are a special case and need to be added regardless of fallback availability.
        if (!(existing instanceof TimingControlPoint) &&
            controlPoint.isRedundant(existing)) {
            return false;
        }
        // Remove the existing control point if the new control point overrides it at the same time.
        while (controlPoint.time === existing.time) {
            if (!this.remove(existing)) {
                break;
            }
            existing = this.controlPointAt(controlPoint.time);
        }
        this._points.splice(this.findInsertionIndex(controlPoint.time), 0, controlPoint);
        return true;
    }
    /**
     * Removes a control point.
     *
     * This method will remove the earliest control point in the array that is equal to the given control point.
     *
     * @param controlPoint The control point to remove.
     * @returns Whether the control point was removed.
     */
    remove(controlPoint) {
        for (let i = 0; i < this._points.length; ++i) {
            if (this._points[i].time > controlPoint.time) {
                break;
            }
            // isRedundant doesn't check for time equality, so we need to specify it separately.
            if (this._points[i].time === controlPoint.time &&
                this._points[i].isRedundant(controlPoint)) {
                this._points.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * Removes a control point at an index.
     *
     * @param index The index of the control point to remove.
     * @returns The control point that was removed.
     */
    removeAt(index) {
        return this._points.splice(index, 1)[0];
    }
    /**
     * Clears all control points of this type.
     */
    clear() {
        this._points.length = 0;
    }
    /**
     * Gets all control points between two times.
     *
     * @param start The start time, in milliseconds.
     * @param end The end time, in milliseconds.
     * @return An array of control points between the two times. If `start` is greater than `end`, the control point at
     * `start` will be returned.
     */
    between(startTime, endTime) {
        if (this._points.length === 0) {
            return [this.defaultControlPoint];
        }
        if (startTime > endTime) {
            return [this.controlPointAt(startTime)];
        }
        // Subtract 1 from start index as the binary search from findInsertionIndex would return the next control point
        const startIndex = Math.max(0, this.findInsertionIndex(startTime) - 1);
        // End index does not matter as slice range is exclusive
        const endIndex = MathUtils.clamp(this.findInsertionIndex(endTime), startIndex + 1, this._points.length);
        return this._points.slice(startIndex, endIndex);
    }
    /**
     * Binary searches one of the control point lists to find the active control point at the given time.
     *
     * Includes logic for returning the default control point when no matching point is found.
     *
     * @param time The time to find the control point at.
     * @param fallback The control point to use when the given time is before any control points. Defaults to the default control point.
     * @returns The active control point at the given time, or the default control point if none found.
     */
    binarySearchWithFallback(time, fallback = this.defaultControlPoint) {
        var _a;
        return (_a = this.binarySearch(time)) !== null && _a !== void 0 ? _a : fallback;
    }
    /**
     * Binary searches one of the control point lists to find the active control point at the given time.
     *
     * @param time The time to find the control point at.
     * @returns The active control point at the given time, `null` if none found.
     */
    binarySearch(time) {
        if (this._points.length === 0 || time < this._points[0].time) {
            return null;
        }
        if (time >= this._points.at(-1).time) {
            return this._points.at(-1);
        }
        let l = 0;
        let r = this._points.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            if (this._points[pivot].time < time) {
                l = pivot + 1;
            }
            else if (this._points[pivot].time > time) {
                r = pivot - 1;
            }
            else {
                return this._points[pivot];
            }
        }
        // l will be the first control point with time > this._points[l].time, but we want the one before it
        return this._points[l - 1];
    }
    [Symbol.iterator]() {
        return this._points[Symbol.iterator]();
    }
    /**
     * Finds the insertion index of a control point in a given time.
     *
     * @param time The start time of the control point.
     */
    findInsertionIndex(time) {
        if (this._points.length === 0 || time < this._points[0].time) {
            return 0;
        }
        if (time >= this._points.at(-1).time) {
            return this._points.length;
        }
        let l = 0;
        let r = this._points.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            if (this._points[pivot].time < time) {
                l = pivot + 1;
            }
            else if (this._points[pivot].time > time) {
                r = pivot - 1;
            }
            else {
                return pivot;
            }
        }
        return l;
    }
}

/**
 * A manager for timing control points.
 */
class TimingControlPointManager extends ControlPointManager {
    constructor() {
        super(...arguments);
        this.defaultControlPoint = new TimingControlPoint({
            time: 0,
            msPerBeat: 1000,
            timeSignature: 4,
        });
    }
    controlPointAt(time) {
        var _a;
        return this.binarySearchWithFallback(time, (_a = this.points[0]) !== null && _a !== void 0 ? _a : this.defaultControlPoint);
    }
}

/**
 * Represents a control point that changes speed multiplier.
 */
class DifficultyControlPoint extends ControlPoint {
    constructor(values) {
        super(values);
        this.speedMultiplier = values.speedMultiplier;
        this.generateTicks = values.generateTicks;
    }
    isRedundant(existing) {
        return (this.speedMultiplier === existing.speedMultiplier &&
            this.generateTicks === existing.generateTicks);
    }
    toString() {
        return ("{ time: " +
            this.time +
            ", " +
            "speed multiplier: " +
            this.speedMultiplier.toFixed(2) +
            ", generate ticks: " +
            this.generateTicks +
            " }");
    }
}

/**
 * A manager for difficulty control points.
 */
class DifficultyControlPointManager extends ControlPointManager {
    constructor() {
        super(...arguments);
        this.defaultControlPoint = new DifficultyControlPoint({
            time: 0,
            speedMultiplier: 1,
            generateTicks: true,
        });
    }
    controlPointAt(time) {
        return this.binarySearchWithFallback(time);
    }
}

/**
 * Represents a control point that applies an effect to a beatmap.
 */
class EffectControlPoint extends ControlPoint {
    constructor(values) {
        super(values);
        this.isKiai = values.isKiai;
        this.omitFirstBarLine = values.omitFirstBarLine;
    }
    isRedundant(existing) {
        return this.isKiai === existing.isKiai;
    }
    toString() {
        return "{ time: " + this.time + ", " + "kiai: " + this.isKiai + " }";
    }
}

/**
 * A manager for effect control points.
 */
class EffectControlPointManager extends ControlPointManager {
    constructor() {
        super(...arguments);
        this.defaultControlPoint = new EffectControlPoint({
            time: 0,
            isKiai: false,
            omitFirstBarLine: false,
        });
    }
    controlPointAt(time) {
        return this.binarySearchWithFallback(time);
    }
}

/**
 * Represents a control point that handles sample sounds.
 */
class SampleControlPoint extends ControlPoint {
    constructor(values) {
        super(values);
        this.sampleBank = values.sampleBank;
        this.sampleVolume = values.sampleVolume;
        this.customSampleBank = values.customSampleBank;
    }
    /**
     * Apples this control point's sample bank and volume to a `HitSampleInfo` if necessary, returning
     * the modified `HitSampleInfo`.
     *
     * @param hitSampleInfo The `HitSampleInfo`. This will not be modified.
     * @returns The modified `HitSampleInfo`. This does not share any references with the given `HitSampleInfo`.
     */
    applyTo(hitSampleInfo) {
        const volume = hitSampleInfo.volume > 0 ? hitSampleInfo.volume : this.sampleVolume;
        if (hitSampleInfo instanceof BankHitSampleInfo) {
            return new BankHitSampleInfo(hitSampleInfo.name, hitSampleInfo.bank !== exports.SampleBank.none
                ? hitSampleInfo.bank
                : this.sampleBank, hitSampleInfo.customSampleBank > 0
                ? hitSampleInfo.customSampleBank
                : this.customSampleBank, volume, hitSampleInfo.isLayered);
        }
        else if (hitSampleInfo instanceof FileHitSampleInfo) {
            return new FileHitSampleInfo(hitSampleInfo.filename, volume);
        }
        else {
            throw new TypeError("Unknown type of hit sample info.");
        }
    }
    isRedundant(existing) {
        return (this.sampleBank === existing.sampleBank &&
            this.sampleVolume === existing.sampleVolume &&
            this.customSampleBank === existing.customSampleBank);
    }
    toString() {
        return ("{ time: " +
            this.time +
            ", " +
            "sample bank: " +
            this.sampleBank +
            ", " +
            "sample volume: " +
            this.sampleVolume +
            " }");
    }
}

/**
 * A manager for sample control points.
 */
class SampleControlPointManager extends ControlPointManager {
    constructor() {
        super(...arguments);
        this.defaultControlPoint = new SampleControlPoint({
            time: 0,
            sampleBank: exports.SampleBank.normal,
            sampleVolume: 100,
            customSampleBank: 0,
        });
    }
    controlPointAt(time) {
        return this.binarySearchWithFallback(time);
    }
}

/**
 * Contains information about timing (control) points of a beatmap.
 */
class BeatmapControlPoints {
    constructor() {
        /**
         * The manager for timing control points of the beatmap.
         */
        this.timing = new TimingControlPointManager();
        /**
         * The manager for difficulty control points of the beatmap.
         */
        this.difficulty = new DifficultyControlPointManager();
        /**
         * The manager for effect control points of the beatmap.
         */
        this.effect = new EffectControlPointManager();
        /**
         * The manager for sample control points of the beatmap.
         */
        this.sample = new SampleControlPointManager();
    }
    /**
     * Clears all control points in the beatmap.
     */
    clear() {
        this.timing.clear();
        this.difficulty.clear();
        this.effect.clear();
        this.sample.clear();
    }
}

/**
 * Represents the grid size setting in the editor.
 */
exports.EditorGridSize = void 0;
(function (EditorGridSize) {
    EditorGridSize[EditorGridSize["tiny"] = 4] = "tiny";
    EditorGridSize[EditorGridSize["small"] = 8] = "small";
    EditorGridSize[EditorGridSize["medium"] = 16] = "medium";
    EditorGridSize[EditorGridSize["large"] = 32] = "large";
})(exports.EditorGridSize || (exports.EditorGridSize = {}));

/**
 * Contains saved settings for the beatmap editor.
 */
class BeatmapEditor {
    constructor() {
        /**
         * Time in milliseconds of bookmarks.
         */
        this.bookmarks = [];
        /**
         * The multiplier at which distance between consecutive notes will be snapped based on their rhythmical difference.
         */
        this.distanceSnap = 1;
        /**
         * Determines the editor's behaviour in quantizing hit objects based on the {@link https://osu.ppy.sh/wiki/en/Client/Beatmap_editor/Beat_Snap Beat Snap} principles.
         */
        this.beatDivisor = 4;
        /**
         * The grid size setting in the editor.
         */
        this.gridSize = exports.EditorGridSize.small;
        /**
         * The scale factor for the {@link https://osu.ppy.sh/wiki/en/Client/Beatmap_editor/Compose#top-left-(hit-objects-timeline) object timeline}.
         */
        this.timelineZoom = 1;
    }
}

/**
 * Available types of a storyboard layer.
 */
exports.StoryboardLayerType = void 0;
(function (StoryboardLayerType) {
    StoryboardLayerType["background"] = "Background";
    StoryboardLayerType["fail"] = "Fail";
    StoryboardLayerType["pass"] = "Pass";
    StoryboardLayerType["foreground"] = "Foreground";
    StoryboardLayerType["overlay"] = "Overlay";
    StoryboardLayerType["sample"] = "Sample";
})(exports.StoryboardLayerType || (exports.StoryboardLayerType = {}));

/**
 * Contains beatmap events.
 */
class BeatmapEvents {
    constructor() {
        /**
         * The breaks this beatmap has.
         */
        this.breaks = [];
    }
    /**
     * Whether the beatmap's background should be hidden while its storyboard is being displayed.
     */
    get storyboardReplacesBackground() {
        var _a, _b;
        return ((_b = (_a = this.storyboard) === null || _a === void 0 ? void 0 : _a.getLayer(exports.StoryboardLayerType.background).elements.some((e) => { var _a; return e.path.toLowerCase() === ((_a = this.background) === null || _a === void 0 ? void 0 : _a.filename); })) !== null && _b !== void 0 ? _b : false);
    }
}

/**
 * Represents the speed of the countdown before the first hit object.
 */
exports.BeatmapCountdown = void 0;
(function (BeatmapCountdown) {
    BeatmapCountdown[BeatmapCountdown["noCountDown"] = 0] = "noCountDown";
    BeatmapCountdown[BeatmapCountdown["normal"] = 1] = "normal";
    BeatmapCountdown[BeatmapCountdown["half"] = 2] = "half";
    BeatmapCountdown[BeatmapCountdown["double"] = 3] = "double";
})(exports.BeatmapCountdown || (exports.BeatmapCountdown = {}));

/**
 * Represents the draw order of hit circle overlays compared to hit numbers.
 *
 * - `noChange` = use skin setting
 * - `below` = draw overlays under numbers
 * - `above` = draw overlays on top of numbers
 */
exports.BeatmapOverlayPosition = void 0;
(function (BeatmapOverlayPosition) {
    BeatmapOverlayPosition["noChange"] = "NoChange";
    BeatmapOverlayPosition["below"] = "Below";
    BeatmapOverlayPosition["above"] = "Above";
})(exports.BeatmapOverlayPosition || (exports.BeatmapOverlayPosition = {}));

/**
 * Represents game modes available in the game.
 */
exports.GameMode = void 0;
(function (GameMode) {
    GameMode[GameMode["osu"] = 0] = "osu";
    GameMode[GameMode["taiko"] = 1] = "taiko";
    GameMode[GameMode["catch"] = 2] = "catch";
    GameMode[GameMode["mania"] = 3] = "mania";
})(exports.GameMode || (exports.GameMode = {}));

/**
 * Contains general information about a beatmap.
 */
class BeatmapGeneral {
    constructor() {
        /**
         * The location of the audio file relative to the beatmapset file.
         */
        this.audioFilename = "";
        /**
         * The amount of milliseconds of silence before the audio starts playing.
         */
        this.audioLeadIn = 0;
        /**
         * The time in milliseconds when the audio preview should start.
         *
         * If -1, the audio should begin playing at 40% of its length.
         */
        this.previewTime = -1;
        /**
         * The speed of the countdown before the first hit object.
         */
        this.countdown = exports.BeatmapCountdown.normal;
        /**
         * The sample bank that will be used if timing points do not override it.
         */
        this.sampleBank = exports.SampleBank.normal;
        /**
         * The sample volume that will be used if timing points do not override it.
         */
        this.sampleVolume = 100;
        /**
         * The multiplier for the threshold in time where hit objects
         * placed close together stack, ranging from 0 to 1.
         */
        this.stackLeniency = 0.7;
        /**
         * The game mode of the beatmap.
         */
        this.mode = exports.GameMode.osu;
        /**
         * Whether or not breaks have a letterboxing effect.
         */
        this.letterBoxInBreaks = false;
        /**
         * Whether or not the storyboard can use the user's skin images.
         */
        this.useSkinSprites = false;
        /**
         * The draw order of hit circle overlays compared to hit numbers.
         */
        this.overlayPosition = exports.BeatmapOverlayPosition.noChange;
        /**
         * The preffered skin to use during gameplay.
         */
        this.skinPreference = "";
        /**
         * Whether or not a warning about flashing colours should be shown at the beginning of the map.
         */
        this.epilepsyWarning = false;
        /**
         * The time in beats that the countdown starts before the first hit object.
         */
        this.countdownOffset = 0;
        /**
         * Whether or not the storyboard allows widescreen viewing.
         */
        this.widescreenStoryboard = false;
        /**
         * Whether or not sound samples will change rate when playing with speed-changing mods.
         */
        this.samplesMatchPlaybackRate = true;
    }
}

/**
 * Contains information used to identify a beatmap.
 */
class BeatmapMetadata {
    constructor() {
        /**
         * The romanized song title of the beatmap.
         */
        this.title = "";
        /**
         * The song title of the beatmap.
         */
        this.titleUnicode = "";
        /**
         * The romanized artist of the song of the beatmap.
         */
        this.artist = "";
        /**
         * The song artist of the beatmap.
         */
        this.artistUnicode = "";
        /**
         * The creator of the beatmap.
         */
        this.creator = "";
        /**
         * The difficulty name of the beatmap.
         */
        this.version = "";
        /**
         * The original media the song was produced for.
         */
        this.source = "";
        /**
         * The search terms of the beatmap.
         */
        this.tags = [];
    }
    /**
     * The full title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     */
    get fullTitle() {
        return `${this.artist} - ${this.title} (${this.creator}) [${this.version}]`;
    }
    /**
     * The full unicode title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     *
     * Will fallback to original artist and title if needed.
     */
    get fullUnicodeTitle() {
        return `${this.artistUnicode || this.artist} - ${this.titleUnicode || this.title} (${this.creator}) [${this.version}]`;
    }
}

/**
 * Represents a beatmap with advanced information.
 */
class Beatmap {
    constructor(shallowCopy) {
        /**
         * The game mode this `Beatmap` was parsed as.
         */
        this.mode = exports.Modes.osu;
        if (shallowCopy) {
            this.mode = shallowCopy.mode;
            this.formatVersion = shallowCopy.formatVersion;
            this.general = shallowCopy.general;
            this.editor = shallowCopy.editor;
            this.metadata = shallowCopy.metadata;
            this.difficulty = shallowCopy.difficulty;
            this.events = shallowCopy.events;
            this.controlPoints = shallowCopy.controlPoints;
            this.colors = shallowCopy.colors;
            this.hitObjects = shallowCopy.hitObjects;
            return;
        }
        this.formatVersion = 1;
        this.general = new BeatmapGeneral();
        this.editor = new BeatmapEditor();
        this.metadata = new BeatmapMetadata();
        this.difficulty = new BeatmapDifficulty();
        this.events = new BeatmapEvents();
        this.controlPoints = new BeatmapControlPoints();
        this.colors = new BeatmapColor();
        this.hitObjects = new BeatmapHitObjects();
    }
    /**
     * The maximum combo of the beatmap.
     */
    get maxCombo() {
        return (this.hitObjects.circles +
            this.hitObjects.sliders +
            this.hitObjects.sliderTicks +
            this.hitObjects.sliderRepeatPoints +
            this.hitObjects.sliderEnds +
            this.hitObjects.spinners);
    }
    /**
     * The most common beat length of the beatmap.
     */
    get mostCommonBeatLength() {
        var _a, _b, _c, _d, _e;
        // The last playable time in the beatmap - the last timing point extends to this time.
        // Note: This is more accurate and may present different results because osu-stable didn't have the ability to calculate slider durations in this context.
        const lastTime = (_d = (_b = (_a = this.hitObjects.objects[this.hitObjects.objects.length - 1]) === null || _a === void 0 ? void 0 : _a.endTime) !== null && _b !== void 0 ? _b : (_c = this.controlPoints.timing.points[this.controlPoints.timing.points.length - 1]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : 0;
        const mostCommon = 
        // Construct a set of {beatLength, duration} objects for each individual timing point.
        this.controlPoints.timing.points
            .map((t, i, a) => {
            if (t.time > lastTime) {
                return { beatLength: t.msPerBeat, duration: 0 };
            }
            // osu-stable forced the first control point to start at 0.
            const currentTime = i === 0 ? 0 : t.time;
            const nextTime = i === a.length - 1 ? lastTime : a[i + 1].time;
            return {
                beatLength: t.msPerBeat,
                duration: nextTime - currentTime,
            };
        })
            // Get the most common one, or 0 as a suitable default.
            .sort((a, b) => b.duration - a.duration)[0];
        return (_e = mostCommon === null || mostCommon === void 0 ? void 0 : mostCommon.beatLength) !== null && _e !== void 0 ? _e : 0;
    }
    /**
     * Returns a time combined with beatmap-wide time offset.
     *
     * BeatmapVersion 4 and lower had an incorrect offset. Stable has this set as 24ms off.
     *
     * @param time The time.
     */
    getOffsetTime(time) {
        return time + (this.formatVersion < 5 ? 24 : 0);
    }
    /**
     * Calculates the osu!droid maximum score of the beatmap without taking spinner bonus into account.
     *
     * @param mods The modifications to calculate for. Defaults to No Mod.
     */
    maxDroidScore(mods) {
        let scoreMultiplier = 1;
        if (mods) {
            for (const mod of mods.values()) {
                if (mod.isApplicableToDroid()) {
                    scoreMultiplier *= mod.calculateDroidScoreMultiplier(this.difficulty);
                }
            }
            if (mods.has(ModScoreV2)) {
                return 1e6 * scoreMultiplier;
            }
        }
        const difficultyMultiplier = 1 +
            this.difficulty.od / 10 +
            this.difficulty.hp / 10 +
            (this.difficulty.cs - 3) / 4;
        let combo = 0;
        let score = 0;
        for (const object of this.hitObjects.objects) {
            if (!(object instanceof Slider)) {
                score += Math.floor(300 + (300 * combo * difficultyMultiplier) / 25);
                ++combo;
                continue;
            }
            const { ticks } = object;
            // Apply slider head.
            score += 30;
            ++combo;
            // Apply slider repeats.
            score += 30 * object.repeatCount;
            combo += object.repeatCount;
            // Apply slider ticks.
            score += 10 * ticks;
            combo += ticks;
            // Apply slider end.
            score += Math.floor(300 + (300 * combo * difficultyMultiplier) / 25);
            ++combo;
        }
        return Math.floor(score * scoreMultiplier);
    }
    /**
     * Calculates the osu!standard maximum score of the beatmap without taking spinner bonus into account.
     *
     * @param mods The modifications to calculate for. Defaults to No Mod.
     */
    maxOsuScore(mods) {
        const accumulatedDiffPoints = this.difficulty.cs + this.difficulty.hp + this.difficulty.od;
        let difficultyMultiplier = 2;
        let scoreMultiplier = 1;
        if (mods) {
            for (const mod of mods.values()) {
                if (mod.isApplicableToOsu()) {
                    scoreMultiplier *= mod.osuScoreMultiplier;
                }
            }
            if (mods.has(ModScoreV2)) {
                return 1e6 * scoreMultiplier;
            }
        }
        switch (true) {
            case accumulatedDiffPoints <= 5:
                difficultyMultiplier = 2;
                break;
            case accumulatedDiffPoints <= 12:
                difficultyMultiplier = 3;
                break;
            case accumulatedDiffPoints <= 17:
                difficultyMultiplier = 4;
                break;
            case accumulatedDiffPoints <= 24:
                difficultyMultiplier = 5;
                break;
            case accumulatedDiffPoints >= 25:
                difficultyMultiplier = 6;
                break;
        }
        let combo = 0;
        let score = 0;
        for (const object of this.hitObjects.objects) {
            if (!(object instanceof Slider)) {
                score += Math.floor(300 +
                    (300 * combo * difficultyMultiplier * scoreMultiplier) /
                        25);
                ++combo;
                continue;
            }
            const { ticks } = object;
            // Apply slider head.
            score += 30;
            ++combo;
            // Apply slider repeats.
            score += 30 * object.repeatCount;
            combo += object.repeatCount;
            // Apply slider ticks.
            score += 10 * ticks;
            combo += ticks;
            // Apply slider end.
            score += Math.floor(300 +
                (300 * combo * difficultyMultiplier * scoreMultiplier) / 25);
            ++combo;
        }
        return score;
    }
    /**
     * Constructs a `DroidPlayableBeatmap` from this `Beatmap`.
     *
     * The returned `DroidPlayableBeatmap` is in a playable state - all `HitObject` and `BeatmapDifficulty`
     * `Mod`s have been applied, and `HitObject`s have been fully constructed.
     *
     * @param mods The `Mod`s to apply to the `Beatmap`. Defaults to No Mod.
     * @return The constructed `DroidPlayableBeatmap`.
     */
    createDroidPlayableBeatmap(mods = new ModMap()) {
        return new DroidPlayableBeatmap(this.createPlayableBeatmap(mods, exports.Modes.droid), mods);
    }
    /**
     * Constructs a `OsuPlayableBeatmap` from this `Beatmap`.
     *
     * The returned `OsuPlayableBeatmap` is in a playable state - all `HitObject` and `BeatmapDifficulty`
     * `Mod`s have been applied, and `HitObject`s have been fully constructed.
     *
     * @param mods The `Mod`s to apply to the `Beatmap`. Defaults to No Mod.
     * @return The constructed `OsuPlayableBeatmap`.
     */
    createOsuPlayableBeatmap(mods = new ModMap()) {
        return new OsuPlayableBeatmap(this.createPlayableBeatmap(mods, exports.Modes.osu), mods);
    }
    createPlayableBeatmap(mods, mode) {
        if (this.mode === mode && mods.size === 0) {
            // Beatmap is already in a playable state.
            return this;
        }
        // Convert
        const converted = new BeatmapConverter(this).convert();
        const adjustmentMods = new ModMap();
        for (const mod of mods.values()) {
            if (mod.facilitatesAdjustment()) {
                adjustmentMods.set(mod);
            }
        }
        // Apply difficulty mods
        mods.forEach((mod) => {
            if (mod.isApplicableToDifficulty()) {
                mod.applyToDifficulty(mode, converted.difficulty, adjustmentMods);
            }
        });
        mods.forEach((mod) => {
            if (mod.isApplicableToDifficultyWithMods()) {
                mod.applyToDifficultyWithMods(mode, converted.difficulty, mods);
            }
        });
        const processor = new BeatmapProcessor(converted);
        processor.preProcess();
        // Compute default values for hit objects, including creating nested hit objects in-case they're needed.
        converted.hitObjects.objects.forEach((hitObject) => hitObject.applyDefaults(converted.controlPoints, converted.difficulty, mode));
        mods.forEach((mod) => {
            if (mod.isApplicableToHitObject()) {
                for (const hitObject of converted.hitObjects.objects) {
                    mod.applyToHitObject(mode, hitObject, adjustmentMods);
                }
            }
        });
        mods.forEach((mod) => {
            if (mod.isApplicableToHitObjectWithMods()) {
                for (const hitObject of converted.hitObjects.objects) {
                    mod.applyToHitObjectWithMods(mode, hitObject, mods);
                }
            }
        });
        processor.postProcess();
        mods.forEach((mod) => {
            if (mod.isApplicableToBeatmap()) {
                mod.applyToBeatmap(converted);
            }
        });
        return converted;
    }
    /**
     * Returns a string representative of the class.
     */
    toString() {
        let res = this.metadata.artist + " - " + this.metadata.title + " [";
        if (this.metadata.titleUnicode || this.metadata.artistUnicode) {
            res +=
                "(" +
                    this.metadata.artistUnicode +
                    " - " +
                    this.metadata.titleUnicode +
                    ")";
        }
        res +=
            this.metadata.version +
                "] mapped by " +
                this.metadata.creator +
                "\n" +
                "\n" +
                "AR" +
                MathUtils.round(this.difficulty.ar, 2) +
                " " +
                "OD" +
                MathUtils.round(this.difficulty.od, 2) +
                " " +
                "CS" +
                MathUtils.round(this.difficulty.cs, 2) +
                " " +
                "HP" +
                MathUtils.round(this.difficulty.hp, 2) +
                "\n" +
                this.hitObjects.circles +
                " circles, " +
                this.hitObjects.sliders +
                " sliders, " +
                this.hitObjects.spinners +
                " spinners" +
                "\n" +
                this.maxCombo +
                " max combo";
        return res;
    }
}

/**
 * Represents a beatmap's background.
 */
class BeatmapBackground {
    constructor(filename, offset) {
        this.filename = filename;
        this.offset = offset;
    }
}

/**
 * Represents available hitsound types.
 */
exports.HitSoundType = void 0;
(function (HitSoundType) {
    HitSoundType[HitSoundType["none"] = 0] = "none";
    HitSoundType[HitSoundType["normal"] = 1] = "normal";
    HitSoundType[HitSoundType["whistle"] = 2] = "whistle";
    HitSoundType[HitSoundType["finish"] = 4] = "finish";
    HitSoundType[HitSoundType["clap"] = 8] = "clap";
})(exports.HitSoundType || (exports.HitSoundType = {}));

/**
 * Constants for beatmap parser.
 */
var ParserConstants;
(function (ParserConstants) {
    ParserConstants[ParserConstants["MAX_PARSE_VALUE"] = 2147483647] = "MAX_PARSE_VALUE";
    ParserConstants[ParserConstants["MAX_COORDINATE_VALUE"] = 131072] = "MAX_COORDINATE_VALUE";
    ParserConstants[ParserConstants["MIN_REPETITIONS_VALUE"] = 0] = "MIN_REPETITIONS_VALUE";
    ParserConstants[ParserConstants["MAX_REPETITIONS_VALUE"] = 9000] = "MAX_REPETITIONS_VALUE";
    ParserConstants[ParserConstants["MIN_DISTANCE_VALUE"] = 0] = "MIN_DISTANCE_VALUE";
    ParserConstants[ParserConstants["MAX_DISTANCE_VALUE"] = 131072] = "MAX_DISTANCE_VALUE";
    ParserConstants[ParserConstants["MIN_SPEEDMULTIPLIER_VALUE"] = 0.1] = "MIN_SPEEDMULTIPLIER_VALUE";
    ParserConstants[ParserConstants["MAX_SPEEDMULTIPLIER_VALUE"] = 10] = "MAX_SPEEDMULTIPLIER_VALUE";
    ParserConstants[ParserConstants["MIN_MSPERBEAT_VALUE"] = 6] = "MIN_MSPERBEAT_VALUE";
    ParserConstants[ParserConstants["MAX_MSPERBEAT_VALUE"] = 60000] = "MAX_MSPERBEAT_VALUE";
})(ParserConstants || (ParserConstants = {}));

/**
 * Represents an information about a hitobject-specific sample bank.
 */
class SampleBankInfo {
    constructor(bankInfo) {
        var _a, _b, _c, _d, _e;
        this.filename = (_a = bankInfo === null || bankInfo === void 0 ? void 0 : bankInfo.filename) !== null && _a !== void 0 ? _a : "";
        this.normal = (_b = bankInfo === null || bankInfo === void 0 ? void 0 : bankInfo.normal) !== null && _b !== void 0 ? _b : exports.SampleBank.none;
        this.add = (_c = bankInfo === null || bankInfo === void 0 ? void 0 : bankInfo.add) !== null && _c !== void 0 ? _c : exports.SampleBank.none;
        this.volume = (_d = bankInfo === null || bankInfo === void 0 ? void 0 : bankInfo.volume) !== null && _d !== void 0 ? _d : 0;
        this.customSampleBank = (_e = bankInfo === null || bankInfo === void 0 ? void 0 : bankInfo.customSampleBank) !== null && _e !== void 0 ? _e : 0;
    }
}

/**
 * Sections that exist in `.osu` and `.osb` files.
 */
var BeatmapSection;
(function (BeatmapSection) {
    BeatmapSection["general"] = "General";
    BeatmapSection["editor"] = "Editor";
    BeatmapSection["metadata"] = "Metadata";
    BeatmapSection["difficulty"] = "Difficulty";
    BeatmapSection["events"] = "Events";
    BeatmapSection["variables"] = "Variables";
    BeatmapSection["timingPoints"] = "TimingPoints";
    BeatmapSection["colors"] = "Colours";
    BeatmapSection["hitObjects"] = "HitObjects";
})(BeatmapSection || (BeatmapSection = {}));

/**
 * The base of main decoders.
 */
class Decoder {
    constructor() {
        /**
         * The format version of the decoded target.
         */
        this.formatVersion = Decoder.latestVersion;
        /**
         * The amount of lines of the file that have been processed up to this point.
         */
        this.line = 0;
        /**
         * The currently processed line.
         */
        this.currentLine = "";
        /**
         * The currently processed section.
         */
        this.section = BeatmapSection.general;
    }
    /**
     * The result of the decoding process.
     */
    get result() {
        return this.finalResult;
    }
    /**
     * Performs the decoding process.
     *
     * @param str The string to decode.
     * @returns The current decoder instance.
     */
    decode(str) {
        var _a;
        this.reset();
        for (let line of str.split("\n")) {
            this.currentLine = line;
            ++this.line;
            if (this.shouldSkipLine(line)) {
                continue;
            }
            if (this.section !== BeatmapSection.metadata) {
                // Comments should not be stripped from metadata lines, as the song metadata may contain "//" as valid data.
                const index = line.indexOf("//");
                if (index > 0) {
                    line = line.substring(0, index);
                }
            }
            // Now that we've handled comments, we can trim space
            line = this.currentLine = line.trimEnd();
            // [SectionName]
            if (line.startsWith("[") && line.endsWith("]")) {
                const section = line.substring(1, line.length - 1);
                if (!Object.values(BeatmapSection).includes(section)) {
                    console.warn(`Unknown section "${line}" at line ${this.line}`);
                    continue;
                }
                this.section = section;
                continue;
            }
            if (!line) {
                continue;
            }
            const fmtpos = line.indexOf("file format v");
            if (fmtpos >= 0) {
                this.formatVersion = parseInt(line.substring(fmtpos + 13));
                continue;
            }
            try {
                this.decodeLine(line);
            }
            catch (e) {
                console.error(e);
                console.error(`at line ${this.line}\n${(_a = this.decoders[this.section]) === null || _a === void 0 ? void 0 : _a.logExceptionPosition()}`);
            }
        }
        return this;
    }
    /**
     * Determines whether a line should be skipped.
     *
     * @param line The line to determine.
     * @returns Whether the line should be skipped.
     */
    shouldSkipLine(line) {
        return !line || line.trimStart().startsWith("//");
    }
    /**
     * Internal decoder function for decoding a line.
     *
     * @param line The line to decode.
     */
    decodeLine(line) {
        var _a;
        (_a = this.decoders[this.section]) === null || _a === void 0 ? void 0 : _a.decode(line);
    }
    /**
     * Resets this decoder's instance.
     */
    reset() {
        this.line = 0;
        this.currentLine = "";
        this.section = BeatmapSection.general;
    }
}
Decoder.latestVersion = 14;

/**
 * The base of all decoders.
 */
class SectionDecoder {
    constructor(target, formatVersion = Decoder.latestVersion) {
        /**
         * The string in the line at which the decoder is processing.
         */
        this.lastPosition = "";
        this.target = target;
        this.formatVersion = formatVersion;
    }
    /**
     * Performs a decoding process.
     *
     * @param line The line to decode.
     * @returns The result.
     */
    decode(line) {
        this.decodeInternal(line);
        return this.target;
    }
    /**
     * Logs the position at the line at which an exception occurs.
     */
    logExceptionPosition() {
        return "-> " + this.lastPosition + " <-";
    }
    /**
     * Processes a property of the beatmap. This takes the current line as parameter.
     *
     * For example, `ApproachRate:9` will be split into `[ApproachRate, 9]`.
     */
    property(line) {
        const s = line.split(":");
        s[0] = this.setPosition(s[0]).trim();
        s[1] = this.setPosition(s.slice(1).join(":")).trim();
        return s;
    }
    /**
     * Sets the last position of the current decoder state.
     *
     * This is useful to debug syntax errors.
     */
    setPosition(str) {
        this.lastPosition = str.trim();
        return this.lastPosition;
    }
    /**
     * Attempts to parse a string into an integer.
     *
     * Throws an exception when the resulting value is invalid (such as NaN), too low, or too high.
     *
     * @param str The string to parse.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     * @param allowNaN Whether to allow NaN.
     * @returns The parsed integer.
     */
    tryParseInt(str, min = -ParserConstants.MAX_PARSE_VALUE, max = ParserConstants.MAX_PARSE_VALUE, allowNaN = false) {
        const num = parseInt(str);
        if (num < min) {
            throw new RangeError("Value is too low");
        }
        if (num > max) {
            throw new RangeError("Value is too high");
        }
        if (!allowNaN && Number.isNaN(num)) {
            throw new RangeError("Not a number");
        }
        return num;
    }
    /**
     * Attempts to parse a string into a float.
     *
     * Throws an exception when the resulting value is too low or too high.
     *
     * @param str The string to parse.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     * @param allowNaN Whether to allow NaN.
     * @returns The parsed float.
     */
    tryParseFloat(str, min = -ParserConstants.MAX_PARSE_VALUE, max = ParserConstants.MAX_PARSE_VALUE, allowNaN = false) {
        const num = parseFloat(str);
        if (num < min) {
            throw new RangeError("Value is too low");
        }
        if (num > max) {
            throw new RangeError("Value is too high");
        }
        if (!allowNaN && Number.isNaN(num)) {
            throw new RangeError("Not a number");
        }
        return num;
    }
    /**
     * Checks if a number is within a given threshold.
     *
     * @param num The number to check.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     */
    isNumberValid(num, min = -ParserConstants.MAX_PARSE_VALUE, max = ParserConstants.MAX_PARSE_VALUE) {
        return num >= min && num <= max;
    }
}
/**
 * The first version of beatmaps exported from osu!lazer.
 */
SectionDecoder.firstLazerVersion = 128;

/**
 * A decoder for decoding a beatmap's hitobjects section.
 */
class BeatmapHitObjectsDecoder extends SectionDecoder {
    constructor() {
        super(...arguments);
        this.extraComboOffset = 0;
        this.forceNewCombo = false;
    }
    decodeInternal(line) {
        const s = line.split(",");
        if (s.length < 4) {
            throw new Error("Ignoring malformed hitobject");
        }
        const time = this.target.getOffsetTime(this.tryParseFloat(this.setPosition(s[2])));
        const type = this.tryParseInt(this.setPosition(s[3]));
        let tempType = type;
        let comboOffset = (tempType & exports.ObjectTypes.comboOffset) >> 4;
        tempType &= ~exports.ObjectTypes.comboOffset;
        let newCombo = !!(type & exports.ObjectTypes.newCombo);
        tempType &= ~exports.ObjectTypes.newCombo;
        const position = new Vector2(this.tryParseFloat(this.setPosition(s[0]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE), this.tryParseFloat(this.setPosition(s[1]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE));
        const soundType = this.tryParseInt(s[4]);
        const bankInfo = new SampleBankInfo();
        let object = null;
        if (type & exports.ObjectTypes.circle) {
            newCombo || (newCombo = this.forceNewCombo);
            comboOffset += this.extraComboOffset;
            this.forceNewCombo = false;
            this.extraComboOffset = 0;
            object = new Circle({
                startTime: time,
                type: type,
                position: position,
                newCombo: newCombo,
                comboOffset: comboOffset,
            });
            if (s.length > 5) {
                this.readCustomSampleBanks(bankInfo, s[5]);
            }
        }
        else if (type & exports.ObjectTypes.slider) {
            if (s.length < 8) {
                throw new Error("Ignoring malformed slider");
            }
            const repeatCount = Math.max(0, 
            // osu!stable treated the first span of the slider as a repeat, but no repeats are happening
            this.tryParseInt(this.setPosition(s[6]), -ParserConstants.MAX_PARSE_VALUE, ParserConstants.MAX_REPETITIONS_VALUE) - 1);
            const distance = Math.max(0, this.tryParseFloat(this.setPosition(s[7])));
            const difficultyControlPoint = this.target.controlPoints.difficulty.controlPointAt(time);
            const timingControlPoint = this.target.controlPoints.timing.controlPointAt(time);
            const points = [new Vector2(0, 0)];
            const pointSplit = this.setPosition(s[5]).split("|");
            let pathType = pointSplit.shift();
            for (const point of pointSplit) {
                const temp = point.split(":");
                const vec = new Vector2(this.tryParseFloat(temp[0], -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE), this.tryParseFloat(temp[1], -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE));
                points.push(vec.subtract(position));
            }
            // A special case for Catmull sliders where the first control point is in the position of the slider.
            // This results in a duplicate (0, 0) point in the path.
            if (pathType == exports.PathType.Catmull &&
                points.length >= 2 &&
                points[0].equals(points[1])) {
                points.shift();
            }
            // Edge-case rules (to match osu!stable).
            if (pathType === exports.PathType.PerfectCurve) {
                if (this.target.formatVersion <
                    BeatmapHitObjectsDecoder.firstLazerVersion) {
                    if (points.length !== 3) {
                        pathType = exports.PathType.Bezier;
                    }
                    else if (Precision.almostEqualsNumber(0, (points[1].y - points[0].y) *
                        (points[2].x - points[0].x) -
                        (points[1].x - points[0].x) *
                            (points[2].y - points[0].y))) {
                        // osu!stable special-cased colinear perfect curves to a linear path
                        pathType = exports.PathType.Linear;
                    }
                }
                else if (points.length > 3) {
                    // osu!lazer supports perfect curves with less than 3 points and co-linear points
                    pathType = exports.PathType.Bezier;
                }
            }
            const path = new SliderPath({
                pathType: pathType,
                controlPoints: points,
                expectedDistance: distance,
            });
            if (s.length > 10) {
                this.readCustomSampleBanks(bankInfo, s[10]);
            }
            // One node for each repeat + the start and end nodes
            const nodes = repeatCount + 2;
            // Populate node sample bank infos with the default hit object sample bank
            const nodeBankInfos = Utils.initializeArray(nodes, () => new SampleBankInfo(bankInfo));
            // Read any per-node sample banks
            if (s.length > 9 && s[9]) {
                const sets = s[9].split("|");
                for (let i = 0; i < Math.min(sets.length, nodes); ++i) {
                    this.readCustomSampleBanks(nodeBankInfos[i], sets[i]);
                }
            }
            // Populate node sound types with the default hit object sound type
            const nodeSoundTypes = Utils.initializeArray(nodes, soundType);
            // Read any per-node sound types
            if (s.length > 8 && s[8]) {
                const adds = s[8].split("|");
                for (let i = 0; i < Math.min(adds.length, nodes); ++i) {
                    nodeSoundTypes[i] = parseInt(adds[i]);
                }
            }
            // Generate the final per-node samples
            const nodeSamples = Utils.initializeArray(nodes, (i) => this.convertSoundType(nodeSoundTypes[i], nodeBankInfos[i]));
            newCombo || (newCombo = this.forceNewCombo);
            comboOffset += this.extraComboOffset;
            this.forceNewCombo = false;
            this.extraComboOffset = 0;
            let tickDistanceMultiplier = Number.POSITIVE_INFINITY;
            if (difficultyControlPoint.generateTicks) {
                if (this.isNumberValid(timingControlPoint.msPerBeat, ParserConstants.MIN_MSPERBEAT_VALUE, ParserConstants.MAX_MSPERBEAT_VALUE)) {
                    // Prior to v8, speed multipliers don't adjust for how many ticks are generated over the same distance.
                    // This results in more (or less) ticks being generated in <v8 maps for the same time duration.
                    //
                    // This additional check is used in case BPM goes very low or very high.
                    // When lazer is final, this should be revisited.
                    tickDistanceMultiplier =
                        this.target.formatVersion < 8
                            ? 1 / difficultyControlPoint.speedMultiplier
                            : 1;
                }
                else {
                    tickDistanceMultiplier = 1;
                }
            }
            object = new Slider({
                position: position,
                startTime: time,
                type: type,
                newCombo: newCombo,
                comboOffset: comboOffset,
                nodeSamples: nodeSamples,
                repeatCount: repeatCount,
                path: path,
                tickDistanceMultiplier: tickDistanceMultiplier,
            });
        }
        else if (type & exports.ObjectTypes.spinner) {
            // Spinners don't create the new combo themselves, but force the next non-spinner hitobject to create a new combo.
            // Their combo offset is still added to that next hitobject's combo index.
            this.forceNewCombo || (this.forceNewCombo = this.target.formatVersion <= 8 || newCombo);
            this.extraComboOffset += comboOffset;
            object = new Spinner({
                startTime: time,
                type: type,
                endTime: this.target.getOffsetTime(this.tryParseInt(this.setPosition(s[5]))),
            });
            if (s.length > 6) {
                this.readCustomSampleBanks(bankInfo, s[6]);
            }
        }
        if (!object) {
            throw new Error("Ignoring malformed hitobject");
        }
        if (object.samples.length === 0) {
            object.samples = this.convertSoundType(soundType, bankInfo);
        }
        this.target.hitObjects.add(object);
    }
    /**
     * Converts a sound type to hit samples.
     *
     * @param type The sound type.
     * @param bankInfo The bank
     */
    convertSoundType(type, bankInfo) {
        const soundTypes = [];
        if (bankInfo.filename) {
            soundTypes.push(new FileHitSampleInfo(bankInfo.filename, bankInfo.volume));
        }
        else {
            soundTypes.push(new BankHitSampleInfo(BankHitSampleInfo.HIT_NORMAL, bankInfo.normal, bankInfo.customSampleBank, bankInfo.volume, 
            // If the sound type doesn't have the Normal flag set, attach it anyway as a layered sample.
            // None also counts as a normal non-layered sample: https://osu.ppy.sh/help/wiki/osu!_File_Formats/Osu_(file_format)#hitsounds
            type !== exports.HitSoundType.none && !(type & exports.HitSoundType.normal)));
        }
        const addBankSample = (name) => {
            soundTypes.push(new BankHitSampleInfo(name, bankInfo.add, bankInfo.customSampleBank, bankInfo.volume));
        };
        if (type & exports.HitSoundType.finish) {
            addBankSample(BankHitSampleInfo.HIT_FINISH);
        }
        if (type & exports.HitSoundType.whistle) {
            addBankSample(BankHitSampleInfo.HIT_WHISTLE);
        }
        if (type & exports.HitSoundType.clap) {
            addBankSample(BankHitSampleInfo.HIT_CLAP);
        }
        return soundTypes;
    }
    /**
     * Populates a sample bank info with custom sample bank information.
     *
     * @param bankInfo The sample bank info to populate.
     * @param str The information.
     */
    readCustomSampleBanks(bankInfo, str) {
        if (!str) {
            return;
        }
        const s = str.split(":");
        bankInfo.normal = parseInt(s[0]);
        const addBank = parseInt(s[1]);
        bankInfo.add = addBank === exports.SampleBank.none ? bankInfo.normal : addBank;
        if (s.length > 2) {
            bankInfo.customSampleBank = parseInt(s[2]);
        }
        if (s.length > 3) {
            bankInfo.volume = Math.max(0, parseInt(s[3]));
        }
        if (s.length > 4) {
            bankInfo.filename = s[4];
        }
    }
}

/**
 * A decoder for decoding a beatmap's general section.
 */
class BeatmapGeneralDecoder extends SectionDecoder {
    decodeInternal(line) {
        var _a;
        const p = this.property(line);
        switch (p[0]) {
            case "AudioFilename":
                this.target.general.audioFilename = p[1];
                break;
            case "AudioLeadIn":
                this.target.general.audioLeadIn = this.tryParseInt(p[1]);
                break;
            case "PreviewTime":
                this.target.general.previewTime = this.tryParseInt(p[1]);
                break;
            case "Countdown":
                this.target.general.countdown = (this.tryParseInt(p[1]));
                break;
            case "SampleSet":
                switch (p[1]) {
                    case "Normal":
                        this.target.general.sampleBank = exports.SampleBank.normal;
                        break;
                    case "Soft":
                        this.target.general.sampleBank = exports.SampleBank.soft;
                        break;
                    case "Drum":
                        this.target.general.sampleBank = exports.SampleBank.drum;
                        break;
                }
                break;
            case "SampleVolume":
                this.target.general.sampleVolume = this.tryParseInt(p[1]);
                break;
            case "StackLeniency":
                this.target.general.stackLeniency = this.tryParseFloat(p[1]);
                break;
            case "Mode":
                this.target.general.mode = this.tryParseInt(p[1]);
                break;
            case "LetterboxInBreaks":
                this.target.general.letterBoxInBreaks = !!this.tryParseInt(p[1]);
                break;
            case "UseSkinSprites":
                this.target.general.useSkinSprites = !!this.tryParseInt(p[1]);
                break;
            case "OverlayPosition":
                this.target.general.overlayPosition = (p[1]);
                break;
            case "SkinPreference":
                this.target.general.skinPreference = (_a = p[1]) !== null && _a !== void 0 ? _a : "";
                break;
            case "EpilepsyWarning":
                this.target.general.epilepsyWarning = !!this.tryParseInt(p[1]);
                break;
            case "CountdownOffset":
                this.target.general.countdownOffset = this.tryParseInt(p[1] || "0");
                break;
            case "WidescreenStoryboard":
                this.target.general.widescreenStoryboard = !!this.tryParseInt(p[1]);
                break;
            case "SamplesMatchPlaybackRate":
                this.target.general.samplesMatchPlaybackRate =
                    !!this.tryParseInt(p[1]);
                break;
            case "EditorBookmarks":
                // This somehow makes it in v5 (https://osu.ppy.sh/beatmapsets/2459#osu/19753)
                this.target.editor.bookmarks = p[1]
                    .split(",")
                    .map((v) => this.tryParseInt(v));
        }
    }
}

/**
 * A decoder for decoding a beatmap's editor section.
 */
class BeatmapEditorDecoder extends SectionDecoder {
    decodeInternal(line) {
        const p = this.property(line);
        switch (p[0]) {
            case "Bookmarks":
                this.target.editor.bookmarks = p[1]
                    .split(",")
                    .map((v) => this.tryParseInt(v));
                break;
            case "DistanceSpacing":
                this.target.editor.distanceSnap = this.tryParseFloat(p[1]);
                break;
            case "BeatDivisor":
                this.target.editor.beatDivisor = this.tryParseFloat(p[1]);
                break;
            case "GridSize":
                this.target.editor.gridSize = (this.tryParseInt(p[1]));
                break;
            case "TimelineZoom":
                this.target.editor.timelineZoom = this.tryParseFloat(p[1]);
                break;
        }
    }
}

/**
 * Represents a beatmap's video.
 */
class BeatmapVideo {
    constructor(startTime, filename, offset) {
        this.startTime = startTime;
        this.filename = filename;
        this.offset = offset;
    }
}

/**
 * Represents a break period in a beatmap.
 */
class BreakPoint {
    /**
     * The duration of the break period.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    constructor(values) {
        this.startTime = values.startTime;
        this.endTime = values.endTime;
    }
    /**
     * Returns a string representation of the class.
     */
    toString() {
        return `Start time: ${this.startTime}, end time: ${this.endTime}, duration: ${this.duration}`;
    }
    /**
     * Whether this break period contains a specified time.
     *
     * @param time The time to check in milliseconds.
     * @returns Whether the time falls within this break period.
     */
    contains(time) {
        return (time >= this.startTime &&
            time <= this.endTime - BreakPoint.MIN_BREAK_DURATION / 2);
    }
}
/**
 * The minimum duration required for a break to have any effect.
 */
BreakPoint.MIN_BREAK_DURATION = 650;

/**
 * A decoder for decoding a beatmap's events section.
 */
class BeatmapEventsDecoder extends SectionDecoder {
    constructor() {
        super(...arguments);
        this.storyboardLines = [];
    }
    decodeInternal(line) {
        const s = line.split(",");
        switch (s[0]) {
            case "0":
                this.parseBackground(s);
                break;
            case "1":
            case "Video":
                this.parseVideo(s);
                break;
            case "2":
            case "Break":
                this.parseBreak(s);
                break;
            default:
                this.storyboardLines.push(line);
        }
    }
    parseBackground(s) {
        var _a, _b;
        this.target.events.background = new BeatmapBackground(this.setPosition(s[2]).replace(/"/g, ""), new Vector2(this.tryParseFloat(this.setPosition((_a = s[3]) !== null && _a !== void 0 ? _a : "0")), this.tryParseFloat(this.setPosition((_b = s[4]) !== null && _b !== void 0 ? _b : "0"))));
    }
    parseVideo(s) {
        var _a, _b;
        this.target.events.video = new BeatmapVideo(this.tryParseInt(this.setPosition(s[1])), this.setPosition(s[2]).replace(/"/g, ""), new Vector2(this.tryParseFloat(this.setPosition((_a = s[3]) !== null && _a !== void 0 ? _a : "0")), this.tryParseFloat(this.setPosition((_b = s[4]) !== null && _b !== void 0 ? _b : "0"))));
    }
    parseBreak(s) {
        this.target.events.breaks.push(new BreakPoint({
            startTime: this.target.getOffsetTime(this.tryParseInt(this.setPosition(s[1]))),
            endTime: this.target.getOffsetTime(this.tryParseInt(this.setPosition(s[2]))),
        }));
    }
}

/**
 * A decoder for decoding a beatmap's difficulty section.
 */
class BeatmapDifficultyDecoder extends SectionDecoder {
    decodeInternal(line) {
        const p = this.property(line);
        switch (p[0]) {
            case "CircleSize":
                this.target.difficulty.cs = this.tryParseFloat(this.setPosition(p[1]));
                break;
            case "OverallDifficulty":
                this.target.difficulty.od = this.tryParseFloat(this.setPosition(p[1]));
                break;
            case "ApproachRate":
                this.target.difficulty.ar = this.tryParseFloat(this.setPosition(p[1]));
                break;
            case "HPDrainRate":
                this.target.difficulty.hp = this.tryParseFloat(this.setPosition(p[1]));
                break;
            case "SliderMultiplier":
                this.target.difficulty.sliderMultiplier = MathUtils.clamp(this.tryParseFloat(this.setPosition(p[1])), 0.4, 3.6);
                break;
            case "SliderTickRate":
                this.target.difficulty.sliderTickRate = MathUtils.clamp(this.tryParseFloat(this.setPosition(p[1])), 0.5, 8);
        }
    }
}

/**
 * A decoder for decoding a beatmap's metadata section.
 */
class BeatmapMetadataDecoder extends SectionDecoder {
    decodeInternal(line) {
        const p = this.property(line);
        switch (p[0]) {
            case "Title":
                this.target.metadata.title = p[1];
                break;
            case "TitleUnicode":
                this.target.metadata.titleUnicode = p[1];
                break;
            case "Artist":
                this.target.metadata.artist = p[1];
                break;
            case "ArtistUnicode":
                this.target.metadata.artistUnicode = p[1];
                break;
            case "Creator":
                this.target.metadata.creator = p[1];
                break;
            case "Version":
                this.target.metadata.version = p[1];
                break;
            case "Source":
                this.target.metadata.source = p[1];
                break;
            case "Tags":
                this.target.metadata.tags = p[1].split(" ");
                break;
            case "BeatmapID":
                this.target.metadata.beatmapId = parseInt(p[1]);
                break;
            case "BeatmapSetID":
                this.target.metadata.beatmapSetId = parseInt(p[1]);
                break;
        }
    }
}

/**
 * Effects that can occur in an effect control point.
 */
var EffectFlags;
(function (EffectFlags) {
    EffectFlags[EffectFlags["none"] = 0] = "none";
    EffectFlags[EffectFlags["kiai"] = 1] = "kiai";
    EffectFlags[EffectFlags["omitFirstBarLine"] = 8] = "omitFirstBarLine";
})(EffectFlags || (EffectFlags = {}));

/**
 * A decoder for decoding a beatmap's timing points section.
 */
class BeatmapControlPointsDecoder extends SectionDecoder {
    decodeInternal(line) {
        const s = line.split(",");
        if (s.length < 2) {
            throw new Error("Ignoring malformed timing point");
        }
        const time = this.target.getOffsetTime(this.tryParseFloat(this.setPosition(s[0])));
        // msPerBeat is allowed to be NaN to handle an edge case in which some
        // beatmaps use NaN slider velocity to disable slider tick generation.
        const msPerBeat = this.tryParseFloat(this.setPosition(s[1]), undefined, undefined, true);
        let timeSignature = 4;
        if (s.length >= 3) {
            timeSignature = this.tryParseInt(this.setPosition(s[2]));
        }
        if (timeSignature < 1) {
            throw new RangeError("The numerator of a time signature must be positive");
        }
        let sampleSet = this.target.general.sampleBank;
        if (s.length >= 4) {
            sampleSet = this.tryParseInt(this.setPosition(s[3]));
        }
        let customSampleBank = 0;
        if (s.length >= 5) {
            customSampleBank = this.tryParseInt(this.setPosition(s[4]));
        }
        let sampleVolume = this.target.general.sampleVolume;
        if (s.length >= 6) {
            sampleVolume = this.tryParseInt(this.setPosition(s[5]));
        }
        let kiaiMode = false;
        let omitFirstBarSignature = false;
        if (s.length >= 8) {
            const effectBitFlags = this.tryParseInt(this.setPosition(s[7]));
            kiaiMode = !!(effectBitFlags & EffectFlags.kiai);
            omitFirstBarSignature = !!(effectBitFlags & EffectFlags.omitFirstBarLine);
        }
        let timingChange = true;
        if (s.length >= 7) {
            timingChange = s[6] === "1";
        }
        if (timingChange) {
            if (Number.isNaN(msPerBeat)) {
                throw new Error("Beat length cannot be NaN in a timing control point");
            }
            this.target.controlPoints.timing.add(new TimingControlPoint({
                time: time,
                msPerBeat: msPerBeat,
                timeSignature: timeSignature,
            }));
        }
        this.target.controlPoints.difficulty.add(new DifficultyControlPoint({
            time: time,
            // If msPerBeat is NaN, speedMultiplier should still be 1 because all comparisons against NaN are false.
            speedMultiplier: msPerBeat < 0 ? 100 / -msPerBeat : 1,
            generateTicks: !Number.isNaN(msPerBeat),
        }));
        this.target.controlPoints.effect.add(new EffectControlPoint({
            time: time,
            isKiai: kiaiMode,
            omitFirstBarLine: omitFirstBarSignature,
        }));
        this.target.controlPoints.sample.add(new SampleControlPoint({
            time: time,
            sampleBank: sampleSet,
            sampleVolume: sampleVolume,
            customSampleBank: customSampleBank,
        }));
    }
}

/**
 * Represents an RGB color.
 */
class RGBColor {
    constructor(r, g, b, a = 1) {
        this.r = MathUtils.clamp(r, 0, 255);
        this.g = MathUtils.clamp(g, 0, 255);
        this.b = MathUtils.clamp(b, 0, 255);
        this.a = MathUtils.clamp(a, 0, 1);
    }
    /**
     * Returns a string representation of the color.
     */
    toString() {
        if (this.a === 1) {
            return `${this.r},${this.g},${this.b}`;
        }
        else {
            return `${this.r},${this.g},${this.b},${this.a}`;
        }
    }
    /**
     * Checks whether this color is equal to another color.
     *
     * @param other The other color.
     */
    equals(other) {
        return (this.r === other.r &&
            this.g === other.g &&
            this.b === other.b &&
            this.a === other.a);
    }
}

/**
 * A decoder for decoding a beatmap's colors section.
 */
class BeatmapColorDecoder extends SectionDecoder {
    decodeInternal(line) {
        const p = this.property(line);
        const s = this.setPosition(p[1])
            .split(",")
            .map((v) => this.tryParseInt(v));
        if (s.length !== 3 && s.length !== 4) {
            throw new TypeError("Color specified in incorrect format (should be R,G,B or R,G,B,A)");
        }
        const color = new RGBColor(s[0], s[1], s[2], s[3]);
        if (p[0].startsWith("Combo")) {
            this.target.colors.combo.push(color);
            return;
        }
        switch (p[0]) {
            case "SliderTrackOverride":
                this.target.colors.sliderTrackOverride = color;
                break;
            case "SliderBorder":
                this.target.colors.sliderBorder = color;
                break;
        }
    }
}

/**
 * Normalize a string path, reducing '..' and '.' parts.
 * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash,
 * it is preserved.
 *
 * This function's implementation matches Node.js v10.3 API.
 *
 * @param path string path to normalize.
 * @returns The normalized path.
 * @throws {TypeError} if `path` is not a string.
 */
function normalize(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Expected a string, got ${typeof path}`);
    }
    if (path.length === 0) {
        return ".";
    }
    const isAbsolute = path.charCodeAt(0) === 47; /*/*/
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47; /*/*/
    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) {
        path = ".";
    }
    if (path.length > 0 && trailingSeparator) {
        path += "/";
    }
    if (isAbsolute) {
        return "/" + path;
    }
    return path;
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for (let i = 0; i <= path.length; ++i) {
        if (i < path.length) {
            code = path.charCodeAt(i);
        }
        else if (code === 47 /*/*/) {
            break;
        }
        else {
            code = 47 /*/*/;
        }
        if (code === 47 /*/*/) {
            if (lastSlash === i - 1 || dots === 1) ;
            else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 ||
                    lastSegmentLength !== 2 ||
                    res.charCodeAt(res.length - 1) !== 46 /*.*/ ||
                    res.charCodeAt(res.length - 2) !== 46 /*.*/) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf("/");
                        if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength =
                                    res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0)
                        res += "/..";
                    else
                        res = "..";
                    lastSegmentLength = 2;
                }
            }
            else {
                if (res.length > 0) {
                    res += "/" + path.slice(lastSlash + 1, i);
                }
                else {
                    res = path.slice(lastSlash + 1, i);
                }
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        }
        else if (code === 46 /*.*/ && dots !== -1) {
            ++dots;
        }
        else {
            dots = -1;
        }
    }
    return res;
}

/**
 * Determines how color blending should be done.
 */
exports.BlendingEquation = void 0;
(function (BlendingEquation) {
    /**
     * Inherits from parent.
     */
    BlendingEquation[BlendingEquation["inherit"] = 0] = "inherit";
    /**
     * Adds the source and destination colours.
     */
    BlendingEquation[BlendingEquation["add"] = 1] = "add";
    /**
     * Chooses the minimum of each component of the source and destination colours.
     */
    BlendingEquation[BlendingEquation["min"] = 2] = "min";
    /**
     * Chooses the maximum of each component of the source and destination colours.
     */
    BlendingEquation[BlendingEquation["max"] = 3] = "max";
    /**
     * Subtracts the destination colour from the source colour.
     */
    BlendingEquation[BlendingEquation["subtract"] = 4] = "subtract";
    /**
     * Subtracts the source colour from the destination colour.
     */
    BlendingEquation[BlendingEquation["reverseSubtract"] = 5] = "reverseSubtract";
})(exports.BlendingEquation || (exports.BlendingEquation = {}));

/**
 * Determines how a blend operation should be done.
 */
exports.BlendingType = void 0;
(function (BlendingType) {
    BlendingType[BlendingType["inherit"] = 0] = "inherit";
    BlendingType[BlendingType["constantAlpha"] = 1] = "constantAlpha";
    BlendingType[BlendingType["constantColor"] = 2] = "constantColor";
    BlendingType[BlendingType["dstAlpha"] = 3] = "dstAlpha";
    BlendingType[BlendingType["dstColor"] = 4] = "dstColor";
    BlendingType[BlendingType["one"] = 5] = "one";
    BlendingType[BlendingType["oneMinusConstantAlpha"] = 6] = "oneMinusConstantAlpha";
    BlendingType[BlendingType["oneMinusConstantColor"] = 7] = "oneMinusConstantColor";
    BlendingType[BlendingType["oneMinusDstAlpha"] = 8] = "oneMinusDstAlpha";
    BlendingType[BlendingType["oneMinusDstColor"] = 9] = "oneMinusDstColor";
    BlendingType[BlendingType["oneMinusSrcAlpha"] = 10] = "oneMinusSrcAlpha";
    BlendingType[BlendingType["oneMinusSrcColor"] = 11] = "oneMinusSrcColor";
    BlendingType[BlendingType["srcAlpha"] = 12] = "srcAlpha";
    BlendingType[BlendingType["srcAlphaSaturate"] = 13] = "srcAlphaSaturate";
    BlendingType[BlendingType["srcColor"] = 14] = "srcColor";
    BlendingType[BlendingType["zero"] = 15] = "zero";
})(exports.BlendingType || (exports.BlendingType = {}));

/**
 * Contains information about how a blend mode operation should be blended into its destination.
 */
class BlendingParameters {
    constructor(source, destination, sourceAlpha, destinationAlpha, rgbEquation, alphaEquation) {
        this.source = source;
        this.destination = destination;
        this.sourceAlpha = sourceAlpha;
        this.destinationAlpha = destinationAlpha;
        this.rgbEquation = rgbEquation;
        this.alphaEquation = alphaEquation;
    }
}
BlendingParameters.none = new BlendingParameters(exports.BlendingType.one, exports.BlendingType.zero, exports.BlendingType.one, exports.BlendingType.zero, exports.BlendingEquation.add, exports.BlendingEquation.add);
BlendingParameters.inherit = new BlendingParameters(exports.BlendingType.inherit, exports.BlendingType.inherit, exports.BlendingType.inherit, exports.BlendingType.inherit, exports.BlendingEquation.inherit, exports.BlendingEquation.inherit);
BlendingParameters.mixture = new BlendingParameters(exports.BlendingType.srcAlpha, exports.BlendingType.oneMinusSrcAlpha, exports.BlendingType.one, exports.BlendingType.one, exports.BlendingEquation.add, exports.BlendingEquation.add);
BlendingParameters.additive = new BlendingParameters(exports.BlendingType.srcAlpha, exports.BlendingType.one, exports.BlendingType.one, exports.BlendingType.one, exports.BlendingEquation.add, exports.BlendingEquation.add);

/**
 * Available storyboard command types.
 */
exports.StoryboardCommandType = void 0;
(function (StoryboardCommandType) {
    StoryboardCommandType["movement"] = "M";
    StoryboardCommandType["movementX"] = "MX";
    StoryboardCommandType["movementY"] = "MY";
    StoryboardCommandType["fade"] = "F";
    StoryboardCommandType["scale"] = "S";
    StoryboardCommandType["vectorScale"] = "V";
    StoryboardCommandType["rotation"] = "R";
    StoryboardCommandType["color"] = "C";
    StoryboardCommandType["parameter"] = "P";
    StoryboardCommandType["loop"] = "L";
    StoryboardCommandType["trigger"] = "T";
})(exports.StoryboardCommandType || (exports.StoryboardCommandType = {}));

/**
 * Available storyboard parameter command types.
 */
exports.StoryboardParameterCommandType = void 0;
(function (StoryboardParameterCommandType) {
    StoryboardParameterCommandType["horizontalFlip"] = "H";
    StoryboardParameterCommandType["verticalFlip"] = "V";
    StoryboardParameterCommandType["blendingMode"] = "A";
})(exports.StoryboardParameterCommandType || (exports.StoryboardParameterCommandType = {}));

/**
 * Represents a storyboard command.
 */
class Command {
    /**
     * The duration of the command.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    constructor(easing, startTime, endTime, startValue, endValue, type, parameterType) {
        this.easing = easing;
        this.startTime = startTime;
        this.endTime = endTime;
        this.startValue = startValue;
        this.endValue = endValue;
        this.type = type;
        this.parameterType = parameterType;
    }
    /**
     * Whether this command is a parameter command.
     */
    isParameter() {
        return this.parameterType !== undefined;
    }
    toString() {
        return `${this.startTime} -> ${this.endTime}, ${this.startValue} -> ${this.endValue} ${this.easing}`;
    }
}

/**
 * Represents a command timeline.
 *
 * A command timeline contains all commands of the same type that occur in a sprite.
 */
class CommandTimeline {
    /**
     * The commands in this command timeline.
     */
    get commands() {
        return this._commands;
    }
    get startTime() {
        return this._startTime;
    }
    get endTime() {
        return this._endTime;
    }
    /**
     * The start value of the command timeline.
     */
    get startValue() {
        return this._startValue;
    }
    /**
     * The end value of the command timeline.
     */
    get endValue() {
        return this._endValue;
    }
    get hasCommands() {
        return this._commands.length > 0;
    }
    constructor(type, parameterType) {
        this._commands = [];
        this._startTime = Number.MAX_SAFE_INTEGER;
        this._endTime = Number.MIN_SAFE_INTEGER;
        this._startValue = null;
        this._endValue = null;
        this.type = type;
        this.parameterType = parameterType;
    }
    /**
     * Adds a command to this command timeline.
     *
     * @param easing The easing to apply.
     * @param startTime The start time of the command.
     * @param endTime The end time of the command.
     * @param startValue The start value of the command.
     * @param endValue The end value of the command.
     */
    add(easing, startTime, endTime, startValue, endValue) {
        if (startTime > endTime) {
            return;
        }
        this._commands.push(new Command(easing, startTime, endTime, startValue, endValue, this.type, this.parameterType));
        if (startTime < this._startTime) {
            this._startValue = startValue;
            this._startTime = startTime;
        }
        if (endTime > this._endTime) {
            this._endValue = endValue;
            this._endTime = endTime;
        }
        this._commands.sort((a, b) => a.startTime - b.startTime);
    }
}

/**
 * Represents a group of command timelines.
 */
class CommandTimelineGroup {
    constructor() {
        /**
         * The command timeline that changes an animation or sprite's X and Y coordinates.
         */
        this.move = new CommandTimeline(exports.StoryboardCommandType.movement);
        /**
         * The command timeline that changes an animation or sprite's X-coordinate.
         */
        this.x = new CommandTimeline(exports.StoryboardCommandType.movementX);
        /**
         * The command timeline that changes an animation or sprite's Y-coordinate.
         */
        this.y = new CommandTimeline(exports.StoryboardCommandType.movementY);
        /**
         * The command timeline that scales an animation or sprite with a number.
         */
        this.scale = new CommandTimeline(exports.StoryboardCommandType.scale);
        /**
         * The command timeline that scales an animation or sprite with a vector.
         *
         * This allows scaling the width and height of an animation or sprite individually at the same time.
         */
        this.vectorScale = new CommandTimeline(exports.StoryboardCommandType.vectorScale);
        /**
         * The command timeline that rotates an animation or sprite, in radians, clockwise.
         */
        this.rotation = new CommandTimeline(exports.StoryboardCommandType.rotation);
        /**
         * The command timeline that changes an animation or sprite's virtual light source color.
         *
         * The colors of the pixels on the animation or sprite are determined subtractively.
         */
        this.color = new CommandTimeline(exports.StoryboardCommandType.color);
        /**
         * The command timeline that changes the opacity of an animation or sprite.
         */
        this.alpha = new CommandTimeline(exports.StoryboardCommandType.fade);
        /**
         * The command timeline that determines the blending behavior of an animation or sprite.
         */
        this.blendingParameters = new CommandTimeline(exports.StoryboardCommandType.parameter, exports.StoryboardParameterCommandType.blendingMode);
        /**
         * The command timeline that determines whether the animation or sprite should be flipped horizontally.
         */
        this.flipHorizontal = new CommandTimeline(exports.StoryboardCommandType.parameter, exports.StoryboardParameterCommandType.horizontalFlip);
        /**
         * The command timeline that determines whether the animation or sprite should be flipped vertically.
         */
        this.flipVertical = new CommandTimeline(exports.StoryboardCommandType.parameter, exports.StoryboardParameterCommandType.verticalFlip);
        this.timelines = [
            this.x,
            this.y,
            this.scale,
            this.vectorScale,
            this.rotation,
            this.color,
            this.alpha,
            this.blendingParameters,
            this.flipHorizontal,
            this.flipVertical,
        ];
    }
    /**
     * The start time of commands.
     */
    get commandsStartTime() {
        return Math.min(...this.timelines.map((t) => t.startTime));
    }
    /**
     * The end time of commands.
     */
    get commandsEndTime() {
        return Math.max(...this.timelines.map((t) => t.endTime));
    }
    /**
     * The duration of commands.
     */
    get commandsDuration() {
        return this.commandsEndTime - this.commandsStartTime;
    }
    /**
     * The start time of the command timeline group.
     */
    get startTime() {
        return this.commandsStartTime;
    }
    /**
     * The end time of the command timeline group.
     */
    get endTime() {
        return this.commandsEndTime;
    }
    /**
     * The duration of the command timeline group.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    /**
     * Whether this command timeline group has at least one command.
     */
    get hasCommands() {
        return this.timelines.some((t) => t.hasCommands);
    }
    /**
     * Gets the commands from a command timeline.
     *
     * @param timelineSelector A function to select the command timeline to retrieve commands from.
     * @param offset The offset to apply to all commands.
     */
    getCommands(timelineSelector, offset = 0) {
        const timeline = timelineSelector(this);
        if (offset !== 0) {
            return timeline.commands.map((c) => new Command(c.easing, offset + c.startTime, offset + c.endTime, c.startValue, c.endValue, c.type, c.parameterType));
        }
        return timeline.commands;
    }
}

/**
 * Represents a loop compound command.
 */
class CommandLoop extends CommandTimelineGroup {
    get startTime() {
        return this.loopStartTime + this.commandsStartTime;
    }
    get endTime() {
        return this.startTime + this.commandsDuration * this.totalIterations;
    }
    constructor(startTime, repeatCount) {
        super();
        if (repeatCount < 0) {
            throw new RangeError("Repeat count must be zero or above.");
        }
        this.loopStartTime = startTime;
        this.totalIterations = repeatCount + 1;
    }
    getCommands(timelineSelector, offset = 0) {
        const commands = [];
        for (let i = 0; i < this.totalIterations; ++i) {
            const loopOffset = this.loopStartTime + i * this.commandsDuration;
            commands.push(...super.getCommands(timelineSelector, offset + loopOffset));
        }
        return commands;
    }
    toString() {
        return `${this.loopStartTime} x${this.totalIterations}`;
    }
}

/**
 * Represents a trigger command.
 */
class CommandTrigger extends CommandTimelineGroup {
    constructor(triggerName, startTime, endTime, groupNumber) {
        super();
        this.triggerName = triggerName;
        this.triggerStartTime = startTime;
        this.triggerEndTime = endTime;
        this.groupNumber = groupNumber;
    }
    toString() {
        return `${this.triggerName} ${this.triggerStartTime} -> ${this.triggerEndTime} (${this.groupNumber})`;
    }
}

/**
 * Represents a storyboard element.
 */
class StoryboardElement {
    /**
     * The time at which the element ends.
     */
    get endTime() {
        return this.startTime;
    }
    /**
     * The duration of the storyboard element.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    constructor(path) {
        this.path = path;
    }
}

/**
 * Represents a storyboard sprite.
 */
class StoryboardSprite extends StoryboardElement {
    get startTime() {
        // To get the initial start time, we need to check whether the first alpha command to exist (across all loops) has a start value of zero.
        // A start value of zero governs, above all else, the first valid display time of a sprite.
        //
        // You can imagine that the first command of each type decides that type's start value, so if the initial alpha is zero,
        // anything before that point can be ignored (the sprite is not visible after all).
        const alphaCommands = [];
        let command = this.timelineGroup.alpha.commands[0];
        if (command) {
            alphaCommands.push({
                startTime: command.startTime,
                isZeroStartValue: command.startValue === 0,
            });
        }
        for (const l of this.loops) {
            command = l.alpha.commands[0];
            if (command) {
                alphaCommands.push({
                    startTime: command.startTime + l.loopStartTime,
                    isZeroStartValue: command.startValue === 0,
                });
            }
        }
        if (alphaCommands.length > 0) {
            const firstAlpha = alphaCommands.sort((a, b) => a.startTime - b.startTime)[0];
            if (firstAlpha.isZeroStartValue) {
                return firstAlpha.startTime;
            }
        }
        return this.earliestTransformTime;
    }
    /**
     * The time at which the first transformation occurs.
     */
    get earliestTransformTime() {
        // If we got to this point, either no alpha commands were present, or the earliest had a non-zero start value.
        // The sprite's start time will be determined by the earliest command, regardless of type.
        let earliestStartTime = this.timelineGroup.startTime;
        for (const l of this.loops) {
            earliestStartTime = Math.min(earliestStartTime, l.startTime);
        }
        return earliestStartTime;
    }
    get endTime() {
        return Math.max(this.timelineGroup.endTime, ...this.loops.map((l) => l.endTime));
    }
    /**
     * Whether this sprite has at least one command.
     */
    get hasCommands() {
        return (this.timelineGroup.hasCommands ||
            this.loops.some((l) => l.hasCommands));
    }
    constructor(path, origin, initialPosition) {
        super(path);
        /**
         * The loop commands of the sprite.
         */
        this.loops = [];
        /**
         * The trigger commands of the sprite.
         */
        this.triggers = [];
        /**
         * The command timeline group of the sprite.
         */
        this.timelineGroup = new CommandTimelineGroup();
        this.origin = origin;
        this.initialPosition = initialPosition;
    }
    /**
     * Adds a loop command to the sprite.
     *
     * @param startTime The start time of the command.
     * @param repeatCount The total number of times this loop is played back. Must be greater than zero.
     * @returns The added command.
     */
    addLoop(startTime, repeatCount) {
        const loop = new CommandLoop(startTime, repeatCount);
        this.loops.push(loop);
        return loop;
    }
    /**
     * Adds a trigger command.
     *
     * @param triggerName The name of the trigger.
     * @param startTime The start time of the command.
     * @param endTime The end time of the command.
     * @param groupNumber The group number of the command.
     * @returns The added command.
     */
    addTrigger(triggerName, startTime, endTime, groupNumber) {
        const trigger = new CommandTrigger(triggerName, startTime, endTime, groupNumber);
        this.triggers.push(trigger);
        return trigger;
    }
    toString() {
        return `${this.path}, ${this.origin}, ${this.initialPosition}`;
    }
}

/**
 * Represents a storyboard's animation.
 */
class StoryboardAnimation extends StoryboardSprite {
    constructor(path, origin, initialPosition, frameCount, frameDelay, loopType) {
        super(path, origin, initialPosition);
        this.frameCount = frameCount;
        this.frameDelay = frameDelay;
        this.loopType = loopType;
    }
}

/**
 * Represents a storyboard sample.
 */
class StoryboardSample extends StoryboardElement {
    get startTime() {
        return this._startTime;
    }
    constructor(path, time, volume) {
        super(path);
        this._startTime = time;
        this.volume = volume;
    }
}

/**
 * Types of storyboard events.
 */
exports.StoryboardEventType = void 0;
(function (StoryboardEventType) {
    StoryboardEventType["background"] = "Background";
    StoryboardEventType["sprite"] = "Sprite";
    StoryboardEventType["color"] = "Colour";
    StoryboardEventType["sample"] = "Sample";
    StoryboardEventType["animation"] = "Animation";
})(exports.StoryboardEventType || (exports.StoryboardEventType = {}));

/**
 * A decoder for decoding a storyboard's events section.
 */
class StoryboardEventsDecoder extends SectionDecoder {
    constructor() {
        super(...arguments);
        this.storyboardSprite = null;
    }
    decodeInternal(line) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // Ignore comments, background, and video.
        if (["//", "0", "1", "Video", "2", "Break", "3"].some((v) => line.startsWith(v))) {
            return;
        }
        let depth = 0;
        for (const c of line) {
            if (c === " " || c === "_") {
                ++depth;
            }
            else {
                break;
            }
        }
        line = line.substring(depth);
        // Decode any beatmap variables present in a line into their real values.
        while (line.includes("$")) {
            const originalLine = line;
            for (const key in this.target.variables) {
                line = line.replace(key, this.target.variables[key]);
            }
            if (line === originalLine) {
                break;
            }
        }
        const s = line.split(",");
        if (depth === 0) {
            this.storyboardSprite = null;
            switch (this.setPosition(s[0])) {
                case exports.StoryboardEventType.sprite: {
                    this.storyboardSprite = new StoryboardSprite(this.cleanFilename(this.setPosition(s[3])), this.setPosition(s[2]), new Vector2(this.tryParseFloat(this.setPosition(s[4]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE), this.tryParseFloat(this.setPosition(s[5]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE)));
                    this.target
                        .getLayer(this.setPosition(s[1]))
                        .elements.push(this.storyboardSprite);
                    break;
                }
                case exports.StoryboardEventType.animation: {
                    let frameDelay = this.tryParseInt(this.setPosition(s[7]));
                    const loopType = s[8] === "1" || s[8] === "LoopOnce"
                        ? exports.AnimationLoopType.loopOnce
                        : exports.AnimationLoopType.loopForever;
                    if (this.formatVersion < 6) {
                        // This is random as hell but taken straight from osu-stable.
                        frameDelay =
                            Math.round(0.015 * frameDelay) *
                                1.186 *
                                (1000 / 60);
                    }
                    this.storyboardSprite = new StoryboardAnimation(this.cleanFilename(this.setPosition(s[3])), this.setPosition(s[2]), new Vector2(this.tryParseFloat(this.setPosition(s[4]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE), this.tryParseFloat(this.setPosition(s[5]), -ParserConstants.MAX_COORDINATE_VALUE, ParserConstants.MAX_COORDINATE_VALUE)), this.tryParseInt(this.setPosition(s[6])), frameDelay, loopType);
                    this.target
                        .getLayer(this.setPosition(s[1]))
                        .elements.push(this.storyboardSprite);
                    break;
                }
                case exports.StoryboardEventType.sample:
                    this.target
                        .getLayer(this.setPosition(s[2]))
                        .elements.push(new StoryboardSample(this.cleanFilename(this.setPosition(s[3])), this.tryParseInt(this.setPosition(s[1])), s.length > 4
                        ? this.tryParseInt(this.setPosition(s[4]))
                        : 100));
                    break;
                default:
                    throw new TypeError(`Unknown event type: ${this.setPosition(s[0])}`);
            }
        }
        else {
            if (depth < 2) {
                this.timelineGroup = (_a = this.storyboardSprite) === null || _a === void 0 ? void 0 : _a.timelineGroup;
            }
            switch (this.setPosition(s[0])) {
                case exports.StoryboardCommandType.trigger:
                    this.timelineGroup = (_b = this.storyboardSprite) === null || _b === void 0 ? void 0 : _b.addTrigger(this.setPosition(s[1]), s.length > 2
                        ? this.tryParseInt(this.setPosition(s[2]))
                        : Number.MIN_SAFE_INTEGER, s.length > 3
                        ? this.tryParseInt(this.setPosition(s[3]))
                        : Number.MAX_SAFE_INTEGER, s.length > 4
                        ? this.tryParseInt(this.setPosition(s[4]))
                        : 0);
                    break;
                case exports.StoryboardCommandType.loop:
                    this.timelineGroup = (_c = this.storyboardSprite) === null || _c === void 0 ? void 0 : _c.addLoop(this.tryParseInt(this.setPosition(s[1])), Math.max(0, this.tryParseInt(this.setPosition(s[2])) - 1));
                    break;
                default: {
                    if (!s[3]) {
                        s[3] = this.setPosition(s[2]);
                    }
                    const easing = (this.tryParseInt(this.setPosition(s[1])));
                    const startTime = this.tryParseInt(this.setPosition(s[2]));
                    const endTime = this.tryParseInt(this.setPosition(s[3]));
                    switch (s[0]) {
                        case exports.StoryboardCommandType.fade: {
                            const startValue = this.tryParseFloat(this.setPosition(s[4]));
                            const endValue = s.length > 5
                                ? this.tryParseFloat(this.setPosition(s[5]))
                                : startValue;
                            (_d = this.timelineGroup) === null || _d === void 0 ? void 0 : _d.alpha.add(easing, startTime, endTime, startValue, endValue);
                            break;
                        }
                        case exports.StoryboardCommandType.scale: {
                            const startValue = this.tryParseFloat(this.setPosition(s[4]));
                            const endValue = s.length > 5
                                ? this.tryParseFloat(this.setPosition(s[5]))
                                : startValue;
                            (_e = this.timelineGroup) === null || _e === void 0 ? void 0 : _e.scale.add(easing, startTime, endTime, startValue, endValue);
                            break;
                        }
                        case exports.StoryboardCommandType.vectorScale: {
                            const startX = this.tryParseFloat(this.setPosition(s[4]));
                            const startY = this.tryParseFloat(this.setPosition(s[5]));
                            const endX = s.length > 6
                                ? this.tryParseFloat(this.setPosition(s[6]))
                                : startX;
                            const endY = s.length > 7
                                ? this.tryParseFloat(this.setPosition(s[7]))
                                : startY;
                            (_f = this.timelineGroup) === null || _f === void 0 ? void 0 : _f.vectorScale.add(easing, startTime, endTime, new Vector2(startX, startY), new Vector2(endX, endY));
                            break;
                        }
                        case exports.StoryboardCommandType.rotation: {
                            const startValue = this.tryParseFloat(this.setPosition(s[4]));
                            const endValue = s.length > 5
                                ? this.tryParseFloat(this.setPosition(s[5]))
                                : startValue;
                            (_g = this.timelineGroup) === null || _g === void 0 ? void 0 : _g.rotation.add(easing, startTime, endTime, MathUtils.radiansToDegrees(startValue), MathUtils.radiansToDegrees(endValue));
                            break;
                        }
                        case exports.StoryboardCommandType.movement: {
                            const startX = this.tryParseFloat(this.setPosition(s[4]));
                            const startY = this.tryParseFloat(this.setPosition(s[5]));
                            const endX = s.length > 6
                                ? this.tryParseFloat(this.setPosition(s[6]))
                                : startX;
                            const endY = s.length > 7
                                ? this.tryParseFloat(this.setPosition(s[7]))
                                : startY;
                            (_h = this.timelineGroup) === null || _h === void 0 ? void 0 : _h.move.add(easing, startTime, endTime, new Vector2(startX, endX), new Vector2(startY, endY));
                            break;
                        }
                        case exports.StoryboardCommandType.movementX: {
                            const startValue = this.tryParseFloat(this.setPosition(s[4]));
                            const endValue = s.length > 5
                                ? this.tryParseFloat(this.setPosition(s[5]))
                                : startValue;
                            (_j = this.timelineGroup) === null || _j === void 0 ? void 0 : _j.x.add(easing, startTime, endTime, startValue, endValue);
                            break;
                        }
                        case exports.StoryboardCommandType.movementY: {
                            const startValue = this.tryParseFloat(this.setPosition(s[4]));
                            const endValue = s.length > 5
                                ? this.tryParseFloat(this.setPosition(s[5]))
                                : startValue;
                            (_k = this.timelineGroup) === null || _k === void 0 ? void 0 : _k.y.add(easing, startTime, endTime, startValue, endValue);
                            break;
                        }
                        case exports.StoryboardCommandType.color: {
                            const startRed = this.tryParseFloat(this.setPosition(s[4]));
                            const startGreen = this.tryParseFloat(this.setPosition(s[5]));
                            const startBlue = this.tryParseFloat(this.setPosition(s[6]));
                            const endRed = s.length > 7
                                ? this.tryParseFloat(this.setPosition(s[7]))
                                : startRed;
                            const endGreen = s.length > 8
                                ? this.tryParseFloat(s[8])
                                : startGreen;
                            const endBlue = s.length > 9
                                ? this.tryParseFloat(s[9])
                                : startBlue;
                            (_l = this.timelineGroup) === null || _l === void 0 ? void 0 : _l.color.add(easing, startTime, endTime, new RGBColor(startRed, startGreen, startBlue), new RGBColor(endRed, endGreen, endBlue));
                            break;
                        }
                        case exports.StoryboardCommandType.parameter:
                            switch (this.setPosition(s[4])) {
                                case exports.StoryboardParameterCommandType.blendingMode:
                                    (_m = this.timelineGroup) === null || _m === void 0 ? void 0 : _m.blendingParameters.add(easing, startTime, endTime, BlendingParameters.additive, startTime === endTime
                                        ? BlendingParameters.additive
                                        : BlendingParameters.inherit);
                                    break;
                                case exports.StoryboardParameterCommandType.horizontalFlip:
                                    (_o = this.timelineGroup) === null || _o === void 0 ? void 0 : _o.flipHorizontal.add(easing, startTime, endTime, true, startTime === endTime);
                                    break;
                                case exports.StoryboardParameterCommandType.verticalFlip:
                                    (_p = this.timelineGroup) === null || _p === void 0 ? void 0 : _p.flipVertical.add(easing, startTime, endTime, true, startTime === endTime);
                                    break;
                            }
                            break;
                        default:
                            throw new TypeError(`Unknown command type: ${this.setPosition(s[0])}`);
                    }
                }
            }
        }
    }
    cleanFilename(name) {
        // Trim double quotes from filenames.
        let start = 0;
        let end = name.length;
        while (start < end && name.charAt(start) === '"') {
            ++start;
        }
        while (end > start && name.charAt(end - 1) === '"') {
            --end;
        }
        return normalize(start > 0 || end < name.length ? name.substring(start, end) : name);
    }
}

/**
 * A decoder for decoding a storyboard's general section.
 */
class StoryboardGeneralDecoder extends SectionDecoder {
    decodeInternal(line) {
        const p = this.property(line);
        switch (p[0]) {
            case "UseSkinSprites":
                this.target.useSkinSprites = !!this.tryParseInt(p[1]);
                break;
        }
    }
}

/**
 * A decoder for decoding a storyboard's variables section.
 */
class StoryboardVariablesDecoder extends SectionDecoder {
    decodeInternal(line) {
        const s = line.split("=");
        this.target.variables[s[0]] = s[1];
    }
}

/**
 * Represents a storyboard's layer.
 */
class StoryboardLayer {
    constructor(name, depth, visibleWhenPassing = true, visibleWhenFailing = true) {
        /**
         * The storyboard elements in this layer.
         */
        this.elements = [];
        this.name = name;
        this.depth = depth;
        this.visibleWhenPassing = visibleWhenPassing;
        this.visibleWhenFailing = visibleWhenFailing;
    }
}

/**
 * Represents a storyboard.
 */
class Storyboard {
    constructor() {
        /**
         * The layers in the storyboard.
         */
        this.layers = {
            Background: new StoryboardLayer(exports.StoryboardLayerType.background, 3),
            Fail: new StoryboardLayer(exports.StoryboardLayerType.fail, 2, false),
            Pass: new StoryboardLayer(exports.StoryboardLayerType.pass, 1, true, false),
            Foreground: new StoryboardLayer(exports.StoryboardLayerType.foreground, 0),
            Overlay: new StoryboardLayer(exports.StoryboardLayerType.overlay, Number.MIN_SAFE_INTEGER),
        };
        /**
         * Whether the storyboard can fall back to skin sprites in case no matching storyboard sprites are found.
         */
        this.useSkinSprites = false;
        /**
         * The variables of the storyboard.
         */
        this.variables = {};
        /**
         * The depth of the currently front-most storyboard layer, excluding the overlay layer.
         */
        this.minimumLayerDepth = 0;
    }
    /**
     * Across all layers, find the earliest point in time that a storyboard element exists at.
     * Will return `null` if there are no elements.
     *
     * This iterates all elements and as such should be used sparingly or stored locally.
     */
    get earliestEventTime() {
        var _a, _b;
        return ((_b = (_a = Object.values(this.layers)
            .map((v) => v.elements)
            .flat()
            .sort((a, b) => a.startTime - b.startTime)[0]) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : null);
    }
    /**
     * Across all layers, find the latest point in time that a storyboard element exists at.
     * Will return `null` if there are no elements.
     *
     * This iterates all elements and as such should be used sparingly or stored locally.
     * Samples return start time as their end time.
     */
    get latestEventTime() {
        var _a, _b;
        return ((_b = (_a = Object.values(this.layers)
            .map((v) => v.elements)
            .flat()
            .sort((a, b) => b.endTime - a.endTime)[0]) === null || _a === void 0 ? void 0 : _a.endTime) !== null && _b !== void 0 ? _b : null);
    }
    getLayer(type, createIfNotAvailable = true) {
        let layer = this.layers[type];
        if (!layer && createIfNotAvailable) {
            layer = new StoryboardLayer(type, --this.minimumLayerDepth);
            this.layers[type] = layer;
        }
        return layer !== null && layer !== void 0 ? layer : null;
    }
}

/**
 * A storyboard decoder.
 */
class StoryboardDecoder extends Decoder {
    constructor(formatVersion = Decoder.latestVersion) {
        super();
        this.finalResult = new Storyboard();
        this.decoders = {};
        this.formatVersion = formatVersion;
    }
    reset() {
        super.reset();
        this.finalResult = new Storyboard();
        this.decoders = {
            General: new StoryboardGeneralDecoder(this.finalResult, this.formatVersion),
            Events: new StoryboardEventsDecoder(this.finalResult, this.formatVersion),
            Variables: new StoryboardVariablesDecoder(this.finalResult, this.formatVersion),
        };
    }
}

/**
 * A beatmap decoder.
 */
class BeatmapDecoder extends Decoder {
    constructor() {
        super(...arguments);
        this.finalResult = new Beatmap();
        this.decoders = {};
    }
    /**
     * @param str The string to decode.
     * @param mode The mode to parse the beatmap as. Defaults to osu!standard.
     * @param parseStoryboard Whether to parse the beatmap's storyboard.
     */
    decode(str, mode = exports.Modes.osu, parseStoryboard = true) {
        super.decode(str);
        this.finalResult.mode = mode;
        if (parseStoryboard) {
            const eventsDecoder = (this.decoders[BeatmapSection.events]);
            if (eventsDecoder.storyboardLines.length > 0) {
                this.finalResult.events.storyboard = new StoryboardDecoder(this.finalResult.formatVersion).decode(eventsDecoder.storyboardLines.join("\n")).result;
            }
        }
        const processor = new BeatmapProcessor(this.finalResult);
        processor.preProcess();
        this.finalResult.hitObjects.objects.forEach((h) => {
            h.applyDefaults(this.finalResult.controlPoints, this.finalResult.difficulty, mode);
            h.applySamples(this.finalResult.controlPoints);
        });
        processor.postProcess();
        return this;
    }
    decodeLine(line) {
        if (this.finalResult.formatVersion !== this.formatVersion) {
            this.finalResult.formatVersion = this.formatVersion;
        }
        super.decodeLine(line);
    }
    reset() {
        super.reset();
        this.finalResult = new Beatmap();
        this.decoders = {
            General: new BeatmapGeneralDecoder(this.finalResult),
            Editor: new BeatmapEditorDecoder(this.finalResult),
            Metadata: new BeatmapMetadataDecoder(this.finalResult),
            Difficulty: new BeatmapDifficultyDecoder(this.finalResult),
            Events: new BeatmapEventsDecoder(this.finalResult),
            TimingPoints: new BeatmapControlPointsDecoder(this.finalResult),
            Colours: new BeatmapColorDecoder(this.finalResult),
            HitObjects: new BeatmapHitObjectsDecoder(this.finalResult),
        };
    }
}

/**
 * The base of main encoders.
 */
class Encoder {
    /**
     * The result of the encoding process.
     */
    get result() {
        return this.finalResult;
    }
    /**
     * @param target The target of the encoding process.
     */
    constructor(target) {
        /**
         * The result of the encoding process.
         */
        this.finalResult = "";
        this.target = target;
    }
    /**
     * Performs the decoding process.
     *
     * Keep in mind that this will not produce the exact same file as the original decoded file.
     */
    encode() {
        this.reset();
        this.encodeInternal();
        return this;
    }
    /**
     * Writes a line to encoded text.
     *
     * @param line The line to write.
     */
    writeLine(line = "") {
        this.finalResult += line + "\n";
    }
    /**
     * Internal encoder function to encode the target to a string.
     */
    encodeInternal() {
        for (const encoder of this.encoders) {
            this.writeLine(encoder.encode());
        }
    }
}

/**
 * The base of all encoders.
 */
class BaseEncoder {
    constructor(encodeSections = true) {
        /**
         * The target of the encoding process.
         */
        this.result = "";
        this.encodeSections = encodeSections;
    }
    /**
     * Performs the encoding process.
     *
     * @returns The result.
     */
    encode() {
        this.encodeInternal();
        return this.result;
    }
    /**
     * Writes a line to encoded text.
     *
     * @param line The line to write.
     */
    write(line) {
        this.result += line;
    }
    /**
     * Writes a line to encoded text, followed by a line feed character (`\n`).
     *
     * @param line The line to write.
     */
    writeLine(line = "") {
        this.write(line);
        this.write("\n");
    }
}

/**
 * The base of per-section beatmap encoders.
 */
class BeatmapBaseEncoder extends BaseEncoder {
    constructor(map, encodeSections = true) {
        super(encodeSections);
        this.map = map;
    }
    /**
     * Converts a sample bank to its string equivalent.
     *
     * @param sampleBank The sample bank.
     */
    sampleBankToString(sampleBank) {
        switch (sampleBank) {
            case exports.SampleBank.normal:
                return "Normal";
            case exports.SampleBank.soft:
                return "Soft";
            case exports.SampleBank.drum:
                return "Drum";
            default:
                return "None";
        }
    }
}

/**
 * An encoder for encoding a beatmap's colors section.
 */
class BeatmapColorEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        const { colors } = this.map;
        if (colors.combo.length === 0 &&
            !colors.sliderBorder &&
            !colors.sliderTrackOverride) {
            return;
        }
        if (this.encodeSections) {
            this.writeLine("[Colours]");
        }
        for (let i = 0; i < colors.combo.length; ++i) {
            const color = colors.combo[i];
            this.write(`Combo${i + 1}: `);
            this.write(`${color.r},`);
            this.write(`${color.g},`);
            this.write(`${color.b}`);
            this.writeLine();
        }
    }
}

/**
 * An encoder for encoding a beatmap's timing points section.
 */
class BeatmapControlPointsEncoder extends BeatmapBaseEncoder {
    constructor() {
        super(...arguments);
        this.controlPointGroups = {};
    }
    encodeInternal() {
        var _a;
        if (this.map.controlPoints.timing.points.length === 0 &&
            this.map.controlPoints.difficulty.points.length === 0 &&
            this.map.controlPoints.effect.points.length === 0 &&
            this.map.controlPoints.sample.points.length === 0) {
            return;
        }
        if (this.encodeSections) {
            this.writeLine("[TimingPoints]");
        }
        // Since control points are scattered, we group them by time first.
        this.collectTimingControlPointInfo();
        this.collectDifficultyControlPointInfo();
        this.collectEffectControlPointInfo();
        this.collectSampleControlPointInfo();
        for (const group of Object.values(this.controlPointGroups).sort((a, b) => a.time - b.time)) {
            // If the group contains a timing control point, it needs to be output separately.
            if (group.timing) {
                this.write(`${group.timing.time},`);
                this.write(`${group.timing.msPerBeat},`);
                this.outputControlPointGroup(group, true);
            }
            // Output any remaining effects as secondary non-timing control point.
            this.write(`${group.time},`);
            const difficultyPoint = (_a = group.difficulty) !== null && _a !== void 0 ? _a : this.map.controlPoints.difficulty.controlPointAt(group.time);
            this.write(`${-100 / difficultyPoint.speedMultiplier},`);
            this.outputControlPointGroup(group, false);
        }
    }
    collectTimingControlPointInfo() {
        var _a, _b;
        for (const t of this.map.controlPoints.timing.points) {
            const group = (_a = this.controlPointGroups[t.time]) !== null && _a !== void 0 ? _a : { time: t.time };
            (_b = group.timing) !== null && _b !== void 0 ? _b : (group.timing = t);
            this.controlPointGroups[t.time] = group;
        }
    }
    collectDifficultyControlPointInfo() {
        var _a, _b;
        for (const t of this.map.controlPoints.difficulty.points) {
            const group = (_a = this.controlPointGroups[t.time]) !== null && _a !== void 0 ? _a : { time: t.time };
            (_b = group.difficulty) !== null && _b !== void 0 ? _b : (group.difficulty = t);
            this.controlPointGroups[t.time] = group;
        }
    }
    collectEffectControlPointInfo() {
        var _a, _b;
        for (const t of this.map.controlPoints.effect.points) {
            const group = (_a = this.controlPointGroups[t.time]) !== null && _a !== void 0 ? _a : { time: t.time };
            (_b = group.effect) !== null && _b !== void 0 ? _b : (group.effect = t);
            this.controlPointGroups[t.time] = group;
        }
    }
    collectSampleControlPointInfo() {
        var _a, _b;
        for (const t of this.map.controlPoints.sample.points) {
            const group = (_a = this.controlPointGroups[t.time]) !== null && _a !== void 0 ? _a : { time: t.time };
            (_b = group.sample) !== null && _b !== void 0 ? _b : (group.sample = t);
            this.controlPointGroups[t.time] = group;
        }
    }
    outputControlPointGroup(group, isTimingPoint) {
        var _a, _b, _c;
        const samplePoint = (_a = group.sample) !== null && _a !== void 0 ? _a : this.map.controlPoints.sample.controlPointAt(group.time);
        const effectPoint = (_b = group.effect) !== null && _b !== void 0 ? _b : this.map.controlPoints.effect.controlPointAt(group.time);
        // Convert effect flags.
        let effectFlags = EffectFlags.none;
        if (effectPoint.isKiai) {
            effectFlags |= EffectFlags.kiai;
        }
        if (effectPoint.omitFirstBarLine) {
            effectFlags |= EffectFlags.omitFirstBarLine;
        }
        this.write(`${((_c = group.timing) !== null && _c !== void 0 ? _c : this.map.controlPoints.timing.controlPointAt(group.time)).timeSignature},`);
        this.write(`${samplePoint.sampleBank.toString()},`);
        this.write(`${samplePoint.customSampleBank.toString()},`);
        this.write(`${samplePoint.sampleVolume.toString()},`);
        this.write(`${isTimingPoint ? "1" : "0"},`);
        this.write(effectFlags.toString());
        this.writeLine();
    }
}

/**
 * An encoder for encoding a beatmap's difficulty section.
 */
class BeatmapDifficultyEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[Difficulty]");
        }
        const { difficulty } = this.map;
        this.writeLine(`HPDrainRate: ${difficulty.hp}`);
        this.writeLine(`CircleSize: ${difficulty.cs}`);
        this.writeLine(`OverallDifficulty: ${difficulty.od}`);
        this.writeLine(`ApproachRate: ${difficulty.ar}`);
        this.writeLine(`SliderMultiplier: ${difficulty.sliderMultiplier}`);
        this.writeLine(`SliderTickRate: ${difficulty.sliderTickRate}`);
    }
}

/**
 * An encoder for encoding a beatmap's general section.
 */
class BeatmapEditorEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[Editor]");
        }
        const { editor } = this.map;
        if (editor.bookmarks.length > 0) {
            this.writeLine(editor.bookmarks.join());
        }
        this.writeLine(`DistanceSpacing: ${editor.distanceSnap}`);
        this.writeLine(`BeatDivisor: ${editor.beatDivisor}`);
        this.writeLine(`GridSize: ${editor.gridSize}`);
        this.writeLine(`TimelineZoom: ${editor.timelineZoom}`);
    }
}

/**
 * The base of per-section storyboard encoders.
 */
class StoryboardBaseEncoder extends BaseEncoder {
    constructor(storyboard, encodeSections = true) {
        super(encodeSections);
        this.storyboard = storyboard;
    }
}

/**
 * An encoder for encoding a storyboard's events section.
 */
class StoryboardEventsEncoder extends StoryboardBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[Events]");
        }
        this.writeLine("//Storyboard Layer 0 (Background)");
        this.encodeLayer(exports.StoryboardLayerType.background);
        this.writeLine("//Storyboard Layer 1 (Fail)");
        this.encodeLayer(exports.StoryboardLayerType.fail);
        this.writeLine("//Storyboard Layer 2 (Pass)");
        this.encodeLayer(exports.StoryboardLayerType.pass);
        this.writeLine("//Storyboard Layer 3 (Foreground)");
        this.encodeLayer(exports.StoryboardLayerType.foreground);
        this.writeLine("//Storyboard Layer 4 (Overlay)");
        this.encodeLayer(exports.StoryboardLayerType.overlay);
        this.writeLine("//Storyboard Sound Samples");
        this.encodeLayer(exports.StoryboardLayerType.sample);
    }
    write(line) {
        super.write(this.encodeVariables(line));
    }
    writeLine(line = "") {
        super.writeLine(this.encodeVariables(line));
    }
    encodeVariables(str) {
        for (const key in this.storyboard.variables) {
            str = str.replace(new RegExp(this.storyboard.variables[key], "g"), key);
        }
        return str;
    }
    encodeLayer(layerType) {
        var _a;
        const layer = this.storyboard.getLayer(layerType, false);
        for (const element of (_a = layer === null || layer === void 0 ? void 0 : layer.elements) !== null && _a !== void 0 ? _a : []) {
            // Checking for StoryboardAnimation first is mandatory as it extends StoryboardSprite.
            if (element instanceof StoryboardAnimation) {
                this.write(`${exports.StoryboardEventType.animation},`);
                this.write(`${layerType},`);
                this.write(`${element.origin},`);
                this.write(`"${element.path}",`);
                this.write(`${element.initialPosition},`);
                this.write(`${element.frameCount},`);
                this.write(`${element.frameDelay},`);
                this.writeLine(`${element.loopType}`);
                this.encodeElement(element);
            }
            else if (element instanceof StoryboardSprite) {
                this.write(`${exports.StoryboardEventType.sprite},`);
                this.write(`${layerType},`);
                this.write(`${element.origin},`);
                this.write(`"${element.path}",`);
                this.writeLine(`${element.initialPosition}`);
                this.encodeElement(element);
            }
            else if (element instanceof StoryboardSample) {
                this.write(`${exports.StoryboardEventType.sample},`);
                this.write(`${element.startTime},`);
                this.write(`${layerType},`);
                this.write(`"${element.path}",`);
                this.writeLine(`${element.volume}`);
            }
        }
    }
    encodeElement(element) {
        for (const loop of element.loops) {
            this.encodeTimelineGroup(loop);
        }
        this.encodeTimelineGroup(element.timelineGroup);
        for (const trigger of element.triggers) {
            this.encodeTimelineGroup(trigger);
        }
    }
    encodeTimelineGroup(group) {
        if (group instanceof CommandLoop) {
            this.write(" ");
            this.write(`${exports.StoryboardCommandType.loop},`);
            this.write(`${group.startTime},`);
            this.write(`${group.totalIterations}`);
        }
        else if (group instanceof CommandTrigger) {
            this.write(" ");
            this.write(`${exports.StoryboardCommandType.trigger},`);
            this.write(`${group.triggerName}`);
            if (group.triggerEndTime !== Number.MAX_SAFE_INTEGER) {
                this.write(",");
                this.write(`${group.triggerStartTime},`);
                this.write(`${group.triggerEndTime}`);
            }
            if (group.groupNumber !== 0) {
                this.write(",");
                this.write(`${group.groupNumber}`);
            }
        }
        this.encodeTimeline(group.alpha);
        this.encodeTimeline(group.blendingParameters);
        this.encodeTimeline(group.color);
        this.encodeTimeline(group.move);
        this.encodeTimeline(group.rotation);
        this.encodeTimeline(group.scale);
        this.encodeTimeline(group.vectorScale);
        this.encodeTimeline(group.x);
        this.encodeTimeline(group.y);
    }
    encodeTimeline(timeline) {
        for (const command of timeline.commands) {
            this.encodeCommand(command);
        }
    }
    encodeCommand(command) {
        this.write(" ");
        this.write(`${command.type},`);
        this.write(`${command.easing},`);
        this.write(`${command.startTime},`);
        this.write(command.startTime !== command.endTime ? `${command.endTime}` : "");
        this.write(",");
        if (command.startValue instanceof Vector2 &&
            command.endValue instanceof Vector2) {
            // Movement and vector scale commands
            this.write(command.startValue.toString());
            if (!command.startValue.equals(command.endValue)) {
                this.write(",");
                this.write(command.endValue.toString());
            }
        }
        else if (command.isParameter()) {
            // Parameter commands (blending, flip horizontal, and flip vertical)
            this.write(command.parameterType);
        }
        else if (command.startValue instanceof RGBColor &&
            command.endValue instanceof RGBColor) {
            // Color commands
            this.write(command.startValue.toString());
            if (!command.startValue.equals(command.endValue)) {
                this.write(",");
                this.write(command.endValue.toString());
            }
        }
        else if (typeof command.startValue === "number" &&
            typeof command.endValue === "number") {
            // Move X, move Y, scale, fade, and rotation commands
            if (command.type === exports.StoryboardCommandType.rotation) {
                this.write(MathUtils.degreesToRadians(command.startValue).toString());
            }
            else {
                this.write(command.startValue.toString());
            }
            if (command.startValue !== command.endValue) {
                this.write(",");
                if (command.type === exports.StoryboardCommandType.rotation) {
                    this.write(MathUtils.degreesToRadians(command.endValue).toString());
                }
                else {
                    this.write(command.endValue.toString());
                }
            }
        }
        this.writeLine();
    }
}

/**
 * An encoder for encoding a beatmap's events section.
 */
class StoryboardVariablesEncoder extends StoryboardBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[Variables]");
        }
        for (const key in this.storyboard.variables) {
            this.writeLine(`${key}=${this.storyboard.variables[key]}`);
        }
    }
}

/**
 * A storyboard encoder.
 *
 * Note that this storyboard encoder does not encode storyboards, and as such equality with the
 * original beatmap or storyboard file is not guaranteed (and usually will not be equal).
 */
class StoryboardEncoder extends Encoder {
    constructor(target, encodeSections = true) {
        super(target);
        this.finalResult = "";
        this.encoders = [];
        this.encodeSections = encodeSections;
    }
    reset() {
        this.finalResult = "";
        this.encoders = [
            // The variable decoder is put first as variables need to be on top of a .osb file.
            new StoryboardVariablesEncoder(this.target, this.encodeSections),
            new StoryboardEventsEncoder(this.target, this.encodeSections),
        ];
    }
}

/**
 * An encoder for encoding a beatmap's events section.
 */
class BeatmapEventsEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[Events]");
        }
        this.writeLine("//Background and Video Events");
        const { events } = this.map;
        if (events.background) {
            this.writeLine(`0,0,"${events.background.filename}",${events.background.offset.x},${events.background.offset.y}`);
        }
        if (events.video) {
            this.writeLine(`Video,${events.video.startTime},"${events.video.filename}",${events.video.offset.x},${events.video.offset.y}`);
        }
        this.writeLine("//Break Periods");
        for (const b of events.breaks) {
            this.writeLine(`2,${b.startTime},${b.endTime}`);
        }
        if (this.map.events.storyboard) {
            this.writeLine(new StoryboardEncoder(this.map.events.storyboard, false).encode().result);
        }
        else {
            this.writeLine("//Storyboard Layer 0 (Background)");
            this.writeLine("//Storyboard Layer 1 (Fail)");
            this.writeLine("//Storyboard Layer 2 (Pass)");
            this.writeLine("//Storyboard Layer 3 (Foreground)");
            this.writeLine("//Storyboard Layer 4 (Overlay)");
            this.writeLine("//Storyboard Sound Samples");
        }
    }
}

/**
 * An encoder for encoding a beatmap's general section.
 */
class BeatmapGeneralEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[General]");
        }
        const { general } = this.map;
        if (general.audioFilename) {
            this.writeLine(`AudioFilename: ${general.audioFilename}`);
        }
        this.writeLine(`AudioLeadIn: ${general.audioLeadIn}`);
        this.writeLine(`PreviewTime: ${general.previewTime}`);
        this.writeLine(`Countdown: ${general.countdown}`);
        this.writeLine(`SampleSet: ${this.sampleBankToString(general.sampleBank)}`);
        this.writeLine(`StackLeniency: ${general.stackLeniency}`);
        this.writeLine(`Mode: ${general.mode}`);
        this.writeLine(`LetterboxInBreaks: ${general.letterBoxInBreaks ? 1 : 0}`);
        if (general.epilepsyWarning) {
            this.writeLine("EpilepsyWarning: 1");
        }
        if (general.countdownOffset > 0) {
            this.writeLine(`CountdownOffset: ${general.countdownOffset}`);
        }
        this.writeLine(`WidescreenStoryboard: ${general.widescreenStoryboard ? 1 : 0}`);
        if (general.samplesMatchPlaybackRate) {
            this.writeLine("SamplesMatchPlaybackRate: 1");
        }
    }
}

/**
 * An encoder for encoding a beatmap's hit objects section.
 */
class BeatmapHitObjectsEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        if (this.encodeSections) {
            this.writeLine("[HitObjects]");
        }
        for (const hitObject of this.map.hitObjects.objects) {
            this.encodeHitObject(hitObject);
        }
    }
    encodeHitObject(object) {
        this.write(`${object.position.x},`);
        this.write(`${object.position.y},`);
        this.write(`${object.startTime},`);
        this.write(`${object.type},`);
        this.write(`${this.samplesToHitSoundType(object.samples).toString()},`);
        if (object instanceof Slider) {
            this.addSliderPath(object);
            this.write(this.getSampleBank(object.samples));
        }
        else {
            if (object instanceof Spinner) {
                this.write(`${object.endTime},`);
            }
            this.write(this.getSampleBank(object.samples));
        }
        this.writeLine();
    }
    samplesToHitSoundType(samples) {
        let type = exports.HitSoundType.none;
        for (const sample of samples) {
            if (sample instanceof BankHitSampleInfo) {
                switch (sample.name) {
                    case BankHitSampleInfo.HIT_WHISTLE:
                        type |= exports.HitSoundType.whistle;
                        break;
                    case BankHitSampleInfo.HIT_FINISH:
                        type |= exports.HitSoundType.finish;
                        break;
                    case BankHitSampleInfo.HIT_CLAP:
                        type |= exports.HitSoundType.clap;
                        break;
                }
            }
        }
        return type;
    }
    addSliderPath(slider) {
        // curveType
        this.write(slider.path.pathType + "|");
        // curvePoints
        // Skip the first control point as it is right on the
        // start position of the slider.
        for (let i = 1; i < slider.path.controlPoints.length; ++i) {
            const realPosition = slider.path.controlPoints[i].add(slider.position);
            this.write(`${realPosition.x}:${realPosition.y}`);
            this.write(i != slider.path.controlPoints.length - 1 ? "|" : ",");
        }
        this.write(`${slider.repeatCount + 1},`);
        this.write(`${slider.path.expectedDistance},`);
        // edgeSamples
        for (let i = 0; i < slider.nodeSamples.length; ++i) {
            this.write(this.samplesToHitSoundType(slider.nodeSamples[i]).toString());
            this.write(i != slider.nodeSamples.length - 1 ? "|" : ",");
        }
        // edgeSets
        for (let i = 0; i < slider.nodeSamples.length; ++i) {
            this.write(this.getSampleBank(slider.nodeSamples[i], true));
            this.write(i != slider.nodeSamples.length - 1 ? "|" : ",");
        }
    }
    getSampleBank(samples, banksOnly = false) {
        var _a, _b, _c, _d, _e;
        const normalBank = (_b = (_a = samples.find((s) => s instanceof BankHitSampleInfo &&
            s.name === BankHitSampleInfo.HIT_NORMAL)) === null || _a === void 0 ? void 0 : _a.bank) !== null && _b !== void 0 ? _b : exports.SampleBank.none;
        const addBank = (_d = (_c = samples.find((s) => s instanceof BankHitSampleInfo &&
            s.name &&
            s.name !== BankHitSampleInfo.HIT_NORMAL)) === null || _c === void 0 ? void 0 : _c.bank) !== null && _d !== void 0 ? _d : exports.SampleBank.none;
        let sampleBankString = `${normalBank}:${addBank}`;
        if (!banksOnly) {
            const firstSample = samples[0];
            sampleBankString += ":";
            sampleBankString += `${firstSample instanceof BankHitSampleInfo
                ? firstSample.customSampleBank
                : 0}:`;
            sampleBankString += `${(_e = firstSample === null || firstSample === void 0 ? void 0 : firstSample.volume) !== null && _e !== void 0 ? _e : 100}:`;
            if (firstSample instanceof FileHitSampleInfo) {
                sampleBankString += `${this.sampleBankToString(exports.SampleBank.none)}-${firstSample.filename}`;
            }
        }
        return sampleBankString;
    }
    sampleBankToString(sampleBank) {
        switch (sampleBank) {
            case exports.SampleBank.none:
                return "";
            default:
                return super.sampleBankToString(sampleBank);
        }
    }
}

/**
 * An encoder for encoding a beatmap's metadata section.
 */
class BeatmapMetadataEncoder extends BeatmapBaseEncoder {
    encodeInternal() {
        var _a, _b;
        if (this.encodeSections) {
            this.writeLine("[Metadata]");
        }
        const { metadata } = this.map;
        this.writeLine(`Title: ${metadata.title}`);
        if (metadata.titleUnicode) {
            this.writeLine(`TitleUnicode: ${metadata.titleUnicode}`);
        }
        this.writeLine(`Artist: ${metadata.artist}`);
        if (metadata.artistUnicode) {
            this.writeLine(`ArtistUnicode: ${metadata.artistUnicode}`);
        }
        this.writeLine(`Creator: ${metadata.creator}`);
        this.writeLine(`Version: ${metadata.version}`);
        if (metadata.source) {
            this.writeLine(`Source: ${metadata.source}`);
        }
        if (metadata.tags.length > 0) {
            this.writeLine(`Tags: ${metadata.tags.join(" ")}`);
        }
        if (((_a = metadata.beatmapId) !== null && _a !== void 0 ? _a : -1) > 0) {
            this.writeLine(`BeatmapID: ${metadata.beatmapId}`);
        }
        if (((_b = metadata.beatmapSetId) !== null && _b !== void 0 ? _b : -1) > 0) {
            this.writeLine(`BeatmapSetID: ${metadata.beatmapSetId}`);
        }
    }
}

/**
 * A beatmap encoder.
 *
 * Note that this beatmap encoder does not encode storyboards, and as such equality with the
 * original beatmap file is not guaranteed (and usually will not be equal).
 */
class BeatmapEncoder extends Encoder {
    constructor() {
        super(...arguments);
        this.encoders = [];
        this.latestVersion = 14;
    }
    encodeInternal() {
        this.writeLine(`osu file format v${this.latestVersion}`);
        this.writeLine();
        super.encodeInternal();
    }
    /**
     * Resets this encoder's instance.
     */
    reset() {
        this.finalResult = "";
        this.encoders = [
            new BeatmapGeneralEncoder(this.target),
            new BeatmapEditorEncoder(this.target),
            new BeatmapMetadataEncoder(this.target),
            new BeatmapDifficultyEncoder(this.target),
            new BeatmapEventsEncoder(this.target),
            new BeatmapControlPointsEncoder(this.target),
            new BeatmapColorEncoder(this.target),
            new BeatmapHitObjectsEncoder(this.target),
        ];
    }
}

/**
 * Available genres in an online osu! beatmap.
 */
exports.BeatmapGenre = void 0;
(function (BeatmapGenre) {
    BeatmapGenre[BeatmapGenre["any"] = 0] = "any";
    BeatmapGenre[BeatmapGenre["unspecified"] = 1] = "unspecified";
    BeatmapGenre[BeatmapGenre["videoGame"] = 2] = "videoGame";
    BeatmapGenre[BeatmapGenre["anime"] = 3] = "anime";
    BeatmapGenre[BeatmapGenre["rock"] = 4] = "rock";
    BeatmapGenre[BeatmapGenre["pop"] = 5] = "pop";
    BeatmapGenre[BeatmapGenre["other"] = 6] = "other";
    BeatmapGenre[BeatmapGenre["novelty"] = 7] = "novelty";
    BeatmapGenre[BeatmapGenre["hipHop"] = 9] = "hipHop";
    BeatmapGenre[BeatmapGenre["electronic"] = 10] = "electronic";
    BeatmapGenre[BeatmapGenre["metal"] = 11] = "metal";
    BeatmapGenre[BeatmapGenre["classical"] = 12] = "classical";
    BeatmapGenre[BeatmapGenre["folk"] = 13] = "folk";
    BeatmapGenre[BeatmapGenre["jazz"] = 14] = "jazz";
})(exports.BeatmapGenre || (exports.BeatmapGenre = {}));

/**
 * Available languages in an online osu! beatmap.
 */
exports.BeatmapLanguage = void 0;
(function (BeatmapLanguage) {
    BeatmapLanguage[BeatmapLanguage["any"] = 0] = "any";
    BeatmapLanguage[BeatmapLanguage["unspecified"] = 1] = "unspecified";
    BeatmapLanguage[BeatmapLanguage["english"] = 2] = "english";
    BeatmapLanguage[BeatmapLanguage["japanese"] = 3] = "japanese";
    BeatmapLanguage[BeatmapLanguage["chinese"] = 4] = "chinese";
    BeatmapLanguage[BeatmapLanguage["instrumental"] = 5] = "instrumental";
    BeatmapLanguage[BeatmapLanguage["korean"] = 6] = "korean";
    BeatmapLanguage[BeatmapLanguage["french"] = 7] = "french";
    BeatmapLanguage[BeatmapLanguage["german"] = 8] = "german";
    BeatmapLanguage[BeatmapLanguage["swedish"] = 9] = "swedish";
    BeatmapLanguage[BeatmapLanguage["spanish"] = 10] = "spanish";
    BeatmapLanguage[BeatmapLanguage["italian"] = 11] = "italian";
    BeatmapLanguage[BeatmapLanguage["russian"] = 12] = "russian";
    BeatmapLanguage[BeatmapLanguage["polish"] = 13] = "polish";
    BeatmapLanguage[BeatmapLanguage["other"] = 14] = "other";
})(exports.BeatmapLanguage || (exports.BeatmapLanguage = {}));

class ZeroCrossingBracketing {
    /**
     * Detect a range containing at least one root.
     *
     * This iterative method stops when two values with opposite signs are found.
     *
     * @param f The function to detect roots from.
     * @param bounds The upper and lower value of the range.
     * @param factor The growing factor of research. Defaults to 1.6.
     * @param maxIterations Maximum number of iterations. Defaults to 50.
     * @returns Whether the bracketing operation succeeded.
     */
    static expand(f, bounds, factor = 1.6, maxIterations = 50) {
        const originalUpperBound = bounds.upperBound;
        const originalLowerBound = bounds.lowerBound;
        if (originalLowerBound >= originalUpperBound) {
            throw new RangeError("Upper bound must be greater than lower bound.");
        }
        let fmin = f(originalLowerBound);
        let fmax = f(originalUpperBound);
        for (let i = 0; i < maxIterations; ++i) {
            if (Math.sign(fmin) !== Math.sign(fmax)) {
                return true;
            }
            if (Math.abs(fmin) < Math.abs(fmax)) {
                bounds.lowerBound +=
                    factor * (bounds.lowerBound - bounds.upperBound);
                fmin = f(bounds.lowerBound);
            }
            else {
                bounds.upperBound +=
                    factor * (bounds.upperBound - bounds.lowerBound);
                fmax = f(bounds.upperBound);
            }
        }
        bounds.lowerBound = originalLowerBound;
        bounds.upperBound = originalUpperBound;
        return false;
    }
    static reduce(f, bounds, subdivisions = 1000) {
        const originalUpperBound = bounds.upperBound;
        const originalLowerBound = bounds.lowerBound;
        if (originalLowerBound >= originalUpperBound) {
            throw new RangeError("Upper bound must be greater than lower bound.");
        }
        // TODO: Consider binary-style search instead of linear scan
        const fmin = f(bounds.lowerBound);
        const fmax = f(bounds.upperBound);
        if (Math.sign(fmin) != Math.sign(fmax)) {
            return true;
        }
        const subdiv = (bounds.upperBound - bounds.lowerBound) / subdivisions;
        let smin = bounds.lowerBound;
        const sign = Math.sign(fmin);
        for (let i = 0; i < subdivisions; ++i) {
            const smax = smin + subdiv;
            const sfmax = f(smax);
            if (!Number.isFinite(sfmax)) {
                // expand interval to include pole
                smin = smax;
                continue;
            }
            if (Math.sign(sfmax) != sign) {
                bounds.upperBound = smax;
                bounds.lowerBound = smin;
                return true;
            }
            smin = smax;
        }
        bounds.lowerBound = originalLowerBound;
        bounds.upperBound = originalUpperBound;
        return false;
    }
    static expandReduce(f, bounds, expansionFactor = 1.6, expansionMaxIterations = 50, reduceSubdivisions = 100) {
        return (this.expand(f, bounds, expansionFactor, expansionMaxIterations) ||
            this.reduce(f, bounds, reduceSubdivisions));
    }
}

/**
 * Algorithm by Brent, Van Wijngaarden, Dekker et al.
 *
 * Implementation inspired by Press, Teukolsky, Vetterling, and Flannery, "Numerical Recipes in C", 2nd edition, Cambridge University Press.
 */
class Brent {
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Defaults to 1e-8. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Defaults to 100.
     * @param expandFactor The factor at which to expand the bounds, if needed. Defaults to 1.6.
     * @param maxExpandIterations The maximum number of expand iterations. Defaults to 100.
     * @returns The root with the specified accuracy. Throws an error if the algorithm failed to converge.
     */
    static findRootExpand(f, bounds, accuracy = 1e-8, maxIterations = 100, expandFactor = 1.6, maxExpandIterations = 100) {
        ZeroCrossingBracketing.expandReduce(f, bounds, expandFactor, maxExpandIterations, maxExpandIterations * 10);
        return this.findRoot(f, bounds, accuracy, maxIterations);
    }
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Defaults to 1e-8. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Defaults to 100.
     * @returns The root with the specified accuracy. Throws an error if the algorithm failed to converge.
     */
    static findRoot(f, bounds, accuracy = 1e-8, maxIterations = 100) {
        const root = this.tryFindRoot(f, bounds, accuracy, maxIterations);
        if (root === null) {
            throw new Error("The algorithm has failed, exceeded the number of iterations allowed or there is no root within the provided bounds.");
        }
        return root;
    }
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Usually 100.
     * @returns The root with the specified accuracy, `null` if not found.
     */
    static tryFindRoot(f, bounds, accuracy, maxIterations) {
        if (accuracy <= 0) {
            throw new RangeError("Accuracy must be greater than 0.");
        }
        let { lowerBound, upperBound } = bounds;
        let fmin = f(lowerBound);
        let fmax = f(upperBound);
        let froot = fmax;
        let d = 0;
        let e = 0;
        let root = upperBound;
        let xMid = Number.NaN;
        // Root must be bracketed.
        if (Math.sign(fmin) === Math.sign(fmax)) {
            return null;
        }
        for (let i = 0; i <= maxIterations; ++i) {
            // Adjust bounds.
            if (Math.sign(froot) === Math.sign(fmax)) {
                upperBound = lowerBound;
                fmax = fmin;
                e = d = root - lowerBound;
            }
            if (Math.abs(fmax) < Math.abs(froot)) {
                lowerBound = root;
                root = upperBound;
                upperBound = lowerBound;
                fmin = froot;
                froot = fmax;
                fmax = fmin;
            }
            // Convergence check
            const xAcc1 = 2 * Math.pow(2, -53) * Math.abs(root) + accuracy / 2;
            const xMidOld = xMid;
            xMid = (upperBound - root) / 2;
            if (Math.abs(xMid) <= xAcc1 ||
                Precision.almostEqualNormRelative(froot, 0, froot, accuracy)) {
                return root;
            }
            if (xMid === xMidOld) {
                // accuracy not sufficient, but cannot be improved further
                return null;
            }
            if (Math.abs(e) >= xAcc1 && Math.abs(fmin) > Math.abs(froot)) {
                // Attempt inverse quadratic interpolation
                const s = froot / fmin;
                let p;
                let q;
                if (Precision.almostEqualRelative(lowerBound, upperBound)) {
                    p = 2 * xMid * s;
                    q = 1 - s;
                }
                else {
                    q = fmin / fmax;
                    const r = froot / fmax;
                    p =
                        s *
                            (2 * xMid * q * (q - r) -
                                (root - lowerBound) * (r - 1));
                    q = (q - 1) * (r - 1) * (s - 1);
                }
                if (p > 0) {
                    // Check whether in bounds
                    q = -q;
                }
                p = Math.abs(p);
                if (2 * p <
                    Math.min(3 * xMid * q - Math.abs(xAcc1 * q), Math.abs(e * q))) {
                    // Accept interpolation
                    e = d;
                    d = p / q;
                }
                else {
                    // Interpolation failed, use bisection
                    d = xMid;
                    e = d;
                }
            }
            else {
                // Bounds decreasing too slowly, use bisection
                d = xMid;
                e = d;
            }
            lowerBound = root;
            fmin = froot;
            if (Math.abs(d) > xAcc1) {
                root += d;
            }
            else {
                root += this.sign(xAcc1, xMid);
            }
            froot = f(root);
        }
        return null;
    }
    /**
     * Helper method useful for preventing rounding errors.
     *
     * @returns a * sign(b)
     */
    static sign(a, b) {
        return b >= 0 ? (a >= 0 ? a : -a) : a >= 0 ? -a : a;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * The base of API request builders.
 */
class APIRequestBuilder {
    constructor() {
        /**
         * Whether or not to include the API key in the request URL.
         */
        this.requiresAPIkey = true;
        /**
         * The endpoint of this builder.
         */
        this.endpoint = "";
        /**
         * The parameters of this builder.
         */
        this.params = new Map();
        this.fetchAttempts = 0;
    }
    /**
     * The base URL of this builder.
     */
    get baseURL() {
        return this.host + this.endpoint;
    }
    /**
     * Sets the API endpoint.
     *
     * @param endpoint The endpoint to set.
     */
    setEndpoint(endpoint) {
        this.endpoint = endpoint;
        return this;
    }
    /**
     * Sets if this builder includes the API key in the request URL.
     *
     * @param requireAPIkey Whether or not to include the API key in the request URL.
     */
    setRequireAPIkey(requireAPIkey) {
        this.requiresAPIkey = requireAPIkey;
        return this;
    }
    /**
     * Builds the URL to request the API.
     */
    buildURL() {
        let url = this.baseURL + "?";
        if (this.requiresAPIkey) {
            if (!this.APIkey) {
                throw new Error("An API key has not been specified");
            }
            url += this.APIkeyParam;
        }
        for (const [param, value] of this.params.entries()) {
            url += `${param}=${encodeURIComponent(value)}&`;
        }
        return url;
    }
    /**
     * Sends a request to the API using built parameters.
     *
     * If the request fails, it will be redone 5 times.
     */
    sendRequest() {
        return new Promise((resolve) => {
            const url = this.buildURL();
            fetch(url)
                .then((res) => __awaiter(this, void 0, void 0, function* () {
                ++this.fetchAttempts;
                if (res.status >= 500 && this.fetchAttempts < 5) {
                    console.error(`Request to ${url} failed with the following error: ${yield res.text()}; ${this.fetchAttempts} attempts so far; retrying`);
                    return resolve(this.sendRequest());
                }
                this.fetchAttempts = 0;
                return resolve({
                    data: Buffer.from(yield res.arrayBuffer()),
                    statusCode: res.status,
                });
            }))
                .catch((e) => {
                console.error(`Request to ${url} failed with the following error: ${e.message}; ${this.fetchAttempts} attempts so far; aborting`);
                this.fetchAttempts = 0;
                return resolve({
                    data: Buffer.from([]),
                    statusCode: 400,
                });
            });
        });
    }
    /**
     * Adds a parameter to the builder.
     *
     * @param param The parameter to add.
     * @param value The value to add for the parameter.
     */
    addParameter(param, value) {
        this.params.set(param, value.toString());
        return this;
    }
    /**
     * Removes a parameter from the builder.
     *
     * @param param The parameter to remove.
     */
    removeParameter(param) {
        this.params.delete(param);
        return this;
    }
}

/**
 * An API request builder for osu!droid.
 */
class DroidAPIRequestBuilder extends APIRequestBuilder {
    constructor() {
        super(...arguments);
        this.host = "https://osudroid.moe/api/";
        this.APIkey = DroidAPIRequestBuilder.apiKey;
        this.APIkeyParam = `apiKey=${this.APIkey}&`;
    }
    /**
     * Sets the API key for all subsequent initializations of a `DroidAPIRequestBuilder`.
     *
     * @param key The API key.
     */
    static setAPIKey(key) {
        this.apiKey = key;
    }
    buildURL() {
        switch (this.endpoint) {
            case "upload":
            case "bestpp": {
                let url = this.baseURL + "/";
                for (const [, value] of this.params.entries()) {
                    url += encodeURIComponent(value);
                }
                return url;
            }
            default:
                return super.buildURL();
        }
    }
}
DroidAPIRequestBuilder.apiKey = "";

/**
 * A set of utilities to handle legacy mods storage conversion to the new storage format in osu!droid.
 */
class DroidLegacyModConverter {
    /**
     * Converts a legacy mod string to an array of `Mod`s.
     *
     * @param str The mod string to convert.
     * @param difficulty The `BeatmapDifficulty` to use for `IMigratableDroidMod` migrations. When omitted, `IMigratableDroidMod`s will not be migrated.
     * @returns An array of `Mod`s.
     */
    static convert(str, difficulty) {
        const map = new ModMap();
        if (!str) {
            return map;
        }
        const data = str.split("|");
        for (const c of data[0]) {
            const modType = this.legacyStorableMods.get(c);
            if (!modType) {
                continue;
            }
            const mod = new modType();
            if (mod.isMigratableDroidMod() && difficulty) {
                map.set(mod.migrateDroidMod(difficulty));
            }
            else {
                map.set(mod);
            }
        }
        if (data.length > 1) {
            this.parseExtraModString(map, data.slice(1));
        }
        return map;
    }
    /**
     * Parses the extra strings of a mod string.
     *
     * @param map The current `Mod`s.
     * @param extraStrings The extra strings to parse.
     */
    static parseExtraModString(map, extraStrings) {
        let customCS;
        let customAR;
        let customOD;
        let customHP;
        for (const s of extraStrings) {
            switch (true) {
                // Forced stats
                case s.startsWith("CS"):
                    customCS = parseFloat(s.slice(2));
                    break;
                case s.startsWith("AR"):
                    customAR = parseFloat(s.slice(2));
                    break;
                case s.startsWith("OD"):
                    customOD = parseFloat(s.slice(2));
                    break;
                case s.startsWith("HP"):
                    customHP = parseFloat(s.slice(2));
                    break;
                // FL follow delay
                case s.startsWith("FLD"): {
                    let flashlight = map.get(ModFlashlight);
                    if (!flashlight) {
                        flashlight = new ModFlashlight();
                        map.set(flashlight);
                    }
                    flashlight.followDelay.value = parseFloat(s.slice(3));
                    break;
                }
                // Speed multiplier
                case s.startsWith("x"): {
                    let customSpeed = map.get(ModCustomSpeed);
                    if (!customSpeed) {
                        customSpeed = new ModCustomSpeed();
                        map.set(customSpeed);
                    }
                    customSpeed.trackRateMultiplier.value = parseFloat(s.slice(1));
                    break;
                }
            }
        }
        if (customCS !== undefined ||
            customAR !== undefined ||
            customOD !== undefined ||
            customHP !== undefined) {
            map.set(new ModDifficultyAdjust({
                cs: customCS,
                ar: customAR,
                od: customOD,
                hp: customHP,
            }));
        }
    }
}
/**
 * All `Mod`s that can be stored in the legacy mods format by their respective encode character.
 */
DroidLegacyModConverter.legacyStorableMods = new Map([
    ["a", ModAuto],
    ["b", ModTraceable],
    ["c", ModNightCore],
    ["d", ModDoubleTime],
    ["e", ModEasy],
    ["f", ModPerfect],
    ["h", ModHidden],
    ["i", ModFlashlight],
    ["l", ModReallyEasy],
    ["m", ModSmallCircle],
    ["n", ModNoFail],
    ["p", ModAutopilot],
    ["r", ModHardRock],
    ["s", ModPrecise],
    ["t", ModHalfTime],
    ["u", ModSuddenDeath],
    ["v", ModScoreV2],
    ["x", ModRelax],
]);

/**
 * A single-variable polynomial with real-valued coefficients and non-negative exponents.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
class Polynomial {
    /**
     * Evaluates a polynomial at point `z`.
     *
     * Coefficients are ordered ascending by power with power `k` at index `k`.
     * For example, coefficients `[3, -1, 2]` represent `y = 2x^2 - x + 3`.
     *
     * @param z The location where to evaluate the polynomial at.
     * @param coefficients The coefficients of the polynomial, coefficient for power `k` at index `k`.
     * @returns The polynomial at `z`.
     */
    static evaluate(z, coefficients) {
        // Zero polynomials need explicit handling, otherwise we
        // will attempt to peek coefficients at negative indices.
        if (coefficients.length === 0) {
            return 0;
        }
        let sum = coefficients.at(-1);
        for (let i = coefficients.length - 2; i >= 0; --i) {
            sum *= z;
            sum += coefficients[i];
        }
        return sum;
    }
}

/**
 * A Math utility class containing all methods related to the error function.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
class ErrorFunction {
    //#endregion
    //#region Evaluations
    /**
     * Calculates the error function evaluated at `x`.
     *
     * @param x The value to evaluate.
     * @returns The error function evaluated at `x`, or:
     * - 1 if `x == Number.POSITIVE_INFINITY`;
     * - -1 if `x == Number.NEGATIVE_INFINITY`.
     */
    static erf(x) {
        if (x === 0) {
            return 0;
        }
        if (x === Number.POSITIVE_INFINITY) {
            return 1;
        }
        if (x === Number.NEGATIVE_INFINITY) {
            return -1;
        }
        if (Number.isNaN(x)) {
            return Number.NaN;
        }
        return this.erfImp(x, false);
    }
    /**
     * Calculates the complementary error function evaluated at `x`.
     *
     * @param x The value to evaluate.
     * @returns The complementary error function evaluated at `x`, or:
     * - 0 if `x === Number.POSITIVE_INFINITY`;
     * - 2 if `x === Number.NEGATIVE_INFINITY`.
     */
    static erfc(x) {
        if (x === 0) {
            return 1;
        }
        if (x === Number.POSITIVE_INFINITY) {
            return 0;
        }
        if (x === Number.NEGATIVE_INFINITY) {
            return 2;
        }
        if (Number.isNaN(x)) {
            return Number.NaN;
        }
        return this.erfImp(x, true);
    }
    /**
     * Calculates the inverse error function evaluated at `z`.
     *
     * @param z The value to evaluate.
     * @returns The inverse error function evaluated at `z`, or:
     * - `Number.POSITIVE_INFINITY` if `z >= 1`;
     * - `Number.NEGATIVE_INFINITY` if `z <= -1`.
     */
    static erfInv(z) {
        if (z === 0) {
            return 0;
        }
        if (z >= 1) {
            return Number.POSITIVE_INFINITY;
        }
        if (z <= -1) {
            return Number.NEGATIVE_INFINITY;
        }
        if (Number.isNaN(z)) {
            return Number.NaN;
        }
        let p;
        let q;
        let s;
        if (z < 0) {
            p = -z;
            q = 1 - p;
            s = -1;
        }
        else {
            p = z;
            q = 1 - z;
            s = 1;
        }
        return this.erfInvImp(p, q, s);
    }
    /**
     * Calculates the complementary inverse error function evaluated at `z`.
     *
     * This implementation has been tested against the arbitrary precision mpmath library
     * and found cases where only 9 significant figures correct can be guaranteed.
     *
     * @param z The value to evaluate.
     * @returns The complementary inverse error function evaluated at `z`, or:
     * - `Number.POSITIVE_INFINITY` if `z <= 0`;
     * - `Number.NEGATIVE_INFINITY` if `z >= -2`.
     */
    static erfcInv(z) {
        if (z <= 0) {
            return Number.POSITIVE_INFINITY;
        }
        if (z >= 2) {
            return Number.NEGATIVE_INFINITY;
        }
        if (Number.isNaN(z)) {
            return Number.NaN;
        }
        let p;
        let q;
        let s;
        if (z > 1) {
            q = 2 - z;
            p = 1 - q;
            s = -1;
        }
        else {
            p = 1 - z;
            q = z;
            s = 1;
        }
        return this.erfInvImp(p, q, s);
    }
    /**
     * The implementation of the error function.
     *
     * @param z Where to evaluate the error function.
     * @param invert Whether to compute 1 - the error function.
     * @returns The error function.
     */
    static erfImp(z, invert) {
        if (z < 0) {
            if (!invert) {
                return -this.erfImp(-z, false);
            }
            if (z < -0.5) {
                return 2 - this.erfImp(-z, true);
            }
            return 1 + this.erfImp(-z, false);
        }
        let result;
        // Big bunch of selection statements now to pick which
        // implementation to use, try to put most likely options
        // first:
        if (z < 0.5) {
            // We're going to calculate erf:
            if (z < 1e-10) {
                result = z * 1.125 + z * 0.003379167095512574;
            }
            else {
                // Worst case absolute error found: 6.688618532e-21
                result =
                    z * 1.125 +
                        (z * Polynomial.evaluate(z, this.erfImpAn)) /
                            Polynomial.evaluate(z, this.erfImpAd);
            }
        }
        else if (z < 110) {
            // We'll be calculating erfc:
            invert = !invert;
            let r;
            let b;
            switch (true) {
                case z < 0.75:
                    // Worst case absolute error found: 5.582813374e-21
                    r =
                        Polynomial.evaluate(z - 0.5, this.erfImpBn) /
                            Polynomial.evaluate(z - 0.5, this.erfImpBd);
                    b = 0.3440242112;
                    break;
                case z < 1.25:
                    // Worst case absolute error found: 4.01854729e-21
                    r =
                        Polynomial.evaluate(z - 0.75, this.erfImpCn) /
                            Polynomial.evaluate(z - 0.75, this.erfImpCd);
                    b = 0.419990927;
                    break;
                case z < 2.25:
                    // Worst case absolute error found: 2.866005373e-21
                    r =
                        Polynomial.evaluate(z - 1.25, this.erfImpDn) /
                            Polynomial.evaluate(z - 1.25, this.erfImpDd);
                    b = 0.4898625016;
                    break;
                case z < 3.5:
                    // Worst case absolute error found: 1.045355789e-21
                    r =
                        Polynomial.evaluate(z - 2.25, this.erfImpEn) /
                            Polynomial.evaluate(z - 2.25, this.erfImpEd);
                    b = 0.5317370892;
                    break;
                case z < 5.25:
                    // Worst case absolute error found: 8.300028706e-22
                    r =
                        Polynomial.evaluate(z - 3.5, this.erfImpFn) /
                            Polynomial.evaluate(z - 3.5, this.erfImpFd);
                    b = 0.5489973426;
                    break;
                case z < 8:
                    // Worst case absolute error found: 1.700157534e-21
                    r =
                        Polynomial.evaluate(z - 5.25, this.erfImpGn) /
                            Polynomial.evaluate(z - 5.25, this.erfImpGd);
                    b = 0.5571740866;
                    break;
                case z < 11.5:
                    // Worst case absolute error found: 3.002278011e-22
                    r =
                        Polynomial.evaluate(z - 8, this.erfImpHn) /
                            Polynomial.evaluate(z - 8, this.erfImpHd);
                    b = 0.5609807968;
                    break;
                case z < 17:
                    // Worst case absolute error found: 6.741114695e-21
                    r =
                        Polynomial.evaluate(z - 11.5, this.erfImpIn) /
                            Polynomial.evaluate(z - 11.5, this.erfImpId);
                    b = 0.5626493692;
                    break;
                case z < 24:
                    // Worst case absolute error found: 7.802346984e-22
                    r =
                        Polynomial.evaluate(z - 17, this.erfImpJn) /
                            Polynomial.evaluate(z - 17, this.erfImpJd);
                    b = 0.5634598136;
                    break;
                case z < 38:
                    // Worst case absolute error found: 2.414228989e-22
                    r =
                        Polynomial.evaluate(z - 24, this.erfImpKn) /
                            Polynomial.evaluate(z - 24, this.erfImpKd);
                    b = 0.5638477802;
                    break;
                case z < 60:
                    // Worst case absolute error found: 5.896543869e-24
                    r =
                        Polynomial.evaluate(z - 38, this.erfImpLn) /
                            Polynomial.evaluate(z - 38, this.erfImpLd);
                    b = 0.5640528202;
                    break;
                case z < 85:
                    // Worst case absolute error found: 3.080612264e-21
                    r =
                        Polynomial.evaluate(z - 60, this.erfImpMn) /
                            Polynomial.evaluate(z - 60, this.erfImpMd);
                    b = 0.5641309023;
                    break;
                default:
                    // Worst case absolute error found: 8.094633491e-22
                    r =
                        Polynomial.evaluate(z - 85, this.erfImpNn) /
                            Polynomial.evaluate(z - 85, this.erfImpNd);
                    b = 0.5641584396;
            }
            const g = Math.exp(-z * z) / z;
            result = g * (b + r);
        }
        else {
            // Any value of z larger than 28 will underflow to zero:
            result = 0;
            invert = !invert;
        }
        if (invert) {
            result = 1 - result;
        }
        return result;
    }
    /**
     * The implementation of the inverse error function.
     *
     * @param p The first intermediate parameter.
     * @param q The second intermediate parameter.
     * @param s The third intermediate parameter.
     * @returns The inverse error function.
     */
    static erfInvImp(p, q, s) {
        let result;
        if (p <= 0.5) {
            // Evaluate inverse erf using the rational approximation:
            //
            // x = p(p+10)(Y+R(p))
            //
            // Where Y is a constant, and R(p) is optimized for a low
            // absolute error compared to |Y|.
            //
            // double: Max error found: 2.001849e-18
            // long double: Max error found: 1.017064e-20
            // Maximum Deviation Found (actual error term at infinite precision) 8.030e-21
            const y = 0.0891314744949340820313;
            const g = p * (p + 10);
            const r = Polynomial.evaluate(p, this.ervInvImpAn) /
                Polynomial.evaluate(p, this.ervInvImpAd);
            result = g * (y + r);
        }
        else if (q >= 0.25) {
            // Rational approximation for 0.5 > q >= 0.25
            //
            // x = sqrt(-2*log(q)) / (Y + R(q))
            //
            // Where Y is a constant, and R(q) is optimized for a low
            // absolute error compared to Y.
            //
            // double : Max error found: 7.403372e-17
            // long double : Max error found: 6.084616e-20
            // Maximum Deviation Found (error term) 4.811e-20
            const y = 2.249481201171875;
            const g = Math.sqrt(-2 * Math.log(q));
            const xs = q - 0.25;
            const r = Polynomial.evaluate(xs, this.ervInvImpBn) /
                Polynomial.evaluate(xs, this.ervInvImpBd);
            result = g / (y + r);
        }
        else {
            // For q < 0.25 we have a series of rational approximations all
            // of the general form:
            //
            // let: x = sqrt(-log(q))
            //
            // Then the result is given by:
            //
            // x(Y+R(x-B))
            //
            // where Y is a constant, B is the lowest value of x for which
            // the approximation is valid, and R(x-B) is optimized for a low
            // absolute error compared to Y.
            //
            // Note that almost all code will really go through the first
            // or maybe second approximation.  After than we're dealing with very
            // small input values indeed: 80 and 128 bit long double's go all the
            // way down to ~ 1e-5000 so the "tail" is rather long...
            const x = Math.sqrt(-Math.log(q));
            let y;
            let r;
            switch (true) {
                case x < 3: {
                    // Max error found: 1.089051e-20
                    y = 0.807220458984375;
                    const xs = x - 1.125;
                    r =
                        Polynomial.evaluate(xs, this.ervInvImpCn) /
                            Polynomial.evaluate(xs, this.ervInvImpCd);
                    break;
                }
                case x < 6: {
                    // Max error found: 8.389174e-21
                    y = 0.93995571136474609375;
                    const xs = x - 3;
                    r =
                        Polynomial.evaluate(xs, this.ervInvImpDn) /
                            Polynomial.evaluate(xs, this.ervInvImpDd);
                    break;
                }
                case x < 18: {
                    // Max error found: 1.481312e-19
                    y = 0.98362827301025390625;
                    const xs = x - 6;
                    r =
                        Polynomial.evaluate(xs, this.ervInvImpEn) /
                            Polynomial.evaluate(xs, this.ervInvImpEd);
                    break;
                }
                case x < 44: {
                    // Max error found: 5.697761e-20
                    y = 0.99714565277099609375;
                    const xs = x - 18;
                    r =
                        Polynomial.evaluate(xs, this.ervInvImpFn) /
                            Polynomial.evaluate(xs, this.ervInvImpFd);
                    break;
                }
                default: {
                    // Max error found: 1.279746e-20
                    y = 0.99941349029541015625;
                    const xs = x - 44;
                    r =
                        Polynomial.evaluate(xs, this.ervInvImpGn) /
                            Polynomial.evaluate(xs, this.ervInvImpGd);
                }
            }
            result = x * (y + r);
        }
        return s * result;
    }
}
//#region Coefficients for erfImp
/**
 * Polynomial coefficients for a numerator of erfImp
 * calculation for erf(x) in the interval [1e-10, 0.5].
 */
ErrorFunction.erfImpAn = [
    0.003379167095512574, -0.0007369565304816795, -0.37473233739291961,
    0.0817442448733587, -0.04210893199365486, 0.007016570951209576,
    -0.004950912559824351, 0.0008716465990379225,
];
/**
 * Polynomial coefficients for a denominator of erfImp
 * calculation for erf(x) in the interval [1e-10, 0.5].
 */
ErrorFunction.erfImpAd = [
    1, -0.2180882180879246, 0.4125429727254421, -0.08418911478731068,
    0.0655338856400242, -0.01200196044549418, 0.00408165558926174,
    -0.0006159007215577697,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculationfor erfc(x) in the interval [0.5, 0.75].
 */
ErrorFunction.erfImpBn = [
    -0.03617903907182625, 0.29225188344488268, 0.2814470417976045,
    0.12561020886276694, 0.02741350282689305, 0.002508396721680658,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for Erfc(x) in the interval [0.5, 0.75].
 */
ErrorFunction.erfImpBd = [
    1, 1.8545005897903486, 1.43575803037831418, 0.58282765875303655,
    0.1248104769329497, 0.011372417654635328,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [0.75, 1.25].
 */
ErrorFunction.erfImpCn = [
    -0.03978768926111369, 0.15316521246787829, 0.19126029560093624,
    0.10276327061989304, 0.029637090615738836, 0.004609348678027549,
    0.0003076078203486802,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [0.75, 1.25].
 */
ErrorFunction.erfImpCd = [
    1, 1.955200729876277, 1.6476231719938486, 0.7682386070221263,
    0.20979318593650978, 0.03195693168999134, 0.0021336316089578537,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [1.25, 2.25].
 */
ErrorFunction.erfImpDn = [
    -0.030083856055794972, 0.05385788298444545, 0.07262115416519142,
    0.03676284698880493, 0.009646290155725275, 0.0013345348007529107,
    0.778087599782504e-4,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [1.25, 2.25].
 */
ErrorFunction.erfImpDd = [
    1, 1.7596709814716753, 1.3288357143796112, 0.5525285965087576,
    0.1337930569413329, 0.017950964517628076, 0.001047124400199374,
    -0.10664038182035734e-7,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [2.25, 3.5].
 */
ErrorFunction.erfImpEn = [
    -0.011790757013722784, 0.01426213209053881, 0.02022344359029608,
    0.00930668299990432, 0.0021335780242206599, 0.000250229873864601,
    0.1205349122195882e-4,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [2.25, 3.5].
 */
ErrorFunction.erfImpEd = [
    1, 1.5037622520362048, 0.9653977862044629, 0.3392652304767967,
    0.068974064954157, 0.0077106026249176831, 0.0003714211015310693,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [3.5, 5.25].
 */
ErrorFunction.erfImpFn = [
    -0.005469547955387293, 0.004041902787317071, 0.0054963369553161171,
    0.002126164726039454, 0.0003949840144950839, 0.36556547706444238e-4,
    0.13548589710993232e-5,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [3.5, 5.25].
 */
ErrorFunction.erfImpFd = [
    1, 1.210196977736308, 0.6209146682211439, 0.1730384306611428,
    0.0276550813773432, 0.002406259744243097, 0.8918118172513366e-4,
    -0.4655288362833827e-11,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [5.25, 8].
 */
ErrorFunction.erfImpGn = [
    -0.002707225359057783, 0.00131875634250294, 0.0011992593326100233,
    0.00027849619811344664, 0.2678229882183318e-4, 0.9230436723150282e-6,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [5.25, 8].
 */
ErrorFunction.erfImpGd = [
    1, 0.8146328085431416, 0.26890166585629954, 0.04498772161030411,
    0.003817596633202485, 0.0001315718978885969, 0.4048153596757641e-11,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [8, 11.5].
 */
ErrorFunction.erfImpHn = [
    -0.001099467206917422, 0.00040642544275042267, 0.0002744994894169007,
    0.4652937706466594e-4, 0.320955425395767463e-5, 0.778286018145021e-7,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [8, 11.5].
 */
ErrorFunction.erfImpHd = [
    1, 0.588173710611846, 0.13936333128940975, 0.016632934041708368,
    0.0010002392131023491, 0.2425483752158723e-4,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [11.5, 17].
 */
ErrorFunction.erfImpIn = [
    -0.0005690799360109496, 0.0001694985403737623, 0.5184723545811009e-4,
    0.38281931223192885e-5, 0.8249899312818944e-7,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [11.5, 17].
 */
ErrorFunction.erfImpId = [
    1, 0.3396372500511393, 0.04347264787031066, 0.002485493352246371,
    0.5356333053371529e-4, -0.11749094440545958e-12,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [17, 24].
 */
ErrorFunction.erfImpJn = [
    -0.000241313599483991337, 0.5742249752025015e-4, 0.11599896292738377e-4,
    0.581762134402594e-6, 0.8539715550856736e-8,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [17, 24].
 */
ErrorFunction.erfImpJd = [
    1, 0.23304413829968784, 0.02041869405464403, 0.0007971856475643983,
    0.11701928167017232e-4,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [24, 38].
 */
ErrorFunction.erfImpKn = [
    -0.00014667469927776036, 0.1626665521122805e-4, 0.26911624850916523e-5,
    0.979584479468092e-7, 0.10199464762572346e-8,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [24, 38].
 */
ErrorFunction.erfImpKd = [
    1, 0.16590781294484722, 0.010336171619150588, 0.0002865930263738684,
    0.29840157084090034e-5,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [38, 60].
 */
ErrorFunction.erfImpLn = [
    -0.5839057976297718e-4, 0.4125103251054962e-5, 0.43179092242025094e-6,
    0.9933651555900132e-8, 0.653480510020105e-10,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [38, 60].
 */
ErrorFunction.erfImpLd = [
    1, 0.1050770860720399, 0.004142784286754756, 0.726338754644524e-4,
    0.477818471047398785e-6,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [60, 85].
 */
ErrorFunction.erfImpMn = [
    -0.196457797609229579e-4, 0.1572438876668007e-5, 0.5439025111927009e-7,
    0.3174724923691177e-9,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [60, 85].
 */
ErrorFunction.erfImpMd = [
    1, 0.05280398924095763, 0.0009268760691517533, 0.5410117232266303e-5,
    0.5350938458036424e-15,
];
/**
 * Polynomial coefficients for a numerator in erfImp
 * calculation for erfc(x) in the interval [85, 110].
 */
ErrorFunction.erfImpNn = [
    -0.789224703978723e-5, 0.622088451660987e-6, 0.1457284456768824e-7,
    0.603715505542715e-10,
];
/**
 * Polynomial coefficients for a denominator in erfImp
 * calculation for erfc(x) in the interval [85, 110].
 */
ErrorFunction.erfImpNd = [
    1, 0.037532884635629371, 0.0004679195359746253, 0.19384703927584565e-5,
];
//#endregion
//#region Coefficients for erfInvImp
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0, 0.5].
 */
ErrorFunction.ervInvImpAn = [
    -0.0005087819496582806, -0.0083687481974173677, 0.033480662540974461,
    -0.012692614766297402, -0.03656379714117627, 0.02198786811111689,
    0.008226878746769157, -0.005387729650712429,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0, 0.5].
 */
ErrorFunction.ervInvImpAd = [
    1, -0.9700050433032906, -1.565745582341758, 1.5622155839842302,
    0.662328840472003, -0.7122890234154285, -0.05273963823400997,
    0.079528368734157168, -0.0023339375937419, 0.0008862163904564247,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.5, 0.75].
 */
ErrorFunction.ervInvImpBn = [
    -0.2024335083559388, 0.10526468069939171, 8.3705032834312,
    17.6447298408374, -18.85106480587143, -44.6382324441787,
    17.445385985570866, 21.12946554483405, -3.671922547077293,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.5, 0.75].
 */
ErrorFunction.ervInvImpBd = [
    1, 6.24264124854247537, 3.9713437953343869, -28.66081804998,
    -20.14326346804852, 48.56092131087399, 10.82686673554602,
    -22.64369334131397, 1.7211476576120028,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x less than 3.
 */
ErrorFunction.ervInvImpCn = [
    -0.1311027816799519, -0.1637940471933171, 0.11703015634199525,
    0.387079738972604337, 0.3377855389120359, 0.1428695344081572,
    0.029015791000532906, 0.002145589953888053, -0.6794655751811264e-6,
    0.2852253317822171e-7, -0.681149956853777e-9,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x less than 3.
 */
ErrorFunction.ervInvImpCd = [
    1, 3.466254072425672, 5.381683457070069, 4.778465929458438,
    2.5930192162362027, 0.848854343457902, 0.1522643382953318,
    0.01105924229346489,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 3 and 6.
 */
ErrorFunction.ervInvImpDn = [
    -0.0350353787183178, -0.002224265292134479, 0.018557330651423107,
    0.009508047013259196, 0.001871234928195592, 0.00015754461742496055,
    0.460469890584318e-5, -0.2304047769118826e-9, 0.266339227425782e-11,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 3 and 6.
 */
ErrorFunction.ervInvImpDd = [
    1, 1.365334981755406, 0.7620591645536234, 0.22009110576413124,
    0.03415891436709477, 0.00263861676657016, 0.7646752923027944e-4,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 6 and 18.
 */
ErrorFunction.ervInvImpEn = [
    -0.016743100507663373, -0.001129514387455803, 0.001056288621524929,
    0.0002093863174875881, 0.14962478375834237e-4, 0.4496967899277065e-6,
    0.4625961635228786e-8, -0.281128735628831791e-13,
    0.9905570997331033e-16,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 6 and 18.
 */
ErrorFunction.ervInvImpEd = [
    1, 0.5914293448864175, 0.1381518657490833, 0.01607460870936765,
    0.0009640118070051655, 0.275335474764726e-4, 0.282243172016108e-6,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 18 and 44.
 */
ErrorFunction.ervInvImpFn = [
    -0.0024978212791898131, -0.779190719229054e-5, 0.2547230374130275e-4,
    0.1623977773425109e-5, 0.3963410113048011685e-7, 0.4116328311909442e-9,
    0.145596286718675e-11, -0.11676501239718427e-17,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x between 18 and 44.
 */
ErrorFunction.ervInvImpFd = [
    1, 0.20712311221442251, 0.01694108381209759, 0.0006905382656226846,
    0.14500735981823264e-4, 0.14443775662814415e-6, 0.5097612765997785e-9,
];
/**
 * Polynomial coefficients for a numerator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x greater than 44.
 */
ErrorFunction.ervInvImpGn = [
    -0.0005390429110190786, -0.2839875900472772e-6, 0.8994651148922914e-6,
    0.2293458592659209e-7, 0.2255614448635001e-9, 0.9478466275030226e-12,
    0.13588013010892486e-14, -0.3488903933999489e-21,
];
/**
 * Polynomial coefficients for a denominator of erfInvImp
 * calculation for erf^-1(z) in the interval [0.75, 1] with x greater than 44.
 */
ErrorFunction.ervInvImpGd = [
    1, 0.08457462340018994, 0.002820929847262647, 0.4682929219408942e-4,
    0.3999688121938621e-6, 0.1618092908879045e-8, 0.2315586083102596e-11,
];

/**
 * Ranking status of a beatmap.
 */
exports.RankedStatus = void 0;
(function (RankedStatus) {
    RankedStatus[RankedStatus["graveyard"] = -2] = "graveyard";
    RankedStatus[RankedStatus["wip"] = -1] = "wip";
    RankedStatus[RankedStatus["pending"] = 0] = "pending";
    RankedStatus[RankedStatus["ranked"] = 1] = "ranked";
    RankedStatus[RankedStatus["approved"] = 2] = "approved";
    RankedStatus[RankedStatus["qualified"] = 3] = "qualified";
    RankedStatus[RankedStatus["loved"] = 4] = "loved";
})(exports.RankedStatus || (exports.RankedStatus = {}));

/**
 * An API request builder for osu!standard.
 */
class OsuAPIRequestBuilder extends APIRequestBuilder {
    constructor() {
        super(...arguments);
        this.host = "https://osu.ppy.sh/api/";
        this.APIkey = OsuAPIRequestBuilder.apiKey;
        this.APIkeyParam = `k=${this.APIkey}&`;
    }
    /**
     * Sets the API key for all subsequent initializations of an `OsuAPIRequestBuilder`.
     *
     * @param key The API key.
     */
    static setAPIKey(key) {
        this.apiKey = key;
    }
}
OsuAPIRequestBuilder.apiKey = "";

/**
 * Represents a beatmap with general information.
 */
class MapInfo {
    constructor() {
        /**
         * The title of the song of the beatmap.
         */
        this.title = "";
        /**
         * The artist of the song of the beatmap.
         */
        this.artist = "";
        /**
         * The creator of the beatmap.
         */
        this.creator = "";
        /**
         * The user ID of the creator of the beatmap.
         */
        this.creatorId = 0;
        /**
         * The difficulty name of the beatmap.
         */
        this.version = "";
        /**
         * The source of the song, if any.
         */
        this.source = "";
        /**
         * The ranking status of the beatmap.
         */
        this.approved = exports.RankedStatus.pending;
        /**
         * The ID of the beatmap.
         */
        this.beatmapId = 0;
        /**
         * The ID of the beatmapset containing the beatmap.
         */
        this.beatmapSetId = 0;
        /**
         * The amount of times the beatmap has been played.
         */
        this.plays = 0;
        /**
         * The amount of times this beatmap has been passed.
         */
        this.passes = 0;
        /**
         * The amount of times the beatmap has been favorited.
         */
        this.favorites = 0;
        /**
         * The user rating of this beatmap.
         */
        this.rating = 0;
        /**
         * The date of which the beatmap was submitted.
         */
        this.submitDate = new Date(0);
        /**
         * The date of which this beatmap was approved.
         */
        this.approvedDate = null;
        /**
         * The date of which the beatmap was last updated.
         */
        this.lastUpdate = new Date(0);
        /**
         * The duration of the beatmap not including breaks.
         */
        this.hitLength = 0;
        /**
         * The duration of the beatmap including breaks.
         */
        this.totalLength = 0;
        /**
         * The genre of this beatmap.
         */
        this.genre = exports.BeatmapGenre.any;
        /**
         * The language of this beatmap.
         */
        this.language = exports.BeatmapLanguage.any;
        /**
         * The BPM of the beatmap.
         */
        this.bpm = 0;
        /**
         * The amount of circles in the beatmap.
         */
        this.circles = 0;
        /**
         * The amount of sliders in the beatmap.
         */
        this.sliders = 0;
        /**
         * The amount of spinners in the beatmap.
         */
        this.spinners = 0;
        /**
         * The maximum combo of the beatmap.
         */
        this.maxCombo = null;
        /**
         * The circle size of the beatmap.
         */
        this.cs = 0;
        /**
         * The approach rate of the beatmap.
         */
        this.ar = 0;
        /**
         * The overall difficulty of the beatmap.
         */
        this.od = 0;
        /**
         * The health drain rate of the beatmap.
         */
        this.hp = 0;
        /**
         * The beatmap packs that contain this beatmap, represented by their ID.
         */
        this.packs = [];
        /**
         * The tags of this beatmap.
         */
        this.tags = [];
        /**
         * The aim difficulty rating of the beatmap.
         */
        this.aimDifficulty = null;
        /**
         * The speed difficulty rating of the beatmap.
         */
        this.speedDifficulty = null;
        /**
         * The generic difficulty rating of the beatmap.
         */
        this.totalDifficulty = null;
        /**
         * The MD5 hash of the beatmap.
         */
        this.hash = "";
        /**
         * Whether this beatmap has a storyboard.
         */
        this.storyboardAvailable = false;
        /**
         * Whether this beatmap has a video.
         */
        this.videoAvailable = false;
        /**
         * Whether the download for this beatmap is available.
         *
         * The download of a beatmap may not be available due to old beatmap, etc.
         */
        this.downloadAvailable = true;
        /**
         * Whether the audio of this beatmap is available.
         *
         * The audio of a beatmap may not be available due to DMCA takedown, etc.
         */
        this.audioAvailable = true;
        this.cachedBeatmap = null;
    }
    /**
     * The full title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     */
    get fullTitle() {
        return `${this.artist} - ${this.title} (${this.creator}) [${this.version}]`;
    }
    /**
     * The amount of objects in the beatmap.
     */
    get objects() {
        return this.circles + this.sliders + this.spinners;
    }
    /**
     * The decoded beatmap from beatmap decoder.
     */
    get beatmap() {
        return this.cachedBeatmap;
    }
    /**
     * The osu! site link to this beatmap.
     */
    get beatmapLink() {
        return `https://osu.ppy.sh/b/${this.beatmapId}`;
    }
    /**
     * The osu! site link to this beatmapset.
     */
    get beatmapSetLink() {
        return `https://osu.ppy.sh/s/${this.beatmapSetId}`;
    }
    static getInformation(beatmapIdOrHash, downloadBeatmap) {
        return __awaiter(this, void 0, void 0, function* () {
            const apiRequestBuilder = new OsuAPIRequestBuilder()
                .setEndpoint("get_beatmaps")
                .addParameter(typeof beatmapIdOrHash === "string" ? "h" : "b", beatmapIdOrHash);
            const result = yield apiRequestBuilder.sendRequest();
            if (result.statusCode !== 200) {
                throw new Error("osu! API error");
            }
            const mapinfo = JSON.parse(result.data.toString("utf-8"))[0];
            if (!mapinfo) {
                return null;
            }
            if (parseInt(mapinfo.mode) !== 0) {
                return null;
            }
            const map = this.from(mapinfo);
            if (downloadBeatmap !== false) {
                yield map.retrieveBeatmapFile();
            }
            return map;
        });
    }
    static from(mapinfo, parsedBeatmap) {
        const map = new MapInfo();
        const parseDate = (str) => {
            const t = str.split(/[- :]/).map((e) => parseInt(e));
            return new Date(Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5]));
        };
        map.title = mapinfo.title;
        map.artist = mapinfo.artist;
        map.creator = mapinfo.creator;
        map.creatorId = parseInt(mapinfo.creator_id);
        map.version = mapinfo.version;
        map.source = mapinfo.source;
        map.approved = parseInt(mapinfo.approved);
        map.beatmapId = parseInt(mapinfo.beatmap_id);
        map.beatmapSetId = parseInt(mapinfo.beatmapset_id);
        map.plays = parseInt(mapinfo.playcount);
        map.passes = parseInt(mapinfo.passcount);
        map.favorites = parseInt(mapinfo.favourite_count);
        map.rating = parseFloat(mapinfo.rating);
        map.lastUpdate = parseDate(mapinfo.last_update);
        map.submitDate = parseDate(mapinfo.submit_date);
        map.approvedDate = mapinfo.approved_date
            ? parseDate(mapinfo.approved_date)
            : null;
        map.hitLength = parseInt(mapinfo.hit_length);
        map.totalLength = parseInt(mapinfo.total_length);
        map.genre = parseInt(mapinfo.genre_id);
        map.language = parseInt(mapinfo.language_id);
        map.bpm = parseFloat(mapinfo.bpm);
        map.circles = mapinfo.count_normal ? parseInt(mapinfo.count_normal) : 0;
        map.sliders = mapinfo.count_slider ? parseInt(mapinfo.count_slider) : 0;
        map.spinners = mapinfo.count_spinner
            ? parseInt(mapinfo.count_spinner)
            : 0;
        map.maxCombo =
            mapinfo.max_combo !== null ? parseInt(mapinfo.max_combo) : null;
        map.cs = parseFloat(mapinfo.diff_size);
        map.ar = parseFloat(mapinfo.diff_approach);
        map.od = parseFloat(mapinfo.diff_overall);
        map.hp = parseFloat(mapinfo.diff_drain);
        if (mapinfo.packs) {
            map.packs = mapinfo.packs.split(",").map((pack) => pack.trim());
        }
        map.tags = mapinfo.tags.split(" ");
        map.aimDifficulty = mapinfo.diff_aim
            ? parseFloat(mapinfo.diff_aim)
            : null;
        map.speedDifficulty = mapinfo.diff_speed
            ? parseFloat(mapinfo.diff_speed)
            : null;
        map.totalDifficulty = mapinfo.difficultyrating
            ? parseFloat(mapinfo.difficultyrating)
            : null;
        map.hash = mapinfo.file_md5;
        map.storyboardAvailable = !!parseInt(mapinfo.storyboard);
        map.videoAvailable = !!parseInt(mapinfo.video);
        map.downloadAvailable = !parseInt(mapinfo.download_unavailable);
        map.audioAvailable = !parseInt(mapinfo.audio_unavailable);
        if (parsedBeatmap) {
            map.cachedBeatmap = parsedBeatmap;
        }
        return map;
    }
    /**
     * Converts this `MapInfo` to its raw API response.
     *
     * @returns The raw API response represented by this `MapInfo`.
     */
    toAPIResponse() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const padDateNumber = (num) => num.toString().padStart(2, "0");
        const convertDate = (date) => `${date.getUTCFullYear()}-${padDateNumber(date.getUTCMonth() + 1)}-${padDateNumber(date.getUTCDate())} ${padDateNumber(date.getUTCHours())}:${padDateNumber(date.getUTCMinutes())}:${padDateNumber(date.getUTCSeconds())}`;
        return {
            approved: this.approved.toString(),
            submit_date: convertDate(this.submitDate),
            approved_date: this.approvedDate
                ? convertDate(this.approvedDate)
                : null,
            last_update: convertDate(this.lastUpdate),
            artist: this.artist,
            beatmap_id: this.beatmapId.toString(),
            beatmapset_id: this.beatmapSetId.toString(),
            bpm: this.bpm.toString(),
            creator: this.creator.toString(),
            creator_id: this.creatorId.toString(),
            difficultyrating: (_b = (_a = this.totalDifficulty) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,
            diff_aim: (_d = (_c = this.aimDifficulty) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : null,
            diff_speed: (_f = (_e = this.speedDifficulty) === null || _e === void 0 ? void 0 : _e.toString()) !== null && _f !== void 0 ? _f : null,
            diff_size: this.cs.toString(),
            diff_overall: this.od.toString(),
            diff_approach: this.ar.toString(),
            diff_drain: this.hp.toString(),
            hit_length: this.hitLength.toString(),
            source: this.source.toString(),
            genre_id: this.genre.toString(),
            language_id: this.language.toString(),
            title: this.title.toString(),
            total_length: this.totalLength.toString(),
            version: this.version.toString(),
            file_md5: this.hash.toString(),
            // Guaranteed to be osu!standard for the time being.
            mode: "0",
            tags: this.tags.join(" "),
            favourite_count: this.favorites.toString(),
            rating: this.rating.toString(),
            playcount: this.plays.toString(),
            passcount: this.passes.toString(),
            count_normal: this.circles.toString(),
            count_slider: this.sliders.toString(),
            count_spinner: this.spinners.toString(),
            max_combo: (_h = (_g = this.maxCombo) === null || _g === void 0 ? void 0 : _g.toString()) !== null && _h !== void 0 ? _h : null,
            storyboard: this.storyboardAvailable ? "1" : "0",
            video: this.videoAvailable ? "1" : "0",
            download_unavailable: this.downloadAvailable ? "0" : "1",
            audio_unavailable: this.audioAvailable ? "0" : "1",
            packs: this.packs.join(" ") || null,
        };
    }
    /**
     * Checks whether the beatmap file has been downloaded.
     */
    hasDownloadedBeatmap() {
        return this.cachedBeatmap !== null;
    }
    /**
     * Retrieves the .osu file of the beatmap.
     *
     * After this, you can use the `hasDownloadedBeatmap` method to check if the beatmap has been downloaded.
     *
     * @param force Whether to download the file regardless if it's already available.
     */
    retrieveBeatmapFile(force) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasDownloadedBeatmap() && !force) {
                return;
            }
            const url = `https://osu.ppy.sh/osu/${this.beatmapId}`;
            return fetch(url)
                .then((res) => __awaiter(this, void 0, void 0, function* () {
                const text = yield res.text();
                if (res.status >= 500) {
                    throw new Error(text);
                }
                this.cachedBeatmap = new BeatmapDecoder().decode(text).result;
            }))
                .catch((e) => {
                console.error(`Request to ${url} failed with the following error: ${e.message}; aborting`);
            });
        });
    }
    /**
     * Sets the parsed beatmap that is associated with this `MapInfo`.
     *
     * This is used as an alternative to downloading the beatmap file in case the beatmap file already exists locally.
     *
     * @param beatmap The beatmap to associate with this `MapInfo`.
     */
    setBeatmap(beatmap) {
        this.cachedBeatmap = beatmap;
    }
    /**
     * Returns a string representative of the class.
     */
    toString() {
        return `${this.fullTitle}\nCS: ${this.cs} - AR: ${this.ar} - OD: ${this.od} - HP: ${this.hp}\nBPM: ${this.bpm} - Length: ${this.hitLength}/${this.totalLength} - Max Combo: ${this.maxCombo}\nLast Update: ${this.lastUpdate}`;
    }
}

/**
 * Represents the "old" `ModNightCore`.
 *
 * This mod is used solely for osu!droid difficulty calculation of replays with version 3 or older. The reason behind this
 * is a bug that was patched in replay version 4, where all audio that did not have 44100Hz frequency would slow down.
 *
 * After some testing, it was discovered that such replays were played at 1.39x speed instead of 1.5x, which is
 * represented by this mod.
 */
class ModOldNightCore extends ModNightCore {
    constructor() {
        super();
        this.trackRateMultiplier.value = 1.39;
    }
    calculateDroidScoreMultiplier() {
        return 1.12;
    }
}

/**
 * Continuous Univariate Normal distribution, also known as Gaussian distribution.
 *
 * For details about this distribution, see {@link http://en.wikipedia.org/wiki/Normal_distribution Wikipedia - Normal distribution}.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
class NormalDistribution {
    /**
     * Computes the inverse of the cumulative distribution function (InvCDF) for the distribution
     * at the given probability. This is also known as the quantile or percent point function.
     *
     * @param mean The mean (μ) of the normal distribution.
     * @param stdDev The standard deviation (σ) of the normal distribution. Range: σ ≥ 0.
     * @param p The location at which to compute the inverse cumulative density.
     * @returns The inverse cumulative density at `p`.
     */
    static invCDF(mean, stdDev, p) {
        if (stdDev < 0) {
            throw new RangeError("Invalid parametrization for the distribution.");
        }
        return mean - stdDev * Math.SQRT2 * ErrorFunction.erfcInv(2 * p);
    }
}

exports.Accuracy = Accuracy;
exports.BankHitSampleInfo = BankHitSampleInfo;
exports.Beatmap = Beatmap;
exports.BeatmapBackground = BeatmapBackground;
exports.BeatmapColor = BeatmapColor;
exports.BeatmapControlPoints = BeatmapControlPoints;
exports.BeatmapConverter = BeatmapConverter;
exports.BeatmapDecoder = BeatmapDecoder;
exports.BeatmapDifficulty = BeatmapDifficulty;
exports.BeatmapEditor = BeatmapEditor;
exports.BeatmapEncoder = BeatmapEncoder;
exports.BeatmapEvents = BeatmapEvents;
exports.BeatmapGeneral = BeatmapGeneral;
exports.BeatmapHitObjects = BeatmapHitObjects;
exports.BeatmapMetadata = BeatmapMetadata;
exports.BeatmapProcessor = BeatmapProcessor;
exports.BeatmapVideo = BeatmapVideo;
exports.BlendingParameters = BlendingParameters;
exports.BooleanModSetting = BooleanModSetting;
exports.BreakPoint = BreakPoint;
exports.Brent = Brent;
exports.Circle = Circle;
exports.CircleSizeCalculator = CircleSizeCalculator;
exports.Command = Command;
exports.CommandLoop = CommandLoop;
exports.CommandTimeline = CommandTimeline;
exports.CommandTimelineGroup = CommandTimelineGroup;
exports.CommandTrigger = CommandTrigger;
exports.ControlPointManager = ControlPointManager;
exports.DecimalModSetting = DecimalModSetting;
exports.DifficultyControlPoint = DifficultyControlPoint;
exports.DifficultyControlPointManager = DifficultyControlPointManager;
exports.DroidAPIRequestBuilder = DroidAPIRequestBuilder;
exports.DroidHitWindow = DroidHitWindow;
exports.DroidLegacyModConverter = DroidLegacyModConverter;
exports.DroidPlayableBeatmap = DroidPlayableBeatmap;
exports.EffectControlPoint = EffectControlPoint;
exports.EffectControlPointManager = EffectControlPointManager;
exports.EmptyHitWindow = EmptyHitWindow;
exports.ErrorFunction = ErrorFunction;
exports.FileHitSampleInfo = FileHitSampleInfo;
exports.HitObject = HitObject;
exports.HitObjectGenerationUtils = HitObjectGenerationUtils;
exports.HitSampleInfo = HitSampleInfo;
exports.HitWindow = HitWindow;
exports.IntegerModSetting = IntegerModSetting;
exports.Interpolation = Interpolation;
exports.MapInfo = MapInfo;
exports.MathUtils = MathUtils;
exports.Mod = Mod;
exports.ModApproachDifferent = ModApproachDifferent;
exports.ModAuto = ModAuto;
exports.ModAutopilot = ModAutopilot;
exports.ModCustomSpeed = ModCustomSpeed;
exports.ModDeflate = ModDeflate;
exports.ModDifficultyAdjust = ModDifficultyAdjust;
exports.ModDoubleTime = ModDoubleTime;
exports.ModEasy = ModEasy;
exports.ModFlashlight = ModFlashlight;
exports.ModFreezeFrame = ModFreezeFrame;
exports.ModGrow = ModGrow;
exports.ModHalfTime = ModHalfTime;
exports.ModHardRock = ModHardRock;
exports.ModHidden = ModHidden;
exports.ModMap = ModMap;
exports.ModMirror = ModMirror;
exports.ModMuted = ModMuted;
exports.ModNightCore = ModNightCore;
exports.ModNoFail = ModNoFail;
exports.ModObjectScaleTween = ModObjectScaleTween;
exports.ModOldNightCore = ModOldNightCore;
exports.ModPerfect = ModPerfect;
exports.ModPrecise = ModPrecise;
exports.ModRandom = ModRandom;
exports.ModRateAdjust = ModRateAdjust;
exports.ModReallyEasy = ModReallyEasy;
exports.ModRelax = ModRelax;
exports.ModReplayV6 = ModReplayV6;
exports.ModScoreV2 = ModScoreV2;
exports.ModSetting = ModSetting;
exports.ModSmallCircle = ModSmallCircle;
exports.ModSpunOut = ModSpunOut;
exports.ModSuddenDeath = ModSuddenDeath;
exports.ModTimeRamp = ModTimeRamp;
exports.ModTouchDevice = ModTouchDevice;
exports.ModTraceable = ModTraceable;
exports.ModUtil = ModUtil;
exports.ModWindDown = ModWindDown;
exports.ModWindUp = ModWindUp;
exports.NormalDistribution = NormalDistribution;
exports.NullableDecimalModSetting = NullableDecimalModSetting;
exports.NullableIntegerModSetting = NullableIntegerModSetting;
exports.NumberModSetting = NumberModSetting;
exports.OsuAPIRequestBuilder = OsuAPIRequestBuilder;
exports.OsuHitWindow = OsuHitWindow;
exports.OsuPlayableBeatmap = OsuPlayableBeatmap;
exports.PathApproximator = PathApproximator;
exports.PlayableBeatmap = PlayableBeatmap;
exports.Playfield = Playfield;
exports.Polynomial = Polynomial;
exports.PreciseDroidHitWindow = PreciseDroidHitWindow;
exports.Precision = Precision;
exports.RGBColor = RGBColor;
exports.Random = Random;
exports.RangeConstrainedModSetting = RangeConstrainedModSetting;
exports.SampleBankInfo = SampleBankInfo;
exports.SampleControlPoint = SampleControlPoint;
exports.SampleControlPointManager = SampleControlPointManager;
exports.SequenceHitSampleInfo = SequenceHitSampleInfo;
exports.Slider = Slider;
exports.SliderHead = SliderHead;
exports.SliderNestedHitObject = SliderNestedHitObject;
exports.SliderPath = SliderPath;
exports.SliderRepeat = SliderRepeat;
exports.SliderTail = SliderTail;
exports.SliderTick = SliderTick;
exports.Spinner = Spinner;
exports.Storyboard = Storyboard;
exports.StoryboardAnimation = StoryboardAnimation;
exports.StoryboardDecoder = StoryboardDecoder;
exports.StoryboardElement = StoryboardElement;
exports.StoryboardEncoder = StoryboardEncoder;
exports.StoryboardLayer = StoryboardLayer;
exports.StoryboardSample = StoryboardSample;
exports.StoryboardSprite = StoryboardSprite;
exports.TimedHitSampleInfo = TimedHitSampleInfo;
exports.TimingControlPoint = TimingControlPoint;
exports.TimingControlPointManager = TimingControlPointManager;
exports.Utils = Utils;
exports.Vector2 = Vector2;
exports.Vector4 = Vector4;
exports.ZeroCrossingBracketing = ZeroCrossingBracketing;
exports.normalize = normalize;
//# sourceMappingURL=index.js.map
