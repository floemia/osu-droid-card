interface AccuracyInformation {
    /**
     * The amount of objects in the beatmap.
     */
    nobjects?: number;
    /**
     * The accuracy achieved.
     */
    percent?: number;
    /**
     * The amount of 300s achieved.
     */
    n300?: number;
    /**
     * The amount of 100s achieved.
     */
    n100?: number;
    /**
     * The amount of 50s achieved.
     */
    n50?: number;
    /**
     * The amount of misses achieved.
     */
    nmiss?: number;
}
/**
 * An accuracy calculator that calculates accuracy based on given parameters.
 */
declare class Accuracy implements AccuracyInformation {
    n300: number;
    n100: number;
    n50: number;
    nmiss: number;
    /**
     * Calculates accuracy based on given parameters.
     *
     * If `percent` and `nobjects` are specified, `n300`, `n100`, and `n50` will
     * be automatically calculated to be the closest to the given
     * acc percent.
     *
     * @param values Function parameters.
     */
    constructor(values: AccuracyInformation);
    /**
     * Calculates the accuracy value (0.0 - 1.0).
     *
     * @param nobjects The amount of objects in the beatmap. If `n300` was not specified in the constructor, this is required.
     */
    value(nobjects?: number): number;
    /**
     * Determines whether this accuracy instance is equal to another instance.
     *
     * @param other The other accuracy instance.
     * @returns Whether both instances are equal.
     */
    equals(other: Accuracy): boolean;
}

/**
 * General enum to specify an "anchor" or "origin" point from the standard 9 points on a rectangle.
 */
declare enum Anchor {
    topLeft = "TopLeft",
    center = "Centre",
    centerLeft = "CentreLeft",
    topRight = "TopRight",
    bottomCenter = "BottomCentre",
    topCenter = "TopCentre",
    /**
     * The user is manually updating the outcome, so we shouldn't.
     */
    custom = "Custom",
    centerRight = "CentreRight",
    bottomLeft = "BottomLeft",
    bottomRight = "BottomRight"
}

/**
 * Defines available axes.
 */
declare enum Axes {
    /**
     * No axis.
     */
    none = 0,
    /**
     * The X axis.
     */
    x = 1,
    /**
     * The Y axis.
     */
    y = 2,
    /**
     * The X and Y axes.
     */
    both = 3
}

/**
 * The loop type of storyboard animations.
 */
declare enum AnimationLoopType {
    loopForever = "LoopForever",
    loopOnce = "LoopOnce"
}

/**
 * Represents available sample banks.
 */
declare enum SampleBank {
    none = 0,
    normal = 1,
    soft = 2,
    drum = 3
}

/**
 * Represents a gameplay hit sample.
 */
declare abstract class HitSampleInfo {
    /**
     * The sample volume.
     *
     * If this is 0, the control point's volume should be used instead.
     */
    readonly volume: number;
    /**
     * All possible filenames that can be used as an audio source, returned in order of preference (highest first).
     */
    abstract get lookupNames(): string[];
    constructor(volume?: number);
}

/**
 * Represents a pre-determined gameplay hit sample that can be loaded from banks.
 */
declare class BankHitSampleInfo extends HitSampleInfo {
    static readonly HIT_WHISTLE = "hitwhistle";
    static readonly HIT_FINISH = "hitfinish";
    static readonly HIT_NORMAL = "hitnormal";
    static readonly HIT_CLAP = "hitclap";
    /**
     * The name of the sample.
     */
    readonly name: string;
    /**
     * The bank to load the sample from.
     */
    readonly bank: SampleBank;
    /**
     * The index of the sample bank, if this sample bank uses custom samples.
     *
     * If this is 0, the control point's sample index should be used instead.
     */
    readonly customSampleBank: number;
    /**
     * Whether this hit sample is layered.
     *
     * Layered hit sample are automatically added in all modes (except osu!mania),
     * but can be disabled using the layered skin config option.
     */
    readonly isLayered: boolean;
    get lookupNames(): string[];
    constructor(name: string, bank?: SampleBank, customSampleBank?: number, volume?: number, isLayered?: boolean);
}

/**
 * Mode enum to switch things between osu!droid and osu!standard.
 */
declare enum Modes {
    droid = "droid",
    osu = "osu"
}

/**
 * Contains difficulty settings of a beatmap.
 */
declare class BeatmapDifficulty {
    /**
     * The approach rate of the beatmap.
     */
    private _ar?;
    /**
     * The approach rate of the beatmap.
     */
    get ar(): number;
    /**
     * The approach rate of the beatmap.
     */
    set ar(value: number);
    /**
     * The circle size of the beatmap.
     */
    cs: number;
    /**
     * The overall difficulty of the beatmap.
     */
    od: number;
    /**
     * The health drain rate of the beatmap.
     */
    hp: number;
    /**
     * The base slider velocity in hundreds of osu! pixels per beat.
     */
    sliderMultiplier: number;
    /**
     * The amount of slider ticks per beat.
     */
    sliderTickRate: number;
    /**
     * Maps a difficulty value [0, 10] to a two-piece linear range of values.
     *
     * @param difficulty The difficulty value to be mapped.
     * @param min Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param mid Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param max Maximum of the resulting range which will be achieved by a difficulty value of 10.
     */
    static difficultyRange(difficulty: number, min: number, mid: number, max: number): number;
    /**
     * Inverse function to `difficultyRange`. Maps a value returned by the function back to the
     * difficulty that produced it.
     *
     * @param difficultyValue The difficulty-dependent value to be unmapped.
     * @param diff0 Minimum of the resulting range which will be achieved by a difficulty value of 0.
     * @param diff5 Midpoint of the resulting range which will be achieved by a difficulty value of 5.
     * @param diff10 Maximum of the resulting range which will be achieved by a difficulty value of 10.
     * @return The value to which the difficulty value maps in the specified range.
     */
    static inverseDifficultyRange(difficultyValue: number, diff0: number, diff5: number, diff10: number): number;
    constructor(shallowCopy?: BeatmapDifficulty);
}

/**
 * An interface denoting that a `Mod` can be applied to osu!droid.
 */
interface IModApplicableToDroid {
    /**
     * Whether this `Mod` is ranked in osu!droid.
     */
    get droidRanked(): boolean;
    /**
     * Whether this `Mod` results in a meaningful effect to gameplay when applied in osu!droid.
     */
    get isDroidRelevant(): boolean;
    /**
     * Calculates the score multiplier of this `Mod` in osu!droid with the given `BeatmapDifficulty`.
     *
     * @param difficulty The `BeatmapDifficulty` to calculate the score multiplier for.
     * @returns The score multiplier of this `Mod` in osu!droid with the given `BeatmapDifficulty`.
     */
    calculateDroidScoreMultiplier(difficulty: BeatmapDifficulty): number;
}

/**
 * An interface for osu!droid `Mod`s that can be migrated to a new `Mod`.
 */
interface IMigratableDroidMod {
    /**
     * Migrates this `Mod` to a new `Mod` in osu!droid.
     *
     * @param difficulty The `BeatmapDifficulty` to migrate this `Mod` against.
     * @returns The new `Mod`.
     */
    migrateDroidMod(difficulty: BeatmapDifficulty): Mod & IModApplicableToDroid;
}

/**
 * An interface for `Mod`s that applies changes to a `Beatmap` after conversion and post-processing has completed.
 */
interface IModApplicableToBeatmap {
    /**
     * Applies this `IModApplicableToBeatmap` to a `Beatmap`.
     *
     * @param beatmap The `Beatmap` to apply to.
     */
    applyToBeatmap(beatmap: Beatmap): void;
}

/**
 * An interface for `Mod`s that make general adjustments to difficulty.
 */
interface IModApplicableToDifficulty {
    /**
     * Applies this `IModApplicableToDifficulty` to a `BeatmapDifficulty`.
     *
     * This is typically called post beatmap conversion.
     *
     * @param mode The game mode to apply for.
     * @param difficulty The `BeatmapDifficulty` to mutate.
     * @param adjustmentMods A `ModMap` containing `IModFacilitatesAdjustment` `Mod`s.
     */
    applyToDifficulty(mode: Modes, difficulty: BeatmapDifficulty, adjustmentMods: ModMap): void;
}

/**
 * An interface for `Mod`s that make general adjustments to difficulty.
 *
 * This is used in place of `IModApplicableToDifficulty` to make adjustments that
 * correlates directly to other applied `Mod`s.
 *
 * `Mod`s marked by this interface will have their adjustments applied after
 * `IModApplicableToDifficulty` `Mod`s have been applied.
 */
interface IModApplicableToDifficultyWithMods {
    /**
     * Applies this `IModApplicableToDifficultyWithSettings` to a `BeatmapDifficulty`.
     *
     * This is typically called post beatmap conversion.
     *
     * @param mode The game mode to apply the mod for.
     * @param difficulty The `BeatmapDifficulty` to mutate.
     * @param mods The `Mod`s that are applied to the beatmap.
     */
    applyToDifficultyWithMods(mode: Modes, difficulty: BeatmapDifficulty, mods: ModMap): void;
}

/**
 * Bitmask constant of object types. This is needed as osu! uses bits to determine object types.
 */
declare enum ObjectTypes {
    circle = 1,
    slider = 2,
    newCombo = 4,
    spinner = 8,
    comboOffset = 112
}

/**
 * Represents a two-dimensional vector.
 */
declare class Vector2 {
    /**
     * The x position of this vector.
     */
    x: number;
    /**
     * The y position of this vector.
     */
    y: number;
    constructor(value: number);
    constructor(x: number, y: number);
    constructor(other: Vector2);
    /**
     * Multiplies this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The multiplied vector.
     */
    multiply(vec: Vector2): Vector2;
    /**
     * Divides this vector with a scalar.
     *
     * Attempting to divide by 0 will throw an error.
     *
     * @param divideFactor The factor to divide the vector by.
     * @returns The divided vector.
     */
    divide(divideFactor: number): Vector2;
    /**
     * Adds this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The added vector.
     */
    add(vec: Vector2): Vector2;
    /**
     * Subtracts this vector with another vector.
     *
     * @param vec The other vector.
     * @returns The subtracted vector.
     */
    subtract(vec: Vector2): Vector2;
    /**
     * The length of this vector.
     */
    get length(): number;
    /**
     * Performs a dot multiplication with another vector.
     *
     * @param vec The other vector.
     * @returns The dot product of both vectors.
     */
    dot(vec: Vector2): number;
    /**
     * Scales this vector.
     *
     * @param scaleFactor The factor to scale the vector by.
     * @returns The scaled vector.
     */
    scale(scaleFactor: number): Vector2;
    /**
     * Gets the distance between this vector and another vector.
     *
     * @param vec The other vector.
     * @returns The distance between this vector and the other vector.
     */
    getDistance(vec: Vector2): number;
    /**
     * Gets the angle between this vector and another vector.
     *
     * @param vec The other vector.
     * @returns The angle between this vector and the other vector.
     */
    getAngle(vec: Vector2): number;
    /**
     * Normalizes the vector.
     */
    normalize(): void;
    /**
     * Checks whether this vector is equal to another vector.
     *
     * @param other The other vector.
     * @returns Whether this vector is equal to the other vector.
     */
    equals(other: Vector2): boolean;
    /**
     * Deep clones this vector.
     */
    clone(): Vector2;
    /**
     * Returns a string representation of the vector.
     */
    toString(): string;
}

/**
 * Represents a hit window.
 */
declare abstract class HitWindow {
    /**
     * A fixed miss hit window regardless of difficulty settings.
     */
    static readonly missWindow = 400;
    /**
     * The overall difficulty of this `HitWindow`.
     */
    overallDifficulty: number;
    /**
     * @param overallDifficulty The overall difficulty of this `HitWindow`. Defaults to 5.
     */
    constructor(overallDifficulty?: number);
    /**
     * The great (300) window of this `HitWindow`.
     */
    abstract get greatWindow(): number;
    /**
     * The ok (100) window of this `HitWindow`.
     */
    abstract get okWindow(): number;
    /**
     * The meh (50) window of this `HitWindow`.
     */
    abstract get mehWindow(): number;
}

/**
 * Represents a control point in a beatmap.
 */
declare abstract class ControlPoint {
    /**
     * The time at which the control point takes effect in milliseconds.
     */
    readonly time: number;
    constructor(values: {
        /**
         * The time at which the control point takes effect in milliseconds.
         */
        time: number;
    });
    /**
     * Determines whether this control point results in a meaningful change when placed alongside another.
     *
     * @param existing An existing control point to compare with.
     */
    abstract isRedundant(existing: ControlPoint): boolean;
    /**
     * Returns a string representative of the class.
     */
    abstract toString(): string;
}

/**
 * A manager for a control point.
 */
declare abstract class ControlPointManager<T extends ControlPoint> {
    /**
     * The default control point for this type.
     */
    abstract readonly defaultControlPoint: T;
    private _points;
    /**
     * The control points in this manager.
     */
    get points(): readonly T[];
    /**
     * Finds the control point that is active at a given time.
     *
     * @param time The time.
     * @returns The active control point at the given time.
     */
    abstract controlPointAt(time: number): T;
    /**
     * Adds a new control point.
     *
     * Note that the provided control point may not be added if the correct state is already present at the control point's time.
     *
     * Additionally, any control point that exists in the same time will be removed.
     *
     * @param controlPoint The control point to add.
     * @returns Whether the control point was added.
     */
    add(controlPoint: T): boolean;
    /**
     * Removes a control point.
     *
     * This method will remove the earliest control point in the array that is equal to the given control point.
     *
     * @param controlPoint The control point to remove.
     * @returns Whether the control point was removed.
     */
    remove(controlPoint: T): boolean;
    /**
     * Removes a control point at an index.
     *
     * @param index The index of the control point to remove.
     * @returns The control point that was removed.
     */
    removeAt(index: number): T;
    /**
     * Clears all control points of this type.
     */
    clear(): void;
    /**
     * Gets all control points between two times.
     *
     * @param start The start time, in milliseconds.
     * @param end The end time, in milliseconds.
     * @return An array of control points between the two times. If `start` is greater than `end`, the control point at
     * `start` will be returned.
     */
    between(startTime: number, endTime: number): T[];
    /**
     * Binary searches one of the control point lists to find the active control point at the given time.
     *
     * Includes logic for returning the default control point when no matching point is found.
     *
     * @param time The time to find the control point at.
     * @param fallback The control point to use when the given time is before any control points. Defaults to the default control point.
     * @returns The active control point at the given time, or the default control point if none found.
     */
    protected binarySearchWithFallback(time: number, fallback?: T): T;
    /**
     * Binary searches one of the control point lists to find the active control point at the given time.
     *
     * @param time The time to find the control point at.
     * @returns The active control point at the given time, `null` if none found.
     */
    protected binarySearch(time: number): T | null;
    [Symbol.iterator](): IterableIterator<T>;
    /**
     * Finds the insertion index of a control point in a given time.
     *
     * @param time The start time of the control point.
     */
    private findInsertionIndex;
}

/**
 * Represents a control point that changes the beatmap's BPM.
 */
declare class TimingControlPoint extends ControlPoint {
    /**
     * The amount of milliseconds passed for each beat.
     */
    readonly msPerBeat: number;
    /**
     * The amount of beats in a measure.
     */
    readonly timeSignature: number;
    constructor(values: {
        time: number;
        msPerBeat: number;
        timeSignature: number;
    });
    isRedundant(): boolean;
    toString(): string;
}

/**
 * A manager for timing control points.
 */
declare class TimingControlPointManager extends ControlPointManager<TimingControlPoint> {
    readonly defaultControlPoint: TimingControlPoint;
    controlPointAt(time: number): TimingControlPoint;
}

/**
 * Represents a control point that changes speed multiplier.
 */
declare class DifficultyControlPoint extends ControlPoint {
    /**
     * The slider speed multiplier of the control point.
     */
    readonly speedMultiplier: number;
    /**
     * Whether or not slider ticks should be generated at this control point.
     *
     * This exists for backwards compatibility with maps that abuse NaN slider velocity behavior on osu!stable (e.g. /b/2628991).
     */
    readonly generateTicks: boolean;
    constructor(values: {
        time: number;
        speedMultiplier: number;
        generateTicks: boolean;
    });
    isRedundant(existing: DifficultyControlPoint): boolean;
    toString(): string;
}

/**
 * A manager for difficulty control points.
 */
declare class DifficultyControlPointManager extends ControlPointManager<DifficultyControlPoint> {
    readonly defaultControlPoint: DifficultyControlPoint;
    controlPointAt(time: number): DifficultyControlPoint;
}

/**
 * Represents a control point that applies an effect to a beatmap.
 */
declare class EffectControlPoint extends ControlPoint {
    /**
     * Whether or not kiai time is enabled at this control point.
     */
    readonly isKiai: boolean;
    /**
     * Whether the first bar line of this control point is ignored.
     */
    readonly omitFirstBarLine: boolean;
    constructor(values: {
        time: number;
        isKiai: boolean;
        omitFirstBarLine: boolean;
    });
    isRedundant(existing: EffectControlPoint): boolean;
    toString(): string;
}

/**
 * A manager for effect control points.
 */
declare class EffectControlPointManager extends ControlPointManager<EffectControlPoint> {
    readonly defaultControlPoint: EffectControlPoint;
    controlPointAt(time: number): EffectControlPoint;
}

/**
 * Represents a control point that handles sample sounds.
 */
declare class SampleControlPoint extends ControlPoint {
    /**
     * The sample bank at this control point.
     */
    readonly sampleBank: SampleBank;
    /**
     * The sample volume at this control point.
     */
    readonly sampleVolume: number;
    /**
     * The index of the sample bank, if this sample bank uses custom samples.
     *
     * If this is 0, the beatmap's sample should be used instead.
     */
    readonly customSampleBank: number;
    constructor(values: {
        time: number;
        sampleBank: SampleBank;
        sampleVolume: number;
        customSampleBank: number;
    });
    /**
     * Apples this control point's sample bank and volume to a `HitSampleInfo` if necessary, returning
     * the modified `HitSampleInfo`.
     *
     * @param hitSampleInfo The `HitSampleInfo`. This will not be modified.
     * @returns The modified `HitSampleInfo`. This does not share any references with the given `HitSampleInfo`.
     */
    applyTo(hitSampleInfo: HitSampleInfo): HitSampleInfo;
    isRedundant(existing: SampleControlPoint): boolean;
    toString(): string;
}

/**
 * A manager for sample control points.
 */
declare class SampleControlPointManager extends ControlPointManager<SampleControlPoint> {
    readonly defaultControlPoint: SampleControlPoint;
    controlPointAt(time: number): SampleControlPoint;
}

/**
 * Contains information about timing (control) points of a beatmap.
 */
declare class BeatmapControlPoints {
    /**
     * The manager for timing control points of the beatmap.
     */
    readonly timing: TimingControlPointManager;
    /**
     * The manager for difficulty control points of the beatmap.
     */
    readonly difficulty: DifficultyControlPointManager;
    /**
     * The manager for effect control points of the beatmap.
     */
    readonly effect: EffectControlPointManager;
    /**
     * The manager for sample control points of the beatmap.
     */
    readonly sample: SampleControlPointManager;
    /**
     * Clears all control points in the beatmap.
     */
    clear(): void;
}

/**
 * A `HitSampleInfo` that has a time associated with it.
 */
declare class TimedHitSampleInfo<TSampleInfo extends HitSampleInfo = HitSampleInfo> {
    /**
     * The time at which the `HitSampleInfo` should be played.
     */
    readonly time: number;
    /**
     * The `HitSampleInfo` to play.
     */
    readonly sample: TSampleInfo;
    constructor(time: number, sample: TSampleInfo);
}

/**
 * Represents a gameplay hit sample that is meant to be played sequentially at specific times.
 */
declare class SequenceHitSampleInfo {
    /**
     * The `TimedHitSampleInfo`s to play.
     */
    readonly samples: readonly TimedHitSampleInfo[];
    /**
     * Whether this `SequenceHitSampleInfo` contains no `TimedHitSampleInfo`s.
     */
    get isEmpty(): boolean;
    constructor(samples: readonly TimedHitSampleInfo[]);
    /**
     * Obtains the `TimedHitSampleInfo` to play at a given time.
     *
     * @param time The time, in milliseconds.
     * @return The `TimedHitSampleInfo` to play at the given time,
     * or `null` if no `TimedHitSampleInfo`s should be played.
     */
    sampleAt(time: number): TimedHitSampleInfo | null;
}

/**
 * Represents a hitobject in a beatmap.
 */
declare abstract class HitObject {
    /**
     * The base radius of all hitobjects.
     */
    static readonly baseRadius = 64;
    /**
     * Maximum preempt time at AR=0.
     */
    static readonly preemptMax = 1800;
    /**
     * Median preempt time at AR=5.
     */
    static readonly preemptMid = 1200;
    /**
     * Minimum preempt time at AR=10.
     */
    static readonly preemptMin = 450;
    /**
     * A small adjustment to the start time of control points to account for rounding/precision errors.
     */
    protected static readonly controlPointLeniency = 1;
    /**
     * The start time of the hitobject in milliseconds.
     */
    startTime: number;
    /**
     * The bitwise type of the hitobject (circle/slider/spinner).
     */
    readonly type: ObjectTypes;
    protected _position: Vector2;
    /**
     * The position of the hitobject in osu!pixels.
     */
    get position(): Vector2;
    set position(value: Vector2);
    /**
     * The end position of the hitobject in osu!pixels.
     */
    get endPosition(): Vector2;
    /**
     * The end time of the hitobject.
     */
    get endTime(): number;
    /**
     * The duration of the hitobject.
     */
    get duration(): number;
    /**
     * Whether this hitobject represents a new combo.
     */
    readonly isNewCombo: boolean;
    /**
     * When starting a new combo, the offset of the new combo relative to the current one.
     *
     * This is generally a setting provided by a beatmap creator to choreograph interesting color patterns
     * which can only be achieved by skipping combo colors with per-hitobject level.
     *
     * It is exposed via `comboIndexWithOffsets`.
     */
    readonly comboOffset: number;
    private _indexInCurrentCombo;
    /**
     * The index of this hitobject in the current combo.
     */
    get indexInCurrentCombo(): number;
    private _comboIndex;
    /**
     * The index of this hitobject's combo in relation to the beatmap.
     *
     * In other words, this is incremented by 1 each time an `isNewCombo` is reached.
     */
    get comboIndex(): number;
    private _comboIndexWithOffsets;
    /**
     * The index of this hitobject's combo in relation to the beatmap, with all aggregates applied.
     */
    get comboIndexWithOffsets(): number;
    /**
     * Whether this is the last hitobject in the current combo.
     */
    isLastInCombo: boolean;
    /**
     * The samples to be played when this hitobject is hit.
     *
     * In the case of sliders, this is the sample of the curve body
     * and can be treated as the default samples for the hitobject.
     */
    samples: HitSampleInfo[];
    /**
     * Any samples which may be used by this hitobject that are non-standard.
     */
    auxiliarySamples: SequenceHitSampleInfo[];
    private _kiai;
    /**
     * Whether this hitobject is in kiai time.
     */
    get kiai(): boolean;
    /**
     * The hit window of this hitobject.
     */
    hitWindow: HitWindow | null;
    protected _stackHeight: number;
    /**
     * The stack height of this hitobject.
     */
    get stackHeight(): number;
    set stackHeight(value: number);
    protected _scale: number;
    /**
     * The osu!standard scale of this hitobject.
     */
    get scale(): number;
    set scale(value: number);
    private _stackOffsetMultiplier;
    /**
     * The multiplier for the stack offset of this hitobject.
     *
     * This determines how much hitobjects are stacked - and to which direction.
     */
    get stackOffsetMultiplier(): number;
    set stackOffsetMultiplier(value: number);
    /**
     * The stack offset vector of this hitobject.
     */
    get stackOffset(): Vector2;
    /**
     * The stacked position of this hitobject.
     */
    get stackedPosition(): Vector2;
    /**
     * The stacked end position of this hitobject.
     */
    get stackedEndPosition(): Vector2;
    /**
     * The time at which the approach circle of this hitobject should appear before this hitobject starts.
     */
    timePreempt: number;
    /**
     * The time at which this hitobject should fade after this hitobject appears with respect to its time preempt.
     */
    timeFadeIn: number;
    /**
     * The hitobject type (circle, slider, or spinner).
     */
    get typeStr(): string;
    /**
     * The radius of this hitobject in osu!pixels.
     */
    get radius(): number;
    constructor(values: {
        startTime: number;
        position: Vector2;
        newCombo?: boolean;
        comboOffset?: number;
        type?: number;
        endPosition?: Vector2;
    });
    /**
     * Applies default values to this hitobject.
     *
     * @param controlPoints The beatmap control points.
     * @param difficulty The beatmap difficulty settings.
     * @param mode The gamemode to apply defaults for.
     */
    applyDefaults(controlPoints: BeatmapControlPoints, difficulty: BeatmapDifficulty, mode: Modes): void;
    /**
     * Applies samples to this hitobject.
     *
     * @param controlPoints The beatmap control points.
     */
    applySamples(controlPoints: BeatmapControlPoints): void;
    /**
     * Given the previous hitobject in the beatmap, update relevant combo information.
     *
     * @param prev The previous hitobject in the beatmap.
     */
    updateComboInformation(prev?: HitObject | null): void;
    /**
     * Creates a hit sample info based on the sample setting of the first `BankHitSampleInfo.HIT_NORMAL` sample in the `samples` array.
     * If no sample is available, sane default settings will be used instead.
     *
     * In the case an existing sample exists, all settings apart from the sample name will be inherited. This includes volume and bank.
     *
     * @param sampleName The name of the sample.
     * @returns The created hit sample info.
     */
    protected createHitSampleInfo(sampleName: string): BankHitSampleInfo;
    /**
     * Creates the hit window of this hitobject.
     *
     * A `null` return means that this hitobject has no hit window and timing errors should not be displayed to the user.
     *
     * This will only be called if this hitobject's hit window has not been set externally.
     *
     * @param mode The gamemode to create the hit window for.
     * @returns The created hit window.
     */
    protected createHitWindow(mode: Modes): HitWindow | null;
    /**
     * Returns the string representative of the class.
     */
    abstract toString(): string;
    /**
     * Evaluates the stacked position of the specified position.
     *
     * @param position The position to evaluate.
     * @returns The stacked position.
     */
    private evaluateStackedPosition;
}

/**
 * An interface for `Mod`s that can be applied to `HitObject`s.
 */
interface IModApplicableToHitObject {
    /**
     * Applies this `IModApplicableToHitObject` to a `HitObject`.
     *
     * @param mode The game mode to apply for.
     * @param hitObject The `HitObject` to apply to.
     * @param adjustmentMods A `ModMap` containing `IModFacilitatesAdjustment` `Mod`s.
     */
    applyToHitObject(mode: Modes, hitObject: HitObject, adjustmentMods: ModMap): void;
}

/**
 * An interface for `Mod`s that can be applied to `HitObject`s.
 *
 * This is used in place of `IModApplicableToHitObject` to make adjustments that
 * correlates directly to other applied `Mod`s.
 *
 * `Mod`s marked by this interface will have their adjustments applied after
 * `IModApplicableToHitObject` `Mod`s have been applied.
 */
interface IModApplicableToHitObjectWithMods {
    /**
     * Applies this `IModApplicableToHitObjectWithSettings` to a `HitObject`.
     *
     * This is typically called post beatmap conversion.
     *
     * @param mode The game mode to apply for.
     * @param hitObject The `HitObject` to mutate.
     * @param mods The `Mod`s that are applied to the beatmap.
     */
    applyToHitObjectWithMods(mode: Modes, hitObject: HitObject, mods: ModMap): void;
}

/**
 * An interface denoting that a `Mod` can be applied to osu!standard.
 */
interface IModApplicableToOsu {
    /**
     * Whether this `Mod` is ranked in osu!standard.
     */
    get osuRanked(): boolean;
    /**
     * Whether this `Mod` results in a meaningful effect to gameplay when applied in osu!standard.
     */
    get isOsuRelevant(): boolean;
    /**
     * The score multiplier of this `Mod` in osu!standard.
     */
    get osuScoreMultiplier(): number;
}

/**
 * An interface denoting that a `Mod` can be applied to osu!standard, specifically the osu!stable client.
 */
interface IModApplicableToOsuStable extends IModApplicableToOsu {
    /**
     * The bitwise enum of this `Mod`.
     */
    readonly bitwise: number;
}

/**
 * An interface for `Mod`s that make adjustments to the track's playback rate.
 */
interface IModApplicableToTrackRate {
    /**
     * Returns the playback rate at `time` after this `Mod` is applied.
     *
     * @param time The time at which the playback rate is queried, in milliseconds.
     * @param rate The playback rate before applying this [Mod].
     * @return The playback rate after applying this [Mod].
     */
    applyToRate(time: number, rate: number): number;
}

/**
 * An interface for `Mod`s that aids in adjustments to a `HitObject` or `BeatmapDifficulty`.
 *
 * `Mod`s marked by this interface will be passed into `IModApplicableToDifficulty`s
 * and `IModApplicableToHitObject`s.
 */
interface IModFacilitatesAdjustment {
    /**
     * Whether this `Mod` facilitates adjustment to a `HitObject` or `BeatmapDifficulty`.
     *
     * This is always `true`.
     */
    readonly facilitateAdjustment: true;
}

/**
 * Represents a mod that has been serialized.
 */
interface SerializedMod {
    /**
     * The acronym of the mod.
     */
    readonly acronym: string;
    /**
     * Settings specific to the mod, if any.
     */
    readonly settings?: Record<string, unknown>;
}

/**
 * A listener that is called when the value of a `ModSetting` changes.
 */
type ModSettingValueChangedListener<T> = (oldValue: T, value: T) => unknown;

/**
 * Represents a `Mod` specific setting.
 */
declare class ModSetting<T = unknown> {
    /**
     * The legible name of this `ModSetting`.
     */
    readonly name: string;
    /**
     * The description of this `ModSetting`.
     */
    readonly description: string;
    /**
     * The formatter to display the value of this `ModSetting`.
     */
    protected readonly displayFormatter: (value: T) => string;
    private _defaultValue;
    /**
     * The default value of this `ModSetting`.
     */
    get defaultValue(): T;
    set defaultValue(value: T);
    private _value;
    /**
     * The value of this `ModSetting`.
     */
    get value(): T;
    set value(value: T);
    private valueChangedListeners;
    /**
     * Whether this `ModSetting` is set to its default value.
     */
    get isDefault(): boolean;
    constructor(name: string, description: string, defaultValue: T);
    /**
     * Returns a string representation of this `ModSetting`'s value.
     *
     * @returns A string representation of this `ModSetting`'s value.
     */
    toDisplayString(): string;
    /**
     * Binds an action that will be called when the value of this `ModSetting` changes.
     *
     * @param listener The action to call when the value of this `ModSetting` changes.
     * @param runOnceImmediately Whether to call the action immediately with the current value of this `ModSetting`.
     */
    bindValueChanged(listener: ModSettingValueChangedListener<T>, runOnceImmediately?: boolean): void;
    /**
     * Unbinds an action that was previously bound to this `ModSetting`.
     *
     * @param listener The action to unbind.
     */
    unbindValueChanged(listener: ModSettingValueChangedListener<T>): void;
}

/**
 * Represents a mod.
 */
declare abstract class Mod {
    /**
     * The acronym of this `Mod`.
     */
    abstract readonly acronym: string;
    /**
     * The name of this `Mod`.
     */
    abstract readonly name: string;
    /**
     * Whether this `Mod` is playable by a real human user.
     *
     * Should be `false` for cases where the user is not meant to apply the `Mod` by themselves.
     */
    readonly userPlayable: boolean;
    /**
     * `Mod`s that are incompatible with this `Mod`.
     */
    readonly incompatibleMods: Set<typeof Mod>;
    private settingsBacking;
    /**
     * `ModSetting`s that are specific to this `Mod`.
     */
    get settings(): ModSetting[];
    /**
     * Whether all `ModSetting`s of this `Mod` are set to their default values.
     */
    get usesDefaultSettings(): boolean;
    /**
     * Serializes this `Mod` to a `SerializedMod`.
     */
    serialize(): SerializedMod;
    /**
     * Copies the settings of a `SerializedMod` to this `Mod`.
     *
     * @param mod The `SerializedMod` to copy the settings from. Must be the same `Mod` type.
     * @throws {TypeError} If the `SerializedMod` is not the same type as this `Mod`.
     */
    copySettings(mod: SerializedMod): void;
    /**
     * Whether this `Mod` can be applied to osu!droid.
     */
    isApplicableToDroid(): this is this & IModApplicableToDroid;
    /**
     * Whether this `Mod` can be applied to osu!standard.
     */
    isApplicableToOsu(): this is this & IModApplicableToOsu;
    /**
     * Whether this `Mod` can be applied to osu!standard, specifically the osu!stable client.
     */
    isApplicableToOsuStable(): this is this & IModApplicableToOsuStable;
    /**
     * Whether this `Mod` can be applied to a `Beatmap`.
     */
    isApplicableToBeatmap(): this is this & IModApplicableToBeatmap;
    /**
     * Whether this `Mod` can be applied to a `BeatmapDifficulty`.
     */
    isApplicableToDifficulty(): this is this & IModApplicableToDifficulty;
    /**
     * Whether this `Mod` can be applied to a `BeatmapDifficulty` relative to other `Mod`s and settings.
     */
    isApplicableToDifficultyWithMods(): this is this & IModApplicableToDifficultyWithMods;
    /**
     * Whether this `Mod` can be applied to a `HitObject`.
     */
    isApplicableToHitObject(): this is this & IModApplicableToHitObject;
    /**
     * Whether this `Mod` can be applied to a `HitObject` relative to other `Mod`s and settings.
     */
    isApplicableToHitObjectWithMods(): this is this & IModApplicableToHitObjectWithMods;
    /**
     * Whether this `Mod` can be applied to a track's playback rate.
     */
    isApplicableToTrackRate(): this is this & IModApplicableToTrackRate;
    /**
     * Whether this `Mod` is migratable to a new `Mod` in osu!droid.
     */
    isMigratableDroidMod(): this is this & IMigratableDroidMod;
    /**
     * Whether this `Mod` facilitates adjustment to a `HitObject` or `BeatmapDifficulty`.
     */
    facilitatesAdjustment(): this is this & IModFacilitatesAdjustment;
    /**
     * Serializes the settings of this `Mod` to an object that can be converted to a JSON.
     *
     * @returns The serialized settings of this `Mod`, or `null` if there are no settings.
     */
    protected serializeSettings(): Record<string, unknown> | null;
    /**
     * Compares this `Mod` to another `Mod` for equality.
     *
     * @param other The object to compare to.
     * @returns `true` if the object is the same `Mod`, `false` otherwise.
     */
    equals(other: Mod): other is this;
    /**
     * Returns the string representation of this `Mod`.
     */
    toString(): string;
}

/**
 * A map that stores `Mod`s depending on their type.
 *
 * This also has additional utilities to eliminate unnecessary `Mod`s.
 */
declare class ModMap extends Map<typeof Mod, Mod> {
    /**
     * Whether this map is empty.
     */
    get isEmpty(): boolean;
    constructor(iterable?: readonly (readonly [typeof Mod, Mod])[] | null);
    /**
     * Checks if the given `Mod` is present in this map.
     *
     * @param value The `Mod` to check for.
     * @returns Whether the `Mod` is present in this map.
     */
    has(value: Mod): boolean;
    /**
     * Checks if the given `Mod` type is present in this map.
     *
     * @param key The `Mod` type to check for.
     * @returns Whether the `Mod` type is present in this map.
     */
    has(key: typeof Mod): boolean;
    get<T extends Mod>(key: new () => T): T | undefined;
    /**
     * Inserts a new instance of the given `Mod` type into this map.
     *
     * @param key The `Mod` type to insert.
     * @returns The existing `Mod` instance of the given `Mod` type if it was already present, or `null` if it was not.
     */
    set<T extends Mod>(key: new () => T): T | null;
    /**
     * Inserts the given `Mod` into this map.
     *
     * @param value The `Mod` to insert.
     * @returns The existing `Mod` instance if it was already present, or `null` if it was not.
     */
    set<T extends Mod>(value: T): T | null;
    /**
     * Serializes all `Mod`s that are in this map.
     *
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     */
    serializeMods(includeNonUserPlayable?: boolean): SerializedMod[];
    /**
     * Determines whether this `ModMap` is equal to another `ModMap`.
     *
     * This equality check succeeds if and only if the two `ModMap`s have the same size and
     * all `Mod`s in this `ModMap` are equal to the corresponding `Mod`s in the other `ModMap`.
     *
     * @param other The other `ModMap` to compare to.
     * @returns Whether the two `ModMap`s are equal.
     */
    equals(other: ModMap): boolean;
    /**
     * Returns a string representation of this `ModMap`.
     *
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns A string representation of this `ModMap`.
     */
    toString(includeNonUserPlayable?: boolean): string;
}

/**
 * Represents an RGB color.
 */
declare class RGBColor {
    /**
     * The red component of the color.
     */
    r: number;
    /**
     * The green component of the color.
     */
    g: number;
    /**
     * The blue component of the color.
     */
    b: number;
    /**
     * The alpha component of the color.
     */
    a: number;
    constructor(r: number, g: number, b: number, a?: number);
    /**
     * Returns a string representation of the color.
     */
    toString(): string;
    /**
     * Checks whether this color is equal to another color.
     *
     * @param other The other color.
     */
    equals(other: RGBColor): boolean;
}

/**
 * Contains information about combo and skin colors of a beatmap.
 */
declare class BeatmapColor {
    /**
     * The combo colors of the beatmap.
     */
    readonly combo: RGBColor[];
    /**
     * Additive slider track color.
     */
    sliderTrackOverride?: RGBColor;
    /**
     * The color of slider borders.
     */
    sliderBorder?: RGBColor;
}

/**
 * Represents the grid size setting in the editor.
 */
declare enum EditorGridSize {
    tiny = 4,
    small = 8,
    medium = 16,
    large = 32
}

/**
 * Contains saved settings for the beatmap editor.
 */
declare class BeatmapEditor {
    /**
     * Time in milliseconds of bookmarks.
     */
    bookmarks: number[];
    /**
     * The multiplier at which distance between consecutive notes will be snapped based on their rhythmical difference.
     */
    distanceSnap: number;
    /**
     * Determines the editor's behaviour in quantizing hit objects based on the {@link https://osu.ppy.sh/wiki/en/Client/Beatmap_editor/Beat_Snap Beat Snap} principles.
     */
    beatDivisor: number;
    /**
     * The grid size setting in the editor.
     */
    gridSize: EditorGridSize;
    /**
     * The scale factor for the {@link https://osu.ppy.sh/wiki/en/Client/Beatmap_editor/Compose#top-left-(hit-objects-timeline) object timeline}.
     */
    timelineZoom: number;
}

/**
 * Represents a beatmap's background.
 */
declare class BeatmapBackground {
    /**
     * The location of the background image relative to the beatmap directory.
     */
    filename: string;
    /**
     * Offset in osu! pixels from the centre of the screen.
     *
     * For example, an offset of `50,100` would have the background shown 50 osu!
     * pixels to the right and 100 osu! pixels down from the centre of the screen.
     */
    offset: Vector2;
    constructor(filename: string, offset: Vector2);
}

/**
 * Represents a beatmap's video.
 */
declare class BeatmapVideo {
    /**
     * The location of the video relative to the beatmap directory.
     */
    filename: string;
    /**
     * The start time of the video, in milliseconds from the beginning of the beatmap's audio.
     */
    startTime: number;
    /**
     * Offset in osu! pixels from the centre of the screen.
     *
     * For example, an offset of `50,100` would have the video shown 50 osu! pixels
     * to the right and 100 osu! pixels down from the centre of the screen.
     */
    offset: Vector2;
    constructor(startTime: number, filename: string, offset: Vector2);
}

/**
 * Available types of a storyboard layer.
 */
declare enum StoryboardLayerType {
    background = "Background",
    fail = "Fail",
    pass = "Pass",
    foreground = "Foreground",
    overlay = "Overlay",
    sample = "Sample"
}

/**
 * Represents a storyboard element.
 */
declare abstract class StoryboardElement {
    /**
     * The file path to the content of the element.
     */
    readonly path: string;
    /**
     * The time at which the element starts.
     */
    abstract get startTime(): number;
    /**
     * The time at which the element ends.
     */
    get endTime(): number;
    /**
     * The duration of the storyboard element.
     */
    get duration(): number;
    constructor(path: string);
}

/**
 * Represents a storyboard's layer.
 */
declare class StoryboardLayer {
    /**
     * The name of the layer.
     */
    readonly name: StoryboardLayerType;
    /**
     * The depth of the layer.
     */
    readonly depth: number;
    /**
     * Whether this storyboard layer is visible in pass state.
     */
    visibleWhenPassing: boolean;
    /**
     * Whether this storyboard layer is visible in fail state.
     */
    visibleWhenFailing: boolean;
    /**
     * The storyboard elements in this layer.
     */
    elements: StoryboardElement[];
    constructor(name: StoryboardLayerType, depth: number, visibleWhenPassing?: boolean, visibleWhenFailing?: boolean);
}

/**
 * Represents a storyboard.
 */
declare class Storyboard {
    /**
     * The layers in the storyboard.
     */
    readonly layers: Partial<Record<StoryboardLayerType, StoryboardLayer>>;
    /**
     * Whether the storyboard can fall back to skin sprites in case no matching storyboard sprites are found.
     */
    useSkinSprites: boolean;
    /**
     * The variables of the storyboard.
     */
    variables: Record<string, string>;
    /**
     * The depth of the currently front-most storyboard layer, excluding the overlay layer.
     */
    private minimumLayerDepth;
    /**
     * Across all layers, find the earliest point in time that a storyboard element exists at.
     * Will return `null` if there are no elements.
     *
     * This iterates all elements and as such should be used sparingly or stored locally.
     */
    get earliestEventTime(): number | null;
    /**
     * Across all layers, find the latest point in time that a storyboard element exists at.
     * Will return `null` if there are no elements.
     *
     * This iterates all elements and as such should be used sparingly or stored locally.
     * Samples return start time as their end time.
     */
    get latestEventTime(): number | null;
    /**
     * Gets a layer of the storyboard.
     *
     * @param type The layer type.
     * @param createIfNotAvailable Whether to create the storyboard layer if it's not available. Defaults to `true`.
     * @returns The storyboard layer.
     */
    getLayer(type: StoryboardLayerType, createIfNotAvailable?: boolean): StoryboardLayer;
    /**
     * Gets a layer of the storyboard.
     *
     * @param type The layer type.
     * @param createIfNotAvailable Whether to create the storyboard layer if it's not available. Defaults to `true`.
     * @returns The storyboard layer.
     */
    getLayer(type: StoryboardLayerType, createIfNotAvailable: false): StoryboardLayer | null;
}

/**
 * Represents a break period in a beatmap.
 */
declare class BreakPoint {
    /**
     * The minimum duration required for a break to have any effect.
     */
    static readonly MIN_BREAK_DURATION = 650;
    /**
     * The start time of the break period.
     */
    readonly startTime: number;
    /**
     * The end time of the break period.
     */
    readonly endTime: number;
    /**
     * The duration of the break period.
     */
    get duration(): number;
    constructor(values: {
        startTime: number;
        endTime: number;
    });
    /**
     * Returns a string representation of the class.
     */
    toString(): string;
    /**
     * Whether this break period contains a specified time.
     *
     * @param time The time to check in milliseconds.
     * @returns Whether the time falls within this break period.
     */
    contains(time: number): boolean;
}

/**
 * Contains beatmap events.
 */
declare class BeatmapEvents {
    /**
     * The beatmap's background.
     */
    background?: BeatmapBackground;
    /**
     * The beatmap's video.
     */
    video?: BeatmapVideo;
    /**
     * The beatmap's storyboard.
     */
    storyboard?: Storyboard;
    /**
     * The breaks this beatmap has.
     */
    readonly breaks: BreakPoint[];
    /**
     * Whether the beatmap's background should be hidden while its storyboard is being displayed.
     */
    get storyboardReplacesBackground(): boolean;
}

/**
 * Represents the speed of the countdown before the first hit object.
 */
declare enum BeatmapCountdown {
    noCountDown = 0,
    normal = 1,
    half = 2,
    double = 3
}

/**
 * Represents the draw order of hit circle overlays compared to hit numbers.
 *
 * - `noChange` = use skin setting
 * - `below` = draw overlays under numbers
 * - `above` = draw overlays on top of numbers
 */
declare enum BeatmapOverlayPosition {
    noChange = "NoChange",
    below = "Below",
    above = "Above"
}

/**
 * Represents game modes available in the game.
 */
declare enum GameMode {
    osu = 0,
    taiko = 1,
    catch = 2,
    mania = 3
}

/**
 * Contains general information about a beatmap.
 */
declare class BeatmapGeneral {
    /**
     * The location of the audio file relative to the beatmapset file.
     */
    audioFilename: string;
    /**
     * The amount of milliseconds of silence before the audio starts playing.
     */
    audioLeadIn: number;
    /**
     * The time in milliseconds when the audio preview should start.
     *
     * If -1, the audio should begin playing at 40% of its length.
     */
    previewTime: number;
    /**
     * The speed of the countdown before the first hit object.
     */
    countdown: BeatmapCountdown;
    /**
     * The sample bank that will be used if timing points do not override it.
     */
    sampleBank: SampleBank;
    /**
     * The sample volume that will be used if timing points do not override it.
     */
    sampleVolume: number;
    /**
     * The multiplier for the threshold in time where hit objects
     * placed close together stack, ranging from 0 to 1.
     */
    stackLeniency: number;
    /**
     * The game mode of the beatmap.
     */
    mode: GameMode;
    /**
     * Whether or not breaks have a letterboxing effect.
     */
    letterBoxInBreaks: boolean;
    /**
     * Whether or not the storyboard can use the user's skin images.
     */
    useSkinSprites: boolean;
    /**
     * The draw order of hit circle overlays compared to hit numbers.
     */
    overlayPosition: BeatmapOverlayPosition;
    /**
     * The preffered skin to use during gameplay.
     */
    skinPreference: string;
    /**
     * Whether or not a warning about flashing colours should be shown at the beginning of the map.
     */
    epilepsyWarning: boolean;
    /**
     * The time in beats that the countdown starts before the first hit object.
     */
    countdownOffset: number;
    /**
     * Whether or not the storyboard allows widescreen viewing.
     */
    widescreenStoryboard: boolean;
    /**
     * Whether or not sound samples will change rate when playing with speed-changing mods.
     */
    samplesMatchPlaybackRate: boolean;
}

/**
 * Represents a circle in a beatmap.
 *
 * All we need from circles is their position. All positions
 * stored in the objects are in playfield coordinates (512*384
 * rectangle).
 */
declare class Circle extends HitObject {
    constructor(values: {
        startTime: number;
        newCombo?: boolean;
        comboOffset?: number;
        type?: number;
        position: Vector2;
    });
    toString(): string;
}

/**
 * Types of slider paths.
 */
declare enum PathType {
    Catmull = "C",
    Bezier = "B",
    Linear = "L",
    PerfectCurve = "P"
}

/**
 * Represents a slider's path.
 */
declare class SliderPath {
    /**
     * The path type of the slider.
     */
    readonly pathType: PathType;
    /**
     * The control points (anchor points) of the slider.
     */
    readonly controlPoints: Vector2[];
    /**
     * Distance that is expected when calculating slider path.
     */
    readonly expectedDistance: number;
    /**
     * Whether or not the instance has been initialized.
     */
    isInitialized: boolean;
    /**
     * The calculated path of the slider.
     */
    readonly calculatedPath: Vector2[];
    /**
     * The cumulative length of the slider.
     */
    readonly cumulativeLength: number[];
    constructor(values: {
        /**
         * The path type of the slider.
         */
        pathType: PathType;
        /**
         * The anchor points of the slider.
         */
        controlPoints: Vector2[];
        /**
         * The distance that is expected when calculating slider path.
         */
        expectedDistance: number;
    });
    /**
     * Initializes the instance.
     */
    ensureInitialized(): void;
    /**
     * Calculates the slider's path.
     */
    calculatePath(): void;
    /**
     * Calculates the slider's subpath.
     */
    calculateSubPath(subControlPoints: Vector2[]): Vector2[];
    /**
     * Calculates the slider's cumulative length.
     */
    calculateCumulativeLength(): void;
    /**
     * Computes the position on the slider at a given progress that ranges from 0 (beginning of the path)
     * to 1 (end of the path).
     *
     * @param progress Ranges from 0 (beginning of the path) to 1 (end of the path).
     */
    positionAt(progress: number): Vector2;
    /**
     * Computes the slider path until a given progress that ranges from 0 (beginning of the slider) to
     * 1 (end of the slider).
     *
     * @param p0 Start progress. Ranges from 0 (beginning of the slider) to 1 (end of the slider).
     * @param p1 End progress. Ranges from 0 (beginning of the slider) to 1 (end of the slider).
     * @return The computed path between the two ranges.
     */
    pathToProgress(p0: number, p1: number): Vector2[];
    /**
     * Returns the progress of reaching expected distance.
     */
    private progressToDistance;
    /**
     * Interpolates verticles of the slider.
     */
    private interpolateVerticles;
    /**
     * Binary searches the cumulative length array and returns the
     * index at which `arr[index] >= d`.
     *
     * @param d The distance to search.
     * @returns The index.
     */
    private indexOfDistance;
}

/**
 * Represents a hitobject that can be nested within a slider.
 */
declare abstract class SliderNestedHitObject extends HitObject {
    /**
     * The index of the span at which this nested hitobject lies.
     */
    readonly spanIndex: number;
    /**
     * The start time of the span at which this nested hitobject lies, in milliseconds.
     */
    readonly spanStartTime: number;
    constructor(values: {
        position: Vector2;
        startTime: number;
        spanIndex: number;
        spanStartTime: number;
    });
    toString(): string;
}

/**
 * Represents the head of a slider.
 */
declare class SliderHead extends SliderNestedHitObject {
    constructor(values: {
        position: Vector2;
        startTime: number;
    });
}

/**
 * Represents a nested hit object that is at the end of a slider path (either repeat or tail).
 */
declare abstract class SliderEndCircle extends SliderNestedHitObject {
    private readonly sliderSpanDuration;
    private readonly sliderStartTime;
    constructor(values: {
        sliderSpanDuration: number;
        sliderStartTime: number;
        position: Vector2;
        startTime: number;
        spanIndex: number;
        spanStartTime: number;
    });
    applyDefaults(controlPoints: BeatmapControlPoints, difficulty: BeatmapDifficulty, mode: Modes): void;
    protected createHitWindow(): HitWindow | null;
}

/**
 * Represents the tail of a slider.
 */
declare class SliderTail extends SliderEndCircle {
}

/**
 * Represents a slider in a beatmap.
 */
declare class Slider extends HitObject {
    private static readonly baseNormalSlideSample;
    private static readonly baseWhistleSlideSample;
    private static readonly baseTickSample;
    get position(): Vector2;
    set position(value: Vector2);
    get endTime(): number;
    private readonly endPositionCache;
    get endPosition(): Vector2;
    /**
     * The nested hitobjects of the slider. Consists of headcircle (sliderhead), slider ticks, repeat points, and tailcircle (sliderend).
     */
    readonly nestedHitObjects: SliderNestedHitObject[];
    /**
     * The slider's path.
     */
    private _path;
    /**
     * The slider's path.
     */
    get path(): SliderPath;
    /**
     * The slider's path.
     */
    set path(value: SliderPath);
    /**
     * The slider's velocity.
     */
    private _velocity;
    /**
     * The slider's velocity.
     */
    get velocity(): number;
    /**
     * The distance of this slider.
     */
    get distance(): number;
    /**
     * The amount of times this slider repeats.
     */
    private _repeatCount;
    /**
     * The amount of times this slider repeats.
     */
    get repeatCount(): number;
    /**
     * The amount of times this slider repeats.
     */
    set repeatCount(value: number);
    /**
     * The amount of times the length of this slider spans.
     */
    get spanCount(): number;
    /**
     * The spacing between slider ticks of this slider.
     */
    private _tickDistance;
    /**
     * The spacing between slider ticks of this slider.
     */
    get tickDistance(): number;
    /**
     * An extra multiplier that affects the number of slider ticks generated by this slider.
     * An increase in this value increases `tickDistance`, which reduces the number of ticks generated.
     */
    readonly tickDistanceMultiplier: number;
    /**
     * Whether slider ticks should be generated by this object.
     *
     * This exists for backwards compatibility with maps that abuse NaN slider velocity behavior on osu!stable (e.g. /b/2628991).
     */
    generateTicks: boolean;
    /**
     * The length of one span of this slider.
     */
    get spanDuration(): number;
    /**
     * The slider's head.
     */
    private _head;
    /**
     * The slider's head.
     */
    get head(): SliderHead;
    /**
     * The slider's tail.
     */
    private _tail;
    /**
     * The slider's tail.
     */
    get tail(): SliderTail;
    /**
     * The samples to be played when each node of this slider is hit.
     *
     * - 0: The first node.
     * - 1: The first repeat.
     * - 2: The second repeat.
     * - ...
     * - `n - 1`: The last repeat.
     * - `n`: The last node.
     */
    readonly nodeSamples: HitSampleInfo[][];
    /**
     * The amount of slider ticks in this slider.
     *
     * This iterates through all nested objects and should be stored locally or used sparingly.
     */
    get ticks(): number;
    get stackHeight(): number;
    set stackHeight(value: number);
    get scale(): number;
    set scale(value: number);
    static readonly legacyLastTickOffset = 36;
    constructor(values: {
        startTime: number;
        type: number;
        position: Vector2;
        repeatCount: number;
        path: SliderPath;
        newCombo?: boolean;
        comboOffset?: number;
        nodeSamples: HitSampleInfo[][];
        tickDistanceMultiplier: number;
    });
    applyDefaults(controlPoints: BeatmapControlPoints, difficulty: BeatmapDifficulty, mode: Modes): void;
    applySamples(controlPoints: BeatmapControlPoints): void;
    /**
     * Computes the position on this slider relative to how much of the slider has been completed.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns The position on this slider at the given progress.
     */
    curvePositionAt(progress: number): Vector2;
    /**
     * Computes the progress along this slider relative to how much of the slider has been completed.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns `[0, 1]` where 0 is the beginning of this slider and 1 is the end of this slider.
     */
    progressAt(progress: number): number;
    /**
     * Determines which span of this slider the progress point is on.
     *
     * @param progress `[0, 1]` where 0 is the start time of this slider and 1 is the end time of this slider.
     * @returns `[0, spanCount)` where 0 is the first run.
     */
    spanAt(progress: number): number;
    protected createHitWindow(): HitWindow | null;
    private createNestedHitObjects;
    private updateNestedPositions;
    private createSlidingSamples;
    private updateNestedSamples;
    toString(): string;
}

/**
 * Represents a spinner in a beatmap.
 *
 * All we need from spinners is their duration. The
 * position of a spinner is always at 256x192.
 */
declare class Spinner extends HitObject {
    private static readonly baseSpinnerSpinSample;
    private static readonly baseSpinnerBonusSample;
    private _endTime;
    get endTime(): number;
    constructor(values: {
        startTime: number;
        type: number;
        endTime: number;
    });
    applySamples(controlPoints: BeatmapControlPoints): void;
    get stackedPosition(): Vector2;
    get stackedEndPosition(): Vector2;
    protected createHitWindow(): HitWindow | null;
    toString(): string;
}

/**
 * Represents a hitobject that can be placed manually by the user in the game's editor.
 */
type PlaceableHitObject = Circle | Slider | Spinner;

/**
 * Contains information about hit objects of a beatmap.
 */
declare class BeatmapHitObjects {
    /**
     * The objects of the beatmap.
     */
    objects: PlaceableHitObject[];
    private _circles;
    /**
     * The amount of circles in the beatmap.
     */
    get circles(): number;
    private _sliders;
    /**
     * The amount of sliders in the beatmap.
     */
    get sliders(): number;
    private _spinners;
    /**
     * The amount of spinners in the beatmap.
     */
    get spinners(): number;
    /**
     * The amount of slider ticks in the beatmap.
     *
     * This iterates through all objects and should be stored locally or used sparingly.
     */
    get sliderTicks(): number;
    /**
     * The amount of sliderends in the beatmap.
     */
    get sliderEnds(): number;
    /**
     * The amount of slider repeat points in the beatmap.
     *
     * This iterates through all objects and should be stored locally or used sparingly.
     */
    get sliderRepeatPoints(): number;
    /**
     * Adds hitobjects.
     *
     * The sorting order of hitobjects will be maintained.
     *
     * @param objects The hitobjects to add.
     */
    add(...objects: PlaceableHitObject[]): void;
    /**
     * Removes a hitobject at an index.
     *
     * @param index The index of the hitobject to remove.
     * @returns The hitobject that was removed, `null` if no hitobject was removed.
     */
    removeAt(index: number): PlaceableHitObject | null;
    /**
     * Clears all hitobjects.
     */
    clear(): void;
    [Symbol.iterator](): IterableIterator<PlaceableHitObject>;
    /**
     * Finds the insertion index of a hitobject in a given time.
     *
     * @param startTime The start time of the hitobject.
     */
    private findInsertionIndex;
}

/**
 * Contains information used to identify a beatmap.
 */
declare class BeatmapMetadata {
    /**
     * The romanized song title of the beatmap.
     */
    title: string;
    /**
     * The song title of the beatmap.
     */
    titleUnicode: string;
    /**
     * The romanized artist of the song of the beatmap.
     */
    artist: string;
    /**
     * The song artist of the beatmap.
     */
    artistUnicode: string;
    /**
     * The creator of the beatmap.
     */
    creator: string;
    /**
     * The difficulty name of the beatmap.
     */
    version: string;
    /**
     * The original media the song was produced for.
     */
    source: string;
    /**
     * The search terms of the beatmap.
     */
    tags: string[];
    /**
     * The ID of the beatmap.
     */
    beatmapId?: number;
    /**
     * The ID of the beatmapset containing this beatmap.
     */
    beatmapSetId?: number;
    /**
     * The full title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     */
    get fullTitle(): string;
    /**
     * The full unicode title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     *
     * Will fallback to original artist and title if needed.
     */
    get fullUnicodeTitle(): string;
}

/**
 * Represents a beatmap.
 */
interface IBeatmap {
    /**
     * The format version of the beatmap.
     */
    formatVersion: number;
    /**
     * General information about the beatmap.
     */
    readonly general: BeatmapGeneral;
    /**
     * Saved settings for the beatmap editor.
     */
    readonly editor: BeatmapEditor;
    /**
     * Information used to identify the beatmap.
     */
    readonly metadata: BeatmapMetadata;
    /**
     * Difficulty settings of the beatmap.
     */
    difficulty: BeatmapDifficulty;
    /**
     * Events of the beatmap.
     */
    readonly events: BeatmapEvents;
    /**
     * Timing and control points of the beatmap.
     */
    readonly controlPoints: BeatmapControlPoints;
    /**
     * Combo and skin colors of the beatmap.
     */
    readonly colors: BeatmapColor;
    /**
     * The objects of the beatmap.
     */
    hitObjects: BeatmapHitObjects;
    /**
     * The maximum combo of the beatmap.
     */
    get maxCombo(): number;
}

/**
 * Represents a beatmap that is in a playable state for a specific game mode.
 */
declare abstract class PlayableBeatmap implements IBeatmap {
    readonly formatVersion: number;
    readonly general: BeatmapGeneral;
    readonly editor: BeatmapEditor;
    readonly metadata: BeatmapMetadata;
    readonly difficulty: BeatmapDifficulty;
    readonly events: BeatmapEvents;
    readonly controlPoints: BeatmapControlPoints;
    readonly colors: BeatmapColor;
    readonly hitObjects: BeatmapHitObjects;
    readonly maxCombo: number;
    /**
     * The `Mod`s that were applied to this `PlayableBeatmap`.
     */
    readonly mods: ModMap;
    /**
     * The speed multiplier that was applied to this [PlayableBeatmap].
     */
    readonly speedMultiplier: number;
    private readonly _hitWindow;
    /**
     * The `HitWindow` of this `PlayableBeatmap`.
     */
    get hitWindow(): HitWindow;
    /**
     * @param baseBeatmap The base `IBeatmap` that was used to create this `PlayableBeatmap`.
     * @param mods The `Mod`s that were applied to this `PlayableBeatmap`.
     */
    constructor(baseBeatmap: IBeatmap, mods: ModMap);
    /**
     * Creates the `HitWindow` of this `PlayableBeatmap`.
     */
    protected abstract createHitWindow(): HitWindow;
}

/**
 * Representsa a `PlayableBeatmap` for osu!droid.
 */
declare class DroidPlayableBeatmap extends PlayableBeatmap {
    protected createHitWindow(): HitWindow;
}

/**
 * Represents a `PlayableBeatmap` for osu!standard.
 */
declare class OsuPlayableBeatmap extends PlayableBeatmap {
    protected createHitWindow(): HitWindow;
}

/**
 * Represents a beatmap with advanced information.
 */
declare class Beatmap implements IBeatmap {
    /**
     * The game mode this `Beatmap` was parsed as.
     */
    mode: Modes;
    formatVersion: number;
    readonly general: BeatmapGeneral;
    readonly editor: BeatmapEditor;
    readonly metadata: BeatmapMetadata;
    difficulty: BeatmapDifficulty;
    readonly events: BeatmapEvents;
    readonly controlPoints: BeatmapControlPoints;
    readonly colors: BeatmapColor;
    hitObjects: BeatmapHitObjects;
    constructor(shallowCopy?: Beatmap);
    /**
     * The maximum combo of the beatmap.
     */
    get maxCombo(): number;
    /**
     * The most common beat length of the beatmap.
     */
    get mostCommonBeatLength(): number;
    /**
     * Returns a time combined with beatmap-wide time offset.
     *
     * BeatmapVersion 4 and lower had an incorrect offset. Stable has this set as 24ms off.
     *
     * @param time The time.
     */
    getOffsetTime(time: number): number;
    /**
     * Calculates the osu!droid maximum score of the beatmap without taking spinner bonus into account.
     *
     * @param mods The modifications to calculate for. Defaults to No Mod.
     */
    maxDroidScore(mods?: ModMap): number;
    /**
     * Calculates the osu!standard maximum score of the beatmap without taking spinner bonus into account.
     *
     * @param mods The modifications to calculate for. Defaults to No Mod.
     */
    maxOsuScore(mods?: ModMap): number;
    /**
     * Constructs a `DroidPlayableBeatmap` from this `Beatmap`.
     *
     * The returned `DroidPlayableBeatmap` is in a playable state - all `HitObject` and `BeatmapDifficulty`
     * `Mod`s have been applied, and `HitObject`s have been fully constructed.
     *
     * @param mods The `Mod`s to apply to the `Beatmap`. Defaults to No Mod.
     * @return The constructed `DroidPlayableBeatmap`.
     */
    createDroidPlayableBeatmap(mods?: ModMap): DroidPlayableBeatmap;
    /**
     * Constructs a `OsuPlayableBeatmap` from this `Beatmap`.
     *
     * The returned `OsuPlayableBeatmap` is in a playable state - all `HitObject` and `BeatmapDifficulty`
     * `Mod`s have been applied, and `HitObject`s have been fully constructed.
     *
     * @param mods The `Mod`s to apply to the `Beatmap`. Defaults to No Mod.
     * @return The constructed `OsuPlayableBeatmap`.
     */
    createOsuPlayableBeatmap(mods?: ModMap): OsuPlayableBeatmap;
    private createPlayableBeatmap;
    /**
     * Returns a string representative of the class.
     */
    toString(): string;
}

/**
 * Converts a beatmap for another mode.
 */
declare class BeatmapConverter {
    readonly beatmap: Beatmap;
    constructor(beatmap: Beatmap);
    /**
     * Converts the beatmap.
     *
     * @returns The converted beatmap.
     */
    convert(): Beatmap;
    private convertHitObjects;
    private convertHitObject;
}

/**
 * Sections that exist in `.osu` and `.osb` files.
 */
declare enum BeatmapSection {
    general = "General",
    editor = "Editor",
    metadata = "Metadata",
    difficulty = "Difficulty",
    events = "Events",
    variables = "Variables",
    timingPoints = "TimingPoints",
    colors = "Colours",
    hitObjects = "HitObjects"
}

/**
 * The base of all decoders.
 */
declare abstract class SectionDecoder<T> {
    /**
     * The string in the line at which the decoder is processing.
     */
    private lastPosition;
    /**
     * The target of the decoding process.
     */
    protected target: T;
    /**
     * The first version of beatmaps exported from osu!lazer.
     */
    static readonly firstLazerVersion = 128;
    protected readonly formatVersion: number;
    constructor(target: T, formatVersion?: number);
    /**
     * Performs a decoding process.
     *
     * @param line The line to decode.
     * @returns The result.
     */
    decode(line: string): T;
    /**
     * Logs the position at the line at which an exception occurs.
     */
    logExceptionPosition(): string;
    /**
     * Processes a property of the beatmap. This takes the current line as parameter.
     *
     * For example, `ApproachRate:9` will be split into `[ApproachRate, 9]`.
     */
    protected property(line: string): string[];
    /**
     * Sets the last position of the current decoder state.
     *
     * This is useful to debug syntax errors.
     */
    protected setPosition(str: string): string;
    /**
     * Internal decoder function for decoding the target.
     *
     * @param line The line to decode.
     */
    protected abstract decodeInternal(line: string): void;
    /**
     * Attempts to parse a string into an integer.
     *
     * Throws an exception when the resulting value is invalid (such as NaN), too low, or too high.
     *
     * @param str The string to parse.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     * @param allowNaN Whether to allow NaN.
     * @returns The parsed integer.
     */
    protected tryParseInt(str: string, min?: number, max?: number, allowNaN?: boolean): number;
    /**
     * Attempts to parse a string into a float.
     *
     * Throws an exception when the resulting value is too low or too high.
     *
     * @param str The string to parse.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     * @param allowNaN Whether to allow NaN.
     * @returns The parsed float.
     */
    protected tryParseFloat(str: string, min?: number, max?: number, allowNaN?: boolean): number;
    /**
     * Checks if a number is within a given threshold.
     *
     * @param num The number to check.
     * @param min The minimum threshold. Defaults to `-ParserConstants.MAX_PARSE_VALUE`.
     * @param max The maximum threshold. Defaults to `ParserConstants.MAX_PARSE_VALUE`.
     */
    protected isNumberValid(num: number, min?: number, max?: number): boolean;
}

/**
 * The base of main decoders.
 */
declare abstract class Decoder<R, D extends SectionDecoder<R>> {
    /**
     * The result of the decoding process.
     */
    protected abstract finalResult: R;
    /**
     * The result of the decoding process.
     */
    get result(): R;
    static readonly latestVersion = 14;
    /**
     * The format version of the decoded target.
     */
    protected formatVersion: number;
    /**
     * Available per-section decoders, mapped by its section name.
     */
    protected abstract decoders: Partial<Record<BeatmapSection, D>>;
    /**
     * The amount of lines of the file that have been processed up to this point.
     */
    protected line: number;
    /**
     * The currently processed line.
     */
    protected currentLine: string;
    /**
     * The currently processed section.
     */
    protected section: BeatmapSection;
    /**
     * Performs the decoding process.
     *
     * @param str The string to decode.
     * @returns The current decoder instance.
     */
    decode(str: string): this;
    /**
     * Determines whether a line should be skipped.
     *
     * @param line The line to determine.
     * @returns Whether the line should be skipped.
     */
    protected shouldSkipLine(line: string): boolean;
    /**
     * Internal decoder function for decoding a line.
     *
     * @param line The line to decode.
     */
    protected decodeLine(line: string): void;
    /**
     * Resets this decoder's instance.
     */
    protected reset(): void;
}

/**
 * A beatmap decoder.
 */
declare class BeatmapDecoder extends Decoder<Beatmap, SectionDecoder<Beatmap>> {
    protected finalResult: Beatmap;
    protected decoders: Partial<Record<BeatmapSection, SectionDecoder<Beatmap>>>;
    /**
     * @param str The string to decode.
     * @param mode The mode to parse the beatmap as. Defaults to osu!standard.
     * @param parseStoryboard Whether to parse the beatmap's storyboard.
     */
    decode(str: string, mode?: Modes, parseStoryboard?: boolean): this;
    protected decodeLine(line: string): void;
    protected reset(): void;
}

/**
 * The base of all encoders.
 */
declare abstract class BaseEncoder {
    /**
     * The target of the encoding process.
     */
    protected result: string;
    /**
     * Whether sections should be encoded. Defaults to `true`.
     */
    readonly encodeSections: boolean;
    constructor(encodeSections?: boolean);
    /**
     * Performs the encoding process.
     *
     * @returns The result.
     */
    encode(): string;
    /**
     * Internal encoder function for encoding the target.
     */
    protected abstract encodeInternal(): void;
    /**
     * Writes a line to encoded text.
     *
     * @param line The line to write.
     */
    protected write(line: string): void;
    /**
     * Writes a line to encoded text, followed by a line feed character (`\n`).
     *
     * @param line The line to write.
     */
    protected writeLine(line?: string): void;
}

/**
 * The base of main encoders.
 */
declare abstract class Encoder<T, E extends BaseEncoder> {
    /**
     * The target of the encoding process.
     */
    protected target: T;
    /**
     * The result of the encoding process.
     */
    protected finalResult: string;
    /**
     * The result of the encoding process.
     */
    get result(): string;
    /**
     * Available per-section encoders.
     */
    protected abstract encoders: E[];
    /**
     * @param target The target of the encoding process.
     */
    constructor(target: T);
    /**
     * Performs the decoding process.
     *
     * Keep in mind that this will not produce the exact same file as the original decoded file.
     */
    encode(): this;
    /**
     * Writes a line to encoded text.
     *
     * @param line The line to write.
     */
    protected writeLine(line?: string): void;
    /**
     * Internal encoder function to encode the target to a string.
     */
    protected encodeInternal(): void;
    /**
     * Resets this encoder's instance.
     */
    protected abstract reset(): void;
}

/**
 * The base of per-section beatmap encoders.
 */
declare abstract class BeatmapBaseEncoder extends BaseEncoder {
    /**
     * The beatmap that is being encoded.
     */
    readonly map: Beatmap;
    constructor(map: Beatmap, encodeSections?: boolean);
    /**
     * Converts a sample bank to its string equivalent.
     *
     * @param sampleBank The sample bank.
     */
    protected sampleBankToString(sampleBank: SampleBank): string;
}

/**
 * A beatmap encoder.
 *
 * Note that this beatmap encoder does not encode storyboards, and as such equality with the
 * original beatmap file is not guaranteed (and usually will not be equal).
 */
declare class BeatmapEncoder extends Encoder<Beatmap, BeatmapBaseEncoder> {
    protected encoders: BeatmapBaseEncoder[];
    private readonly latestVersion;
    protected encodeInternal(): void;
    /**
     * Resets this encoder's instance.
     */
    protected reset(): void;
}

/**
 * Available genres in an online osu! beatmap.
 */
declare enum BeatmapGenre {
    any = 0,
    unspecified = 1,
    videoGame = 2,
    anime = 3,
    rock = 4,
    pop = 5,
    other = 6,
    novelty = 7,
    hipHop = 9,
    electronic = 10,
    metal = 11,
    classical = 12,
    folk = 13,
    jazz = 14
}

/**
 * Available languages in an online osu! beatmap.
 */
declare enum BeatmapLanguage {
    any = 0,
    unspecified = 1,
    english = 2,
    japanese = 3,
    chinese = 4,
    instrumental = 5,
    korean = 6,
    french = 7,
    german = 8,
    swedish = 9,
    spanish = 10,
    italian = 11,
    russian = 12,
    polish = 13,
    other = 14
}

/**
 * Provides functionality to alter a beatmap after it has been converted.
 */
declare class BeatmapProcessor {
    private static readonly stackDistance;
    /**
     * The beatmap to process. This should already be converted to the applicable mode.
     */
    readonly beatmap: Beatmap;
    constructor(beatmap: Beatmap);
    /**
     * Processes the converted beatmap prior to `HitObject.applyDefaults` being invoked.
     *
     * Nested hitobjects generated during `HitObject.applyDefaults` will not be present by this point,
     * and no mods will have been applied to the hitobjects.
     *
     * This can only be used to add alterations to hitobjects generated directly through the conversion process.
     */
    preProcess(): void;
    /**
     * Processes the converted beatmap after `HitObject.applyDefaults` has been invoked.
     *
     * Nested hitobjects generated during `HitObject.applyDefaults` wil be present by this point,
     * and mods will have been applied to all hitobjects.
     *
     * This should be used to add alterations to hitobjects while they are in their most playable state.
     */
    postProcess(): void;
    private applyStacking;
    private applyOldStacking;
}

/**
 * Determines how color blending should be done.
 */
declare enum BlendingEquation {
    /**
     * Inherits from parent.
     */
    inherit = 0,
    /**
     * Adds the source and destination colours.
     */
    add = 1,
    /**
     * Chooses the minimum of each component of the source and destination colours.
     */
    min = 2,
    /**
     * Chooses the maximum of each component of the source and destination colours.
     */
    max = 3,
    /**
     * Subtracts the destination colour from the source colour.
     */
    subtract = 4,
    /**
     * Subtracts the source colour from the destination colour.
     */
    reverseSubtract = 5
}

/**
 * Determines how a blend operation should be done.
 */
declare enum BlendingType {
    inherit = 0,
    constantAlpha = 1,
    constantColor = 2,
    dstAlpha = 3,
    dstColor = 4,
    one = 5,
    oneMinusConstantAlpha = 6,
    oneMinusConstantColor = 7,
    oneMinusDstAlpha = 8,
    oneMinusDstColor = 9,
    oneMinusSrcAlpha = 10,
    oneMinusSrcColor = 11,
    srcAlpha = 12,
    srcAlphaSaturate = 13,
    srcColor = 14,
    zero = 15
}

/**
 * Contains information about how a blend mode operation should be blended into its destination.
 */
declare class BlendingParameters {
    /**
     * The blending factor for the source color of the blend.
     */
    source: BlendingType;
    /**
     * The blending factor for the destination color of the blend.
     */
    destination: BlendingType;
    /**
     * The blending factor for the source alpha of the blend.
     */
    sourceAlpha: BlendingType;
    /**
     * The blending factor for the destination alpha of the blend.
     */
    destinationAlpha: BlendingType;
    /**
     * Gets or sets the blending equation to use for the RGB components of the blend.
     */
    rgbEquation: BlendingEquation;
    /**
     * Gets or sets the blending equation to use for the alpha component of the blend.
     */
    alphaEquation: BlendingEquation;
    static readonly none: BlendingParameters;
    static readonly inherit: BlendingParameters;
    static readonly mixture: BlendingParameters;
    static readonly additive: BlendingParameters;
    constructor(source: BlendingType, destination: BlendingType, sourceAlpha: BlendingType, destinationAlpha: BlendingType, rgbEquation: BlendingEquation, alphaEquation: BlendingEquation);
}

/**
 * Represents a `Mod` specific setting that is constrained to a boolean value.
 */
declare class BooleanModSetting extends ModSetting<boolean> {
    readonly displayFormatter: (value: boolean) => string;
}

/**
 * Represents root bounds.
 *
 * Used in the Brent root-finding algorithm.
 */
interface RootBounds {
    /**
     * The low value of the range where the root is supposed to be. Can be expanded if needed.
     */
    lowerBound: number;
    /**
     * The high value of the range where the root is supposed to be. Can be expanded if needed.
     */
    upperBound: number;
}

/**
 * Algorithm by Brent, Van Wijngaarden, Dekker et al.
 *
 * Implementation inspired by Press, Teukolsky, Vetterling, and Flannery, "Numerical Recipes in C", 2nd edition, Cambridge University Press.
 */
declare abstract class Brent {
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Defaults to 1e-8. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Defaults to 100.
     * @param expandFactor The factor at which to expand the bounds, if needed. Defaults to 1.6.
     * @param maxExpandIterations The maximum number of expand iterations. Defaults to 100.
     * @returns The root with the specified accuracy. Throws an error if the algorithm failed to converge.
     */
    static findRootExpand(f: (x: number) => number, bounds: RootBounds, accuracy?: number, maxIterations?: number, expandFactor?: number, maxExpandIterations?: number): number;
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Defaults to 1e-8. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Defaults to 100.
     * @returns The root with the specified accuracy. Throws an error if the algorithm failed to converge.
     */
    static findRoot(f: (x: number) => number, bounds: RootBounds, accuracy?: number, maxIterations?: number): number;
    /**
     * Finds a solution to the equation f(x) = 0.
     *
     * @param f The function to find roots from.
     * @param bounds The upper and lower root bounds.
     * @param accuracy The desired accuracy. The root will be refined until the accuracy or the maximum number of iterations is reached. Must be greater than 0.
     * @param maxIterations The maximum number of iterations. Usually 100.
     * @returns The root with the specified accuracy, `null` if not found.
     */
    static tryFindRoot(f: (x: number) => number, bounds: RootBounds, accuracy: number, maxIterations: number): number | null;
    /**
     * Helper method useful for preventing rounding errors.
     *
     * @returns a * sign(b)
     */
    static sign(a: number, b: number): number;
}

/**
 * A utility class for calculating circle sizes across all modes (rimu! and osu!standard).
 */
declare abstract class CircleSizeCalculator {
    /**
     * The following comment is copied verbatim from osu!lazer and osu!stable:
     *
     * > Builds of osu! up to 2013-05-04 had the gamefield being rounded down, which caused incorrect radius calculations
     * > in widescreen cases. This ratio adjusts to allow for old replays to work post-fix, which in turn increases the lenience
     * > for all plays, but by an amount so small it should only be effective in replays.
     *
     * To match expectations of gameplay we need to apply this multiplier to circle scale. It's weird but is what it is.
     * It works out to under 1 game pixel and is generally not meaningful to gameplay, but is to replay playback accuracy.
     */
    static readonly brokenGamefieldRoundingAllowance = 1.00041;
    /**
     * This was not the real height that is used in the game, but rather an assumption so that we can treat circle sizes
     * similarly across all devices. This is used in difficulty calculation.
     */
    static readonly oldAssumedDroidHeight = 681;
    private static readonly oldDroidScaleMultiplier;
    /**
     * Converts osu!droid circle size to osu!droid scale.
     *
     * @param cs The circle size to convert.
     * @returns The calculated osu!droid scale.
     */
    static droidCSToDroidScale(cs: number): number;
    /**
     * Converts osu!droid scale to osu!droid circle size.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The calculated osu!droid circle size.
     */
    static droidScaleToDroidCS(scale: number): number;
    /**
     * Converts osu!droid CS to old osu!droid scale.
     *
     * @param cs The CS to convert.
     * @param mods The mods to apply.
     * @returns The calculated osu!droid scale.
     */
    static droidCSToOldDroidScale(cs: number, mods?: ModMap): number;
    /**
     * Converts old osu!droid scale to osu!droid circle size.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The calculated osu!droid circle size.
     */
    static oldDroidScaleToDroidCS(scale: number): number;
    /**
     * Converts old osu!droid difficulty scale that is in **screen pixels** to **osu!pixels**.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The converted scale.
     */
    static oldDroidScaleScreenPixelsToOsuPixels(scale: number): number;
    /**
     * Converts old osu!droid scale that is in **osu!pixels** to **screen pixels**.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The converted scale.
     */
    static oldDroidScaleOsuPixelsToScreenPixels(scale: number): number;
    /**
     * Converts old osu!droid scale to osu!standard radius.
     *
     * @param scale The osu!droid scale to convert.
     * @returns The osu!standard radius of the given osu!droid scale.
     */
    static oldDroidScaleToStandardRadius(scale: number): number;
    /**
     * Converts osu!standard radius to old osu!droid scale.
     *
     * @param radius The osu!standard radius to convert.
     * @returns The osu!droid scale of the given osu!standard radius.
     */
    static standardRadiusToOldDroidScale(radius: number): number;
    /**
     * Converts osu!standard circle size to osu!standard scale.
     *
     * @param cs The osu!standard circle size to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard scale of the given circle size.
     */
    static standardCSToStandardScale(cs: number, applyFudge?: boolean): number;
    /**
     * Converts osu!standard scale to osu!standard circle size.
     *
     * @param scale The osu!standard scale to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard circle size of the given scale.
     */
    static standardScaleToStandardCS(scale: number, applyFudge?: boolean): number;
    /**
     * Converts osu!standard radius to osu!standard circle size.
     *
     * @param radius The osu!standard radius to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The osu!standard circle size of the given radius.
     */
    static standardRadiusToStandardCS(radius: number, applyFudge?: boolean): number;
    /**
     * Converts osu!standard scale to old osu!droid scale.
     *
     * @param scale The osu!standard scale to convert.
     * @param applyFudge Whether to apply a fudge that was historically applied to osu!standard. Defaults to `false`.
     * @returns The old osu!droid scale of the given osu!standard scale.
     */
    static standardScaleToOldDroidScale(scale: number, applyFudge?: boolean): number;
}

/**
 * Types of easing.
 *
 * See {@link http://easings.net/ this} page for more samples.
 */
declare enum Easing {
    none = 0,
    out = 1,
    in = 2,
    inQuad = 3,
    outQuad = 4,
    inOutQuad = 5,
    inCubic = 6,
    outCubic = 7,
    inOutCubic = 8,
    inQuart = 9,
    outQuart = 10,
    inOutQuart = 11,
    inQuint = 12,
    outQuint = 13,
    inOutQuint = 14,
    inSine = 15,
    outSine = 16,
    inOutSine = 17,
    inExpo = 18,
    outExpo = 19,
    inOutExpo = 20,
    inCirc = 21,
    outCirc = 22,
    inOutCirc = 23,
    inElastic = 24,
    outElastic = 25,
    outElasticHalf = 26,
    outElasticQuarter = 27,
    inOutElastic = 28,
    inBack = 29,
    outBack = 30,
    inOutBack = 31,
    inBounce = 32,
    outBounce = 33,
    inOutBounce = 34,
    outPow10 = 35
}

/**
 * Available storyboard command types.
 */
declare enum StoryboardCommandType {
    movement = "M",
    movementX = "MX",
    movementY = "MY",
    fade = "F",
    scale = "S",
    vectorScale = "V",
    rotation = "R",
    color = "C",
    parameter = "P",
    loop = "L",
    trigger = "T"
}

/**
 * Available storyboard parameter command types.
 */
declare enum StoryboardParameterCommandType {
    horizontalFlip = "H",
    verticalFlip = "V",
    blendingMode = "A"
}

/**
 * Represents a storyboard command.
 */
declare class Command<T> {
    /**
     * The type of the command.
     */
    readonly type: StoryboardCommandType;
    /**
     * The parameter type of the command.
     */
    readonly parameterType?: StoryboardParameterCommandType;
    /**
     * The easing of the command.
     */
    easing: Easing;
    /**
     * The time at which the command starts.
     */
    startTime: number;
    /**
     * The time at which the command ends.
     */
    endTime: number;
    /**
     * The start value of the command.
     */
    startValue: T;
    /**
     * The end value of the command.
     */
    endValue: T;
    /**
     * The duration of the command.
     */
    get duration(): number;
    constructor(easing: Easing, startTime: number, endTime: number, startValue: T, endValue: T, type: StoryboardCommandType, parameterType?: StoryboardParameterCommandType);
    /**
     * Whether this command is a parameter command.
     */
    isParameter(): this is this & {
        readonly parameterType: StoryboardParameterCommandType;
    };
    toString(): string;
}

/**
 * Represents a command timeline.
 *
 * A command timeline contains all commands that occur within a set period of time.
 */
interface ICommandTimeline {
    /**
     * The start time of the command timeline.
     */
    get startTime(): number;
    /**
     * The end time of the command timeline.
     */
    get endTime(): number;
    /**
     * Whether this command timeline has at least one command.
     */
    get hasCommands(): boolean;
}
/**
 * Represents a command timeline.
 *
 * A command timeline contains all commands of the same type that occur in a sprite.
 */
declare class CommandTimeline<T> implements ICommandTimeline {
    /**
     * The type of the command timeline.
     */
    readonly type: StoryboardCommandType;
    /**
     * The parameter command type of the command timeline.
     */
    readonly parameterType?: StoryboardParameterCommandType;
    private _commands;
    private _startTime;
    private _endTime;
    private _startValue;
    private _endValue;
    /**
     * The commands in this command timeline.
     */
    get commands(): Command<T>[];
    get startTime(): number;
    get endTime(): number;
    /**
     * The start value of the command timeline.
     */
    get startValue(): T | null;
    /**
     * The end value of the command timeline.
     */
    get endValue(): T | null;
    get hasCommands(): boolean;
    constructor(type: StoryboardCommandType, parameterType?: StoryboardParameterCommandType);
    /**
     * Adds a command to this command timeline.
     *
     * @param easing The easing to apply.
     * @param startTime The start time of the command.
     * @param endTime The end time of the command.
     * @param startValue The start value of the command.
     * @param endValue The end value of the command.
     */
    add(easing: Easing, startTime: number, endTime: number, startValue: T, endValue: T): void;
}

/**
 * Represents a group of command timelines.
 */
declare class CommandTimelineGroup {
    /**
     * The command timeline that changes an animation or sprite's X and Y coordinates.
     */
    move: CommandTimeline<Vector2>;
    /**
     * The command timeline that changes an animation or sprite's X-coordinate.
     */
    x: CommandTimeline<number>;
    /**
     * The command timeline that changes an animation or sprite's Y-coordinate.
     */
    y: CommandTimeline<number>;
    /**
     * The command timeline that scales an animation or sprite with a number.
     */
    scale: CommandTimeline<number>;
    /**
     * The command timeline that scales an animation or sprite with a vector.
     *
     * This allows scaling the width and height of an animation or sprite individually at the same time.
     */
    vectorScale: CommandTimeline<Vector2>;
    /**
     * The command timeline that rotates an animation or sprite, in radians, clockwise.
     */
    rotation: CommandTimeline<number>;
    /**
     * The command timeline that changes an animation or sprite's virtual light source color.
     *
     * The colors of the pixels on the animation or sprite are determined subtractively.
     */
    color: CommandTimeline<RGBColor>;
    /**
     * The command timeline that changes the opacity of an animation or sprite.
     */
    alpha: CommandTimeline<number>;
    /**
     * The command timeline that determines the blending behavior of an animation or sprite.
     */
    blendingParameters: CommandTimeline<BlendingParameters>;
    /**
     * The command timeline that determines whether the animation or sprite should be flipped horizontally.
     */
    flipHorizontal: CommandTimeline<boolean>;
    /**
     * The command timeline that determines whether the animation or sprite should be flipped vertically.
     */
    flipVertical: CommandTimeline<boolean>;
    private readonly timelines;
    /**
     * The start time of commands.
     */
    get commandsStartTime(): number;
    /**
     * The end time of commands.
     */
    get commandsEndTime(): number;
    /**
     * The duration of commands.
     */
    get commandsDuration(): number;
    /**
     * The start time of the command timeline group.
     */
    get startTime(): number;
    /**
     * The end time of the command timeline group.
     */
    get endTime(): number;
    /**
     * The duration of the command timeline group.
     */
    get duration(): number;
    /**
     * Whether this command timeline group has at least one command.
     */
    get hasCommands(): boolean;
    /**
     * Gets the commands from a command timeline.
     *
     * @param timelineSelector A function to select the command timeline to retrieve commands from.
     * @param offset The offset to apply to all commands.
     */
    getCommands<T>(timelineSelector: CommandTimelineSelector<T>, offset?: number): Command<T>[];
}
type CommandTimelineSelector<T> = (timelineGroup: CommandTimelineGroup) => CommandTimeline<T>;

/**
 * Represents a loop compound command.
 */
declare class CommandLoop extends CommandTimelineGroup {
    /**
     * The start time of the loop command.
     */
    loopStartTime: number;
    /**
     * The total number of times this loop is played back. Always greater than zero.
     */
    readonly totalIterations: number;
    get startTime(): number;
    get endTime(): number;
    constructor(startTime: number, repeatCount: number);
    getCommands<T>(timelineSelector: CommandTimelineSelector<T>, offset?: number): Command<T>[];
    toString(): string;
}

/**
 * Represents a trigger command.
 */
declare class CommandTrigger extends CommandTimelineGroup {
    /**
     * The name of the trigger.
     */
    triggerName: string;
    /**
     * The start time of the command.
     */
    triggerStartTime: number;
    /**
     * The end time of the command.
     */
    triggerEndTime: number;
    /**
     * The group number of the command.
     */
    groupNumber: number;
    constructor(triggerName: string, startTime: number, endTime: number, groupNumber: number);
    toString(): string;
}

/**
 * Represents a `Mod` specific setting that is constrained to a range of values.
 */
declare abstract class RangeConstrainedModSetting<T> extends ModSetting<T> {
    private _min;
    /**
     * The minimum value of this `RangeConstrainedModSetting`.
     */
    get min(): T;
    set min(value: T);
    private _max;
    /**
     * The maximum value of this `RangeConstrainedModSetting`.
     */
    get max(): T;
    set max(value: T);
    private _step;
    /**
     * The step size of this `RangeConstrainedModSetting`.
     */
    get step(): T;
    set step(value: T);
    get value(): T;
    set value(value: T);
    constructor(name: string, description: string, defaultValue: T, min: T, max: T, step: T);
    /**
     * Processes the value of this `RangeConstrainedModSetting` to ensure it is within the range and
     * step size.
     *
     * @param value The value to process.
     */
    protected abstract processValue(value: T): T;
}

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 */
declare class NumberModSetting extends RangeConstrainedModSetting<number> {
    readonly displayFormatter: (v: number) => string;
    constructor(name: string, description: string, defaultValue: number, min: number, max: number, step: number);
    protected processValue(value: number): number;
}

/**
 * Represents a `Mod` specific setting that is constrained to a range of decimal values.
 */
declare class DecimalModSetting extends NumberModSetting {
    private _precision;
    /**
     * The number of decimal places to round the value to.
     *
     * When set to `null`, the value will not be rounded.
     */
    get precision(): number | null;
    set precision(value: number | null);
    readonly displayFormatter: (v: number) => string;
    constructor(name: string, description: string, defaultValue: number, min?: number, max?: number, step?: number, precision?: number | null);
    protected processValue(value: number): number;
}

/**
 * Represents the structure of a response from a network request.
 */
interface RequestResponse {
    /**
     * The result of the API request.
     */
    readonly data: Buffer;
    /**
     * The status code of the API request.
     */
    readonly statusCode: number;
}

/**
 * The base of API request builders.
 */
declare abstract class APIRequestBuilder<Params extends string = string> {
    /**
     * The main point of API host.
     */
    protected abstract readonly host: string;
    /**
     * The API key for this builder.
     */
    protected abstract readonly APIkey: string;
    /**
     * The parameter for API key requests.
     */
    protected abstract readonly APIkeyParam: string;
    /**
     * Whether or not to include the API key in the request URL.
     */
    protected requiresAPIkey: boolean;
    /**
     * The endpoint of this builder.
     */
    protected endpoint: string;
    /**
     * The parameters of this builder.
     */
    protected readonly params: Map<string, string>;
    /**
     * The base URL of this builder.
     */
    protected get baseURL(): string;
    private fetchAttempts;
    /**
     * Sets the API endpoint.
     *
     * @param endpoint The endpoint to set.
     */
    setEndpoint(endpoint: Params): this;
    /**
     * Sets if this builder includes the API key in the request URL.
     *
     * @param requireAPIkey Whether or not to include the API key in the request URL.
     */
    setRequireAPIkey(requireAPIkey: boolean): this;
    /**
     * Builds the URL to request the API.
     */
    buildURL(): string;
    /**
     * Sends a request to the API using built parameters.
     *
     * If the request fails, it will be redone 5 times.
     */
    sendRequest(): Promise<RequestResponse>;
    /**
     * Adds a parameter to the builder.
     *
     * @param param The parameter to add.
     * @param value The value to add for the parameter.
     */
    addParameter(param: string, value: string | number): this;
    /**
     * Removes a parameter from the builder.
     *
     * @param param The parameter to remove.
     */
    removeParameter(param: string): this;
}

/**
 * Available endpoints for osu!droid API.
 */
type DroidAPIEndpoint = "getuserinfo.php" | "scoresearch.php" | "scoresearchv2.php" | "upload" | "bestpp" | "user_list.php" | "usergeneral.php" | "top.php" | "time.php" | "account_ban_get.php" | "account_ban_set.php" | "account_restricted_get.php" | "account_restricted_set.php" | "single_score_wipe.php" | "user_wipe.php" | "user_rename.php";
/**
 * An API request builder for osu!droid.
 */
declare class DroidAPIRequestBuilder extends APIRequestBuilder<DroidAPIEndpoint> {
    private static apiKey;
    /**
     * Sets the API key for all subsequent initializations of a `DroidAPIRequestBuilder`.
     *
     * @param key The API key.
     */
    static setAPIKey(key: string): void;
    protected readonly host = "https://osudroid.moe/api/";
    protected readonly APIkey: string;
    protected readonly APIkeyParam: string;
    buildURL(): string;
}

/**
 * Represents the hit window of osu!droid _without_ the Precise mod.
 */
declare class DroidHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a meh (50) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value: number): number;
    get greatWindow(): number;
    get okWindow(): number;
    get mehWindow(): number;
}

/**
 * A set of utilities to handle legacy mods storage conversion to the new storage format in osu!droid.
 */
declare abstract class DroidLegacyModConverter {
    /**
     * All `Mod`s that can be stored in the legacy mods format by their respective encode character.
     */
    static readonly legacyStorableMods: ReadonlyMap<string, new () => Mod & IModApplicableToDroid>;
    /**
     * Converts a legacy mod string to an array of `Mod`s.
     *
     * @param str The mod string to convert.
     * @param difficulty The `BeatmapDifficulty` to use for `IMigratableDroidMod` migrations. When omitted, `IMigratableDroidMod`s will not be migrated.
     * @returns An array of `Mod`s.
     */
    static convert(str?: string, difficulty?: BeatmapDifficulty): ModMap;
    /**
     * Parses the extra strings of a mod string.
     *
     * @param map The current `Mod`s.
     * @param extraStrings The extra strings to parse.
     */
    static parseExtraModString(map: ModMap, extraStrings: string[]): void;
}

/**
 * An empty `HitWindow` that does not have any hit windows.
 *
 * No time values are provided (meaning instantaneous hit or miss).
 */
declare class EmptyHitWindow extends HitWindow {
    constructor();
    get greatWindow(): number;
    get okWindow(): number;
    get mehWindow(): number;
}

/**
 * A Math utility class containing all methods related to the error function.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
declare abstract class ErrorFunction {
    /**
     * Polynomial coefficients for a numerator of erfImp
     * calculation for erf(x) in the interval [1e-10, 0.5].
     */
    private static readonly erfImpAn;
    /**
     * Polynomial coefficients for a denominator of erfImp
     * calculation for erf(x) in the interval [1e-10, 0.5].
     */
    private static readonly erfImpAd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculationfor erfc(x) in the interval [0.5, 0.75].
     */
    private static readonly erfImpBn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for Erfc(x) in the interval [0.5, 0.75].
     */
    private static readonly erfImpBd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [0.75, 1.25].
     */
    private static readonly erfImpCn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [0.75, 1.25].
     */
    private static readonly erfImpCd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [1.25, 2.25].
     */
    private static readonly erfImpDn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [1.25, 2.25].
     */
    private static readonly erfImpDd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [2.25, 3.5].
     */
    private static readonly erfImpEn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [2.25, 3.5].
     */
    private static readonly erfImpEd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [3.5, 5.25].
     */
    private static readonly erfImpFn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [3.5, 5.25].
     */
    private static readonly erfImpFd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [5.25, 8].
     */
    private static readonly erfImpGn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [5.25, 8].
     */
    private static readonly erfImpGd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [8, 11.5].
     */
    private static readonly erfImpHn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [8, 11.5].
     */
    private static readonly erfImpHd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [11.5, 17].
     */
    private static readonly erfImpIn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [11.5, 17].
     */
    private static readonly erfImpId;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [17, 24].
     */
    private static readonly erfImpJn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [17, 24].
     */
    private static readonly erfImpJd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [24, 38].
     */
    private static readonly erfImpKn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [24, 38].
     */
    private static readonly erfImpKd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [38, 60].
     */
    private static readonly erfImpLn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [38, 60].
     */
    private static readonly erfImpLd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [60, 85].
     */
    private static readonly erfImpMn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [60, 85].
     */
    private static readonly erfImpMd;
    /**
     * Polynomial coefficients for a numerator in erfImp
     * calculation for erfc(x) in the interval [85, 110].
     */
    private static readonly erfImpNn;
    /**
     * Polynomial coefficients for a denominator in erfImp
     * calculation for erfc(x) in the interval [85, 110].
     */
    private static readonly erfImpNd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0, 0.5].
     */
    private static readonly ervInvImpAn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0, 0.5].
     */
    private static readonly ervInvImpAd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.5, 0.75].
     */
    private static readonly ervInvImpBn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.5, 0.75].
     */
    private static readonly ervInvImpBd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x less than 3.
     */
    private static readonly ervInvImpCn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x less than 3.
     */
    private static readonly ervInvImpCd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 3 and 6.
     */
    private static readonly ervInvImpDn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 3 and 6.
     */
    private static readonly ervInvImpDd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 6 and 18.
     */
    private static readonly ervInvImpEn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 6 and 18.
     */
    private static readonly ervInvImpEd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 18 and 44.
     */
    private static readonly ervInvImpFn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x between 18 and 44.
     */
    private static readonly ervInvImpFd;
    /**
     * Polynomial coefficients for a numerator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x greater than 44.
     */
    private static readonly ervInvImpGn;
    /**
     * Polynomial coefficients for a denominator of erfInvImp
     * calculation for erf^-1(z) in the interval [0.75, 1] with x greater than 44.
     */
    private static readonly ervInvImpGd;
    /**
     * Calculates the error function evaluated at `x`.
     *
     * @param x The value to evaluate.
     * @returns The error function evaluated at `x`, or:
     * - 1 if `x == Number.POSITIVE_INFINITY`;
     * - -1 if `x == Number.NEGATIVE_INFINITY`.
     */
    static erf(x: number): number;
    /**
     * Calculates the complementary error function evaluated at `x`.
     *
     * @param x The value to evaluate.
     * @returns The complementary error function evaluated at `x`, or:
     * - 0 if `x === Number.POSITIVE_INFINITY`;
     * - 2 if `x === Number.NEGATIVE_INFINITY`.
     */
    static erfc(x: number): number;
    /**
     * Calculates the inverse error function evaluated at `z`.
     *
     * @param z The value to evaluate.
     * @returns The inverse error function evaluated at `z`, or:
     * - `Number.POSITIVE_INFINITY` if `z >= 1`;
     * - `Number.NEGATIVE_INFINITY` if `z <= -1`.
     */
    static erfInv(z: number): number;
    /**
     * Calculates the complementary inverse error function evaluated at `z`.
     *
     * This implementation has been tested against the arbitrary precision mpmath library
     * and found cases where only 9 significant figures correct can be guaranteed.
     *
     * @param z The value to evaluate.
     * @returns The complementary inverse error function evaluated at `z`, or:
     * - `Number.POSITIVE_INFINITY` if `z <= 0`;
     * - `Number.NEGATIVE_INFINITY` if `z >= -2`.
     */
    static erfcInv(z: number): number;
    /**
     * The implementation of the error function.
     *
     * @param z Where to evaluate the error function.
     * @param invert Whether to compute 1 - the error function.
     * @returns The error function.
     */
    private static erfImp;
    /**
     * The implementation of the inverse error function.
     *
     * @param p The first intermediate parameter.
     * @param q The second intermediate parameter.
     * @param s The third intermediate parameter.
     * @returns The inverse error function.
     */
    private static erfInvImp;
}

/**
 * Represents a custom gameplay hit sample that can be loaded from files.
 */
declare class FileHitSampleInfo extends HitSampleInfo {
    /**
     * The name of the file to load the sample from.
     */
    readonly filename: string;
    get lookupNames(): string[];
    constructor(filename: string, volume?: number);
}

/**
 * A pseudo-random number generator that shares the same implementation with
 * {@link https://github.com/dotnet/runtime/blob/v9.0.4/src/libraries/System.Private.CoreLib/src/System/Random.Net5CompatImpl.cs .NET 5's `System.Random`}.
 *
 * Used in the Random mod to ensure that a seed generates the result that users expect.
 */
declare class Random {
    private static readonly MIN_VALUE;
    private static readonly MAX_VALUE;
    private readonly seedArray;
    private iNext;
    private iNextP;
    /**
     * Constructs a new instance of the `Random` class using the specified seed.
     *
     * @param seed The seed to use for the random number generator. This value is clamped to the range [-2147483648, 2147483647] and must be an integer.
     */
    constructor(seed: number);
    nextDouble(): number;
    private sample;
    private internalSample;
}

/**
 * Represents a four-dimensional vector.
 */
declare class Vector4 {
    /**
     * The X component of this vector.
     */
    x: number;
    /**
     * The Y component of this vector.
     */
    y: number;
    /**
     * The Z component of this vector.
     */
    z: number;
    /**
     * The W component of this vector.
     */
    w: number;
    constructor(value: number);
    constructor(xz: number, yw: number);
    constructor(x: number, y: number, z: number, w: number);
    /**
     * The X coordinate of the left edge of this vector.
     */
    get left(): number;
    /**
     * The Y coordinate of the top edge of this vector.
     */
    get top(): number;
    /**
     * The X coordinate of the right edge of this vector.
     */
    get right(): number;
    /**
     * The Y coordinate of the bottom edge of this vector.
     */
    get bottom(): number;
    /**
     * The top left corner of this vector.
     */
    get topLeft(): Vector2;
    /**
     * The top right corner of this vector.
     */
    get topRight(): Vector2;
    /**
     * The bottom left corner of this vector.
     */
    get bottomLeft(): Vector2;
    /**
     * The bottom right corner of this vector.
     */
    get bottomRight(): Vector2;
    /**
     * The width of the rectangle defined by this vector.
     */
    get width(): number;
    /**
     * The height of the rectangle defined by this vector.
     */
    get height(): number;
}

/**
 * Contains infromation about the position of a {@link HitObject}.
 */
declare class HitObjectPositionInfo {
    /**
     * The {@link HitObject} associated with this {@link HitObjectPositionInfo}.
     */
    readonly hitObject: HitObject;
    /**
     * The jump angle from the previous {@link HitObject} to this one, relative to the previous
     * {@link HitObject}'s jump angle.
     *
     * The `relativeAngle` of the first {@link HitObject} in a beatmap represents the absolute angle from the
     * center of the playfield to the {@link HitObject}.
     *
     * If `relativeAngle` is 0, the player's cursor does not need to change its direction of movement when
     * passing from the previous {@link HitObject} to this one.
     */
    relativeAngle: number;
    /**
     * The jump distance from the previous {@link HitObject} to this one.
     *
     * The `distanceFromPrevious` of the first {@link HitObject} in a beatmap is relative to the center of
     * the playfield.
     */
    distanceFromPrevious: number;
    /**
     * The rotation of this {@link HitObject} relative to its jump angle.
     *
     * For `Slider`s, this is defined as the angle from the `Slider`'s start position to the end of its path
     * relative to its jump angle. For `HitCircle`s and `Spinner`s, this property is ignored.
     */
    rotation: number;
    constructor(hitObject: HitObject);
}

/**
 * Utilities for {@link HitObject} generation.
 */
declare abstract class HitObjectGenerationUtils {
    /**
     * The relative distance to the edge of the playfield before {@link HitObject} positions should start
     * to "turn around" and curve towards the middle. The closer the {@link HitObject}s draw to the border,
     * the sharper the turn.
     */
    private static readonly playfieldEdgeRatio;
    /**
     * The amount of previous {@link HitObject}s to be shifted together when a {@link HitObject} is being moved.
     */
    private static readonly precedingObjectsToShift;
    private static readonly borderDistance;
    /**
     * Rotates a {@link HitObject} away from the edge of the playfield while keeping a constant distance from
     * the previous {@link HitObject}.
     *
     * @param previousObjectPosition The position of the previous {@link HitObject}.
     * @param positionRelativeToPrevious The position of the {@link HitObject} to be rotated relative to the
     * previous {@link HitObject}.
     * @param rotationRatio The extent of the rotation. 0 means the {@link HitObject} is never rotated, while 1
     * means the {@link HitObject} will be fully rotated towards the center of the playfield when it is originally
     * at the edge of the playfield.
     * @return The new position of the {@link HitObject} relative to the previous {@link HitObject}.
     */
    static rotateAwayFromEdge(previousObjectPosition: Vector2, positionRelativeToPrevious: Vector2, rotationRatio?: number): Vector2;
    /**
     * Rotates a {@link Vector2} towards another {@link Vector2}.
     *
     * @param initial The {@link Vector2} to be rotated.
     * @param destination The {@link Vector2} that `initial` should be rotated towards.
     * @param rotationRatio How much `initial` should be rotated. 0 means no rotation. 1 mean `initial` is fully
     * rotated to equal `destination`.
     * @return The rotated {@link Vector2}.
     */
    static rotateVectorTowardsVector(initial: Vector2, destination: Vector2, rotationRatio: number): Vector2;
    /**
     * Obtains the absolute rotation of a {@link Slider}, defined as the angle from its start position to the
     * end of its path.
     *
     * @param slider The {@link Slider} to obtain the rotation from.
     * @return The angle in radians.
     */
    static getSliderRotation(slider: Slider): number;
    /**
     * Rotates a {@link Vector2} by the specified angle.
     *
     * @param vec The {@link Vector2} to be rotated.
     * @param rotation The angle to rotate `vec` by, in radians.
     * @return The rotated {@link Vector2}.
     */
    private static rotateVector;
    /**
     * Reflects the position of a {@link HitObject} horizontally along the playfield.
     *
     * @param hitObject The {@link HitObject} to reflect.
     */
    static reflectHorizontallyAlongPlayfield(hitObject: HitObject): void;
    /**
     * Reflects the position of a {@link HitObject} vertically along the playfield.
     *
     * @param hitObject The {@link HitObject} to reflect.
     */
    static reflectVerticallyAlongPlayfield(hitObject: HitObject): void;
    /**
     * Flips the position of a {@link Slider} around its start position horizontally.
     *
     * @param slider The {@link Slider} to be flipped.
     */
    static flipSliderInPlaceHorizontally(slider: Slider): void;
    /**
     * Rotates a {@link Slider} around its start position by the specified angle.
     *
     * @param slider The {@link Slider} to rotate.
     * @param rotation The angle to rotate `slider` by, in radians.
     */
    static rotateSlider(slider: Slider, rotation: number): void;
    private static modifySlider;
    private static reflectVectorHorizontallyAlongPlayfield;
    private static reflectVectorVerticallyAlongPlayfield;
    /**
     * Generates a list of {@link HitObjectPositionInfo}s containing information for how the given list of
     * {@link HitObject}s are positioned.
     *
     * @param hitObjects A list of {@link HitObject}s to process.
     * @return A list of {@link HitObjectPositionInfo}s describing how each {@link HitObject} is positioned
     * relative to the previous one.
     */
    static generatePositionInfos(hitObjects: Iterable<HitObject>): HitObjectPositionInfo[];
    static repositionHitObjects(positionInfos: HitObjectPositionInfo[]): HitObject[];
    /**
     * Determines whether a {@link HitObject} is on a beat.
     *
     * @param beatmap The {@link Beatmap} the {@link HitObject} is a part of.
     * @param hitObject The {@link HitObject} to check.
     * @param downbeatsOnly If `true`, whether this method only returns `true` is on a downbeat.
     * @return `true` if the {@link HitObject} is on a (down-)beat, `false` otherwise.
     */
    static isHitObjectOnBeat(beatmap: Beatmap, hitObject: HitObject, downbeatsOnly?: boolean): boolean;
    /**
     * Generates a random number from a Normal distribution using the Box-Muller transform.
     *
     * @param random A {@link Random} to get the random number from.
     * @param mean The mean of the distribution.
     * @param stdDev The standard deviation of the distribution.
     * @return The random number.
     */
    static randomGaussian(random: Random, mean?: number, stdDev?: number): number;
    /**
     * Calculates a {@link Vector4} which contains all possible movements of a {@link Slider} (in relative
     * X/Y coordinates) such that the entire {@link Slider} is inside the playfield.
     *
     * If the {@link Slider} is larger than the playfield, the returned {@link Vector4} may have a Z/W component
     * that is smaller than its X/Y component.
     *
     * @param slider The {@link Slider} whose movement bound is to be calculated.
     * @return A {@link Vector4} which contains all possible movements of a {@link Slider} (in relative X/Y
     * coordinates) such that the entire {@link Slider} is inside the playfield.
     */
    static calculatePossibleMovementBounds(slider: Slider): Vector4;
    /**
     * Computes the modified position of a {@link HitObject} while attempting to keep it inside the playfield.
     *
     * @param current The {@link WorkingObject} representing the {@link HitObject} to have the modified
     * position computed for.
     * @param previous The {@link WorkingObject} representing the {@link HitObject} immediately preceding
     * `current`.
     * @param beforePrevious The {@link WorkingObject} representing the {@link HitObject} immediately preceding
     * `previous`.
     */
    private static computeModifiedPosition;
    /**
     * Moves the modified position of a {@link Circle} so that it fits inside the playfield.
     *
     * @param workingObject The {@link WorkingObject} that represents the {@link Circle}.
     * @return The deviation from the original modified position in order to fit within the playfield.
     */
    private static clampHitCircleToPlayfield;
    /**
     * Moves a {@link Slider} and all necessary `SliderHitObject`s into the playfield if they are not in
     * the playfield.
     *
     * @param workingObject The {@link WorkingObject} that represents the {@link Slider}.
     * @return The deviation from the original modified position in order to fit within the playfield.
     */
    private static clampSliderToPlayfield;
    /**
     * Clamps a {@link Vector2} into the playfield, keeping a specified distance from the edge of the playfield.
     *
     * @param vec The {@link Vector2} to clamp.
     * @param padding The minimum distance allowed from the edge of the playfield.
     * @return The clamped {@link Vector2}.
     */
    private static clampToPlayfield;
    /**
     * Decreasingly shifts a list of {@link HitObject}s by a specified amount.
     *
     * The first item in the list is shifted by the largest amount, while the last item is shifted by the
     * smallest amount.
     *
     * @param hitObjects The list of {@link HitObject}s to be shifted.
     * @param shift The amount to shift the {@link HitObject}s by.
     */
    private static applyDecreasingShift;
    /**
     * Estimates the center of mass of a {@link Slider} relative to its start position.
     *
     * @param slider The {@link Slider} whose center mass is to be estimated.
     * @return The estimated center of mass of `slider`.
     */
    private static calculateCenterOfMass;
    /**
     * Calculates the absolute difference between two angles in radians.
     *
     * @param angle1 The first angle.
     * @param angle2 The second angle.
     * @return THe absolute difference within interval `[0, Math.PI]`.
     */
    private static getAngleDifference;
}

/**
 * Represents available hitsound types.
 */
declare enum HitSoundType {
    none = 0,
    normal = 1,
    whistle = 2,
    finish = 4,
    clap = 8
}

/**
 * Quick and simple if statement for type checking.
 */
type If<T extends boolean, A, B = null> = T extends true ? A : T extends false ? B : A | B;

/**
 * Represents a `Mod` specific setting that is constrained to a range of integer values.
 */
declare class IntegerModSetting extends NumberModSetting {
    constructor(name: string, description: string, defaultValue: number, min?: number, max?: number);
}

/**
 * Holds interpolation methods for numbers and vectors.
 */
declare abstract class Interpolation {
    /**
     * Performs a linear interpolation of numbers.
     *
     * @param start The starting point of the interpolation.
     * @param final The final point of the interpolation.
     * @param amount The interpolation multiplier.
     * @returns The interpolated value.
     */
    static lerp(start: number, final: number, amount: number): number;
    /**
     * Performs a linear interpolation of vectors.
     *
     * @param start The starting point of the interpolation.
     * @param final The final point of the interpolation.
     * @param amount The interpolation multiplier.
     * @returns The interpolated vector.
     */
    static lerp(start: Vector2, final: Vector2, amount: number): Vector2;
    /**
     * Calculates the reverse [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation)
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @return The output of the reverse linear interpolation function calculated at `x`.
     */
    static reverseLerp(x: number, start: number, end: number): number;
    /**
     * Interpolates a value using an easing function.
     *
     * @param easing The easing function to use.
     * @param t The progress of the interpolation, from 0 to 1.
     * @returns The interpolated value.
     */
    static easing(easing: Easing, t: number): number;
}

/**
 * Ranking status of a beatmap.
 */
declare enum RankedStatus {
    graveyard = -2,
    wip = -1,
    pending = 0,
    ranked = 1,
    approved = 2,
    qualified = 3,
    loved = 4
}

interface OsuAPIResponse {
    readonly approved: string;
    readonly submit_date: string;
    readonly approved_date: string | null;
    readonly last_update: string;
    readonly artist: string;
    readonly beatmap_id: string;
    readonly beatmapset_id: string;
    readonly bpm: string;
    readonly creator: string;
    readonly creator_id: string;
    readonly difficultyrating: string | null;
    readonly diff_aim: string | null;
    readonly diff_speed: string | null;
    readonly diff_size: string;
    readonly diff_overall: string;
    readonly diff_approach: string;
    readonly diff_drain: string;
    readonly hit_length: string;
    readonly source: string;
    readonly genre_id: string;
    readonly language_id: string;
    readonly title: string;
    readonly total_length: string;
    readonly version: string;
    readonly file_md5: string;
    readonly mode: string;
    readonly tags: string;
    readonly favourite_count: string;
    readonly rating: string;
    readonly playcount: string;
    readonly passcount: string;
    readonly count_normal: string;
    readonly count_slider: string;
    readonly count_spinner: string;
    readonly max_combo: string | null;
    readonly storyboard: string;
    readonly video: string;
    readonly download_unavailable: string;
    readonly audio_unavailable: string;
    readonly packs: string | null;
}
/**
 * Represents a beatmap with general information.
 */
declare class MapInfo<THasBeatmap extends boolean = boolean> {
    /**
     * The title of the song of the beatmap.
     */
    title: string;
    /**
     * The full title of the beatmap, which is `Artist - Title (Creator) [Difficulty Name]`.
     */
    get fullTitle(): string;
    /**
     * The artist of the song of the beatmap.
     */
    artist: string;
    /**
     * The creator of the beatmap.
     */
    creator: string;
    /**
     * The user ID of the creator of the beatmap.
     */
    creatorId: number;
    /**
     * The difficulty name of the beatmap.
     */
    version: string;
    /**
     * The source of the song, if any.
     */
    source: string;
    /**
     * The ranking status of the beatmap.
     */
    approved: RankedStatus;
    /**
     * The ID of the beatmap.
     */
    beatmapId: number;
    /**
     * The ID of the beatmapset containing the beatmap.
     */
    beatmapSetId: number;
    /**
     * The amount of times the beatmap has been played.
     */
    plays: number;
    /**
     * The amount of times this beatmap has been passed.
     */
    passes: number;
    /**
     * The amount of times the beatmap has been favorited.
     */
    favorites: number;
    /**
     * The user rating of this beatmap.
     */
    rating: number;
    /**
     * The date of which the beatmap was submitted.
     */
    submitDate: Date;
    /**
     * The date of which this beatmap was approved.
     */
    approvedDate: Date | null;
    /**
     * The date of which the beatmap was last updated.
     */
    lastUpdate: Date;
    /**
     * The duration of the beatmap not including breaks.
     */
    hitLength: number;
    /**
     * The duration of the beatmap including breaks.
     */
    totalLength: number;
    /**
     * The genre of this beatmap.
     */
    genre: BeatmapGenre;
    /**
     * The language of this beatmap.
     */
    language: BeatmapLanguage;
    /**
     * The BPM of the beatmap.
     */
    bpm: number;
    /**
     * The amount of circles in the beatmap.
     */
    circles: number;
    /**
     * The amount of sliders in the beatmap.
     */
    sliders: number;
    /**
     * The amount of spinners in the beatmap.
     */
    spinners: number;
    /**
     * The amount of objects in the beatmap.
     */
    get objects(): number;
    /**
     * The maximum combo of the beatmap.
     */
    maxCombo: number | null;
    /**
     * The circle size of the beatmap.
     */
    cs: number;
    /**
     * The approach rate of the beatmap.
     */
    ar: number;
    /**
     * The overall difficulty of the beatmap.
     */
    od: number;
    /**
     * The health drain rate of the beatmap.
     */
    hp: number;
    /**
     * The beatmap packs that contain this beatmap, represented by their ID.
     */
    packs: string[];
    /**
     * The tags of this beatmap.
     */
    tags: string[];
    /**
     * The aim difficulty rating of the beatmap.
     */
    aimDifficulty: number | null;
    /**
     * The speed difficulty rating of the beatmap.
     */
    speedDifficulty: number | null;
    /**
     * The generic difficulty rating of the beatmap.
     */
    totalDifficulty: number | null;
    /**
     * The MD5 hash of the beatmap.
     */
    hash: string;
    /**
     * Whether this beatmap has a storyboard.
     */
    storyboardAvailable: boolean;
    /**
     * Whether this beatmap has a video.
     */
    videoAvailable: boolean;
    /**
     * Whether the download for this beatmap is available.
     *
     * The download of a beatmap may not be available due to old beatmap, etc.
     */
    downloadAvailable: boolean;
    /**
     * Whether the audio of this beatmap is available.
     *
     * The audio of a beatmap may not be available due to DMCA takedown, etc.
     */
    audioAvailable: boolean;
    /**
     * The decoded beatmap from beatmap decoder.
     */
    get beatmap(): If<THasBeatmap, Beatmap>;
    /**
     * The osu! site link to this beatmap.
     */
    get beatmapLink(): string;
    /**
     * The osu! site link to this beatmapset.
     */
    get beatmapSetLink(): string;
    private cachedBeatmap;
    /**
     * Retrieve a beatmap's general information.
     *
     * @param beatmapIdOrHash The beatmap ID or MD5 hash of the beatmap.
     * @param downloadBeatmap Whether to also retrieve the .osu file of the beatmap. Defaults to `true`.
     * @returns The beatmap, `null` if the beatmap is not found or the beatmap is not an osu!standard beatmap.
     */
    static getInformation(beatmapIdOrHash: string | number, downloadBeatmap?: boolean): Promise<MapInfo<true> | null>;
    /**
     * Retrieve a beatmap's general information.
     *
     * @param beatmapIdOrHash The beatmap ID or MD5 hash of the beatmap.
     * @param downloadBeatmap Whether to also retrieve the .osu file of the beatmap. Defaults to `true`.
     * @returns The beatmap, `null` if the beatmap is not found or the beatmap is not an osu!standard beatmap.
     */
    static getInformation(beatmapIdOrHash: string | number, downloadBeatmap: false): Promise<MapInfo<false> | null>;
    /**
     * Constructs a `MapInfo` from an osu! API response.
     *
     * @param mapinfo The osu! API response.
     * @returns A `MapInfo` instance representing the osu! API response.
     */
    static from(mapinfo: OsuAPIResponse): MapInfo;
    /**
     * Constructs a `MapInfo` from an osu! API response and a parsed `Beatmap`.
     *
     * @param mapinfo The osu! API response.
     * @param parsedBeatmap The parsed `Beatmap`.
     * @returns A `MapInfo` instance representing the osu! API response and parsed `Beatmap`.
     */
    static from(mapinfo: OsuAPIResponse, parsedBeatmap: Beatmap): MapInfo<true>;
    /**
     * Converts this `MapInfo` to its raw API response.
     *
     * @returns The raw API response represented by this `MapInfo`.
     */
    toAPIResponse(): OsuAPIResponse;
    /**
     * Checks whether the beatmap file has been downloaded.
     */
    hasDownloadedBeatmap(): this is MapInfo<true>;
    /**
     * Retrieves the .osu file of the beatmap.
     *
     * After this, you can use the `hasDownloadedBeatmap` method to check if the beatmap has been downloaded.
     *
     * @param force Whether to download the file regardless if it's already available.
     */
    retrieveBeatmapFile(force?: boolean): Promise<void>;
    /**
     * Sets the parsed beatmap that is associated with this `MapInfo`.
     *
     * This is used as an alternative to downloading the beatmap file in case the beatmap file already exists locally.
     *
     * @param beatmap The beatmap to associate with this `MapInfo`.
     */
    setBeatmap(beatmap: Beatmap): void;
    /**
     * Returns a string representative of the class.
     */
    toString(): string;
}

/**
 * Some math utility functions.
 */
declare abstract class MathUtils {
    /**
     * An alternative of {@link Math.min} that does not require a spread operator, making it
     * more efficient for larger arrays.
     *
     * @param values The values to get the minimum from.
     * @returns One of the following:
     * - The minimum value.
     * - 0 if the iterable is empty.
     * - `NaN` if any of the values are `NaN`.
     */
    static min(values: Iterable<number>): number;
    /**
     * An alternative of {@link Math.max} that does not require a spread operator, making it
     * more efficient for larger arrays.
     *
     * @param values The values to get the maximum from.
     * @returns One of the following:
     * - The maximum value.
     * - 0 if the iterable is empty.
     * - `NaN` if any of the values are `NaN`.
     */
    static max(values: Iterable<number>): number;
    /**
     * Rounds a specified number with specified amount of fractional digits.
     *
     * @param num The number to round.
     * @param fractionalDigits The amount of fractional digits.
     */
    static round(num: number, fractionalDigits: number): number;
    /**
     * Limits the specified number on range `[min, max]`.
     *
     * @param num The number to limit.
     * @param min The minimum range.
     * @param max The maximum range.
     */
    static clamp(num: number, min: number, max: number): number;
    /**
     * Calculates the standard deviation of given data.
     *
     * @param data The data to calculate.
     */
    static calculateStandardDeviation(data: number[]): number;
    /**
     * Converts degrees to radians.
     *
     * @param degrees An angle in degrees.
     * @returns The angle expressed in radians.
     */
    static degreesToRadians(degrees: number): number;
    /**
     * Converts radians to degrees.
     *
     * @param radians An angle in radians.
     * @returns The angle expressed in degrees.
     */
    static radiansToDegrees(radians: number): number;
    /**
     * Converts a BPM value to milliseconds.
     *
     * @param bpm The BPM value.
     * @param delimiter The denominator of the time signature. Defaults to 4.
     * @returns The BPM value in milliseconds.
     */
    static bpmToMilliseconds(bpm: number, delimiter?: number): number;
    /**
     * Converts milliseconds to BPM.
     *
     * @param milliseconds The milliseconds value.
     * @param delimiter The denominator of the time signature. Defaults to 4.
     * @returns The milliseconds value in BPM.
     */
    static millisecondsToBPM(milliseconds: number, delimiter?: number): number;
    /**
     * Calculates an S-shaped {@link https://en.wikipedia.org/wiki/Logistic_function logistic function}
     * with offset at `x`.
     *
     * @param x The value to calculate the function for.
     * @param midpointOffset How much the function midpoint is offset from zero `x`.
     * @param multiplier The growth rate of the function.
     * @param maxValue Maximum value returnable by the function.
     * @returns The output of the logistic function calculated at `x`.
     */
    static offsetLogistic(x: number, midpointOffset: number, multiplier: number, maxValue?: number): number;
    /**
     * Calculates the {@link https://en.wikipedia.org/wiki/Smoothstep smoothstep} function
     * at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the smoothstep function calculated at `x`.
     */
    static smoothstep(x: number, start: number, end: number): number;
    /**
     * Calculates the {@link https://en.wikipedia.org/wiki/Smoothstep#Variations smoothstep}
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the smoothstep function calculated at `x`.
     */
    static smootherstep(x: number, start: number, end: number): number;
    /**
     * Calculates the reverse {@link https://en.wikipedia.org/wiki/Linear_interpolation linear interpolation}
     * function at `x`.
     *
     * @param x The value to calculate the function for.
     * @param start The `x` value at which the function returns 0.
     * @param end The `x` value at which the function returns 1.
     * @returns The output of the reverse lerp function calculated at `x`.
     */
    static reverseLerp(x: number, start: number, end: number): number;
}

/**
 * Represents the Approach Different mod.
 */
declare class ModApproachDifferent extends Mod implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Approach Different";
    readonly acronym = "AD";
    /**
     * The initial size of the approach circle, relative to hit circles.
     */
    readonly scale: DecimalModSetting;
    /**
     * The animation style of the approach circles.
     */
    readonly style: ModSetting<AnimationStyle>;
    /**
     * The {@link Easing} to apply to the approach circle animation.
     */
    get easing(): Easing;
    constructor();
    get droidRanked(): boolean;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get osuRanked(): boolean;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    copySettings(mod: SerializedMod): void;
    protected serializeSettings(): Record<string, unknown> | null;
}
declare enum AnimationStyle {
    linear = 0,
    gravity = 1,
    inOut1 = 2,
    inOut2 = 3,
    accelerate1 = 4,
    accelerate2 = 5,
    accelerate3 = 6,
    decelerate1 = 7,
    decelerate2 = 8,
    decelerate3 = 9
}

/**
 * Represents the Auto mod.
 */
declare class ModAuto extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "AT";
    readonly name = "Autoplay";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Autopilot mod.
 */
declare class ModAutopilot extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "AP";
    readonly name = "Autopilot";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents a `Mod` that adjusts the playback rate of a track.
 */
declare abstract class ModRateAdjust extends Mod implements IModApplicableToTrackRate {
    /**
     * The multiplier for the track's playback rate after applying this `Mod`.
     */
    readonly trackRateMultiplier: DecimalModSetting;
    /**
     * The generic osu!droid score multiplier of this `Mod`.
     */
    protected get droidScoreMultiplier(): number;
    /**
     * Generic getter to determine if this `ModRateAdjust` is relevant.
     */
    protected get isRelevant(): boolean;
    constructor(trackRateMultiplier?: number);
    applyToRate(_: number, rate: number): number;
}

/**
 * Represents the Custom Speed mod.
 *
 * This is a replacement `Mod` for speed modify in osu!droid and custom rates in osu!lazer.
 */
declare class ModCustomSpeed extends ModRateAdjust implements IModApplicableToDroid, IModApplicableToOsu {
    readonly acronym = "CS";
    readonly name = "Custom Speed";
    readonly droidRanked = true;
    readonly osuRanked = false;
    copySettings(mod: SerializedMod): void;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    protected serializeSettings(): Record<string, unknown> | null;
    toString(): string;
}

/**
 * Represents a `Mod` that adjusts the size of `HitObject`s during their fade in animation.
 */
declare abstract class ModObjectScaleTween extends Mod {
    /**
     * The initial size multiplier applied to all `HitObject`s.
     */
    abstract readonly startScale: DecimalModSetting;
    /**
     * The final size multiplier applied to all [HitObject]s.
     */
    endScale: number;
    constructor();
    copySettings(mod: SerializedMod): void;
    protected serializeSettings(): Record<string, unknown> | null;
}

/**
 * Represents the Deflate mod.
 */
declare class ModDeflate extends ModObjectScaleTween implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Deflate";
    readonly acronym = "DF";
    readonly startScale: DecimalModSetting;
    get droidRanked(): boolean;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get osuRanked(): boolean;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 *
 * The value can be `null`, which is treated as a special case.
 */
declare class NullableDecimalModSetting extends RangeConstrainedModSetting<number | null> {
    private _precision;
    /**
     * The number of decimal places to round the value to.
     *
     * When set to `null`, the value will not be rounded.
     */
    get precision(): number | null;
    set precision(value: number | null);
    readonly displayFormatter: (v: number | null) => string;
    constructor(name: string, description: string, defaultValue: number | null, min?: number, max?: number, step?: number, precision?: number | null);
    protected processValue(value: number | null): number | null;
}

/**
 * Represents the Difficulty Adjust mod.
 */
declare class ModDifficultyAdjust extends Mod implements IModApplicableToDroid, IModApplicableToOsu, IModApplicableToDifficultyWithMods, IModApplicableToHitObjectWithMods {
    readonly acronym = "DA";
    readonly name = "Difficulty Adjust";
    readonly droidRanked = false;
    readonly osuRanked = false;
    /**
     * The circle size to enforce.
     */
    readonly cs: NullableDecimalModSetting;
    /**
     * The approach rate to enforce.
     */
    readonly ar: NullableDecimalModSetting;
    /**
     * The overall difficulty to enforce.
     */
    readonly od: NullableDecimalModSetting;
    readonly hp: NullableDecimalModSetting;
    private get isRelevant();
    constructor(values?: {
        cs?: number;
        ar?: number;
        od?: number;
        hp?: number;
    });
    copySettings(mod: SerializedMod): void;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(difficulty: BeatmapDifficulty): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    applyToDifficultyWithMods(_: Modes, difficulty: BeatmapDifficulty, mods: ModMap): void;
    applyToHitObjectWithMods(_: Modes, hitObject: HitObject, mods: ModMap): void;
    protected serializeSettings(): Record<string, unknown> | null;
    private applyFadeAdjustment;
    private calculateTrackRate;
    toString(): string;
}

/**
 * Represents the DoubleTime mod.
 */
declare class ModDoubleTime extends ModRateAdjust implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "DT";
    readonly name = "DoubleTime";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Easy mod.
 */
declare class ModEasy extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable, IModApplicableToDifficulty {
    readonly acronym = "EZ";
    readonly name = "Easy";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    applyToDifficulty(mode: Modes, difficulty: BeatmapDifficulty, adjustmentMods: ModMap): void;
}

/**
 * Represents the Flashlight mod.
 */
declare class ModFlashlight extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    /**
     * The default amount of seconds until the Flashlight follow area reaches the cursor.
     */
    static readonly defaultFollowDelay = 0.12;
    readonly acronym = "FL";
    readonly name = "Flashlight";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    /**
     * The amount of seconds until the Flashlight follow area reaches the cursor.
     */
    readonly followDelay: DecimalModSetting;
    copySettings(mod: SerializedMod): void;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    protected serializeSettings(): Record<string, unknown> | null;
    toString(): string;
}

/**
 * Represents the Freeze Frame mod.
 */
declare class ModFreezeFrame extends Mod implements IModApplicableToDroid, IModApplicableToOsu, IModApplicableToBeatmap {
    readonly name = "Freeze Frame";
    readonly acronym = "FR";
    constructor();
    private lastNewComboTime;
    get droidRanked(): boolean;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get osuRanked(): boolean;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    applyToBeatmap(beatmap: Beatmap): void;
    private applyFadeInAdjustment;
}

/**
 * Represents the Grow mod.
 */
declare class ModGrow extends ModObjectScaleTween implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Grow";
    readonly acronym = "GR";
    readonly startScale: DecimalModSetting;
    get droidRanked(): boolean;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get osuRanked(): boolean;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the HalfTime mod.
 */
declare class ModHalfTime extends ModRateAdjust implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "HT";
    readonly name = "HalfTime";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the HardRock mod.
 */
declare class ModHardRock extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable, IModApplicableToDifficulty, IModApplicableToHitObject {
    readonly acronym = "HR";
    readonly name = "HardRock";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    applyToDifficulty(mode: Modes, difficulty: BeatmapDifficulty, adjustmentMods: ModMap): void;
    applyToHitObject(_: Modes, hitObject: HitObject): void;
    private applySetting;
}

/**
 * Represents the Hidden mod.
 */
declare class ModHidden extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable, IModApplicableToBeatmap {
    static readonly fadeInDurationMultiplier = 0.4;
    static readonly fadeOutDurationMultiplier = 0.3;
    readonly acronym = "HD";
    readonly name = "Hidden";
    get droidRanked(): boolean;
    get osuRanked(): boolean;
    readonly bitwise: number;
    /**
     * Whether to only fade approach circles.
     *
     * The main object body will not fade when enabled.
     */
    readonly onlyFadeApproachCircles: BooleanModSetting;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    copySettings(mod: SerializedMod): void;
    applyToBeatmap(beatmap: Beatmap): void;
    protected serializeSettings(): Record<string, unknown> | null;
    toString(): string;
}

/**
 * Represents the Mirror mod.
 */
declare class ModMirror extends Mod implements IModApplicableToDroid, IModApplicableToOsu, IModApplicableToHitObject {
    readonly name = "Mirror";
    readonly acronym = "MR";
    readonly droidRanked = false;
    readonly osuRanked = false;
    /**
     * The axes to reflect the `HitObject`s along.
     */
    readonly flippedAxes: ModSetting<Axes.x | Axes.y | Axes.both>;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    copySettings(mod: SerializedMod): void;
    applyToHitObject(_: Modes, hitObject: HitObject): void;
    protected serializeSettings(): Record<string, unknown> | null;
    toString(): string;
}

/**
 * Represents the Muted mod.
 */
declare class ModMuted extends Mod implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Muted";
    readonly acronym = "MU";
    /**
     * Increase volume as combo builds.
     */
    readonly inverseMuting: BooleanModSetting;
    /**
     * Add a metronome beat to help the player keep track of the rhythm.
     */
    readonly enableMetronome: BooleanModSetting;
    /**
     * The combo count at which point the track reaches its final volume.
     */
    readonly muteComboCount: IntegerModSetting;
    /**
     * Hit sounds are also muted alongside the track.
     */
    readonly affectsHitSounds: BooleanModSetting;
    get droidRanked(): boolean;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get osuRanked(): boolean;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    constructor();
    /**
     * Obtains the volume at a given combo.
     *
     * @param combo The combo.
     * @return The volume at `combo`, where 0 is muted and 1 is full volume.
     */
    volumeAt(combo: number): number;
    copySettings(mod: SerializedMod): void;
    protected serializeSettings(): Record<string, unknown> | null;
}

/**
 * Represents the NightCore mod.
 */
declare class ModNightCore extends ModRateAdjust implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "NC";
    readonly name = "NightCore";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the NoFail mod.
 */
declare class ModNoFail extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "NF";
    readonly name = "NoFail";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the "old" `ModNightCore`.
 *
 * This mod is used solely for osu!droid difficulty calculation of replays with version 3 or older. The reason behind this
 * is a bug that was patched in replay version 4, where all audio that did not have 44100Hz frequency would slow down.
 *
 * After some testing, it was discovered that such replays were played at 1.39x speed instead of 1.5x, which is
 * represented by this mod.
 */
declare class ModOldNightCore extends ModNightCore {
    constructor();
    calculateDroidScoreMultiplier(): number;
}

/**
 * Represents the Perfect mod.
 */
declare class ModPerfect extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "PF";
    readonly name = "Perfect";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Precise mod.
 */
declare class ModPrecise extends Mod implements IModApplicableToDroid, IModApplicableToHitObject {
    readonly acronym = "PR";
    readonly name = "Precise";
    readonly droidRanked = true;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    applyToHitObject(mode: Modes, hitObject: HitObject): void;
}

/**
 * Represents a `Mod` specific setting that is constrained to a number of values.
 *
 * The value can be `null`, which is treated as a special case.
 */
declare class NullableIntegerModSetting extends RangeConstrainedModSetting<number | null> {
    readonly displayFormatter: (v: number | null) => string;
    constructor(name: string, description: string, defaultValue: number | null, min?: number, max?: number);
    protected processValue(value: number | null): number | null;
}

/**
 * Represents the Random mod.
 */
declare class ModRandom extends Mod implements IModApplicableToDroid, IModApplicableToOsu, IModApplicableToBeatmap {
    private static readonly playfieldDiagonal;
    readonly name = "Random";
    readonly acronym = "RD";
    readonly droidRanked = false;
    readonly osuRanked = false;
    /**
     * The seed to use.
     */
    readonly seed: NullableIntegerModSetting;
    /**
     * Defines how sharp the angles of `HitObject`s should be.
     */
    readonly angleSharpness: DecimalModSetting;
    private random;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
    copySettings(mod: SerializedMod): void;
    applyToBeatmap(beatmap: Beatmap): void;
    protected serializeSettings(): Record<string, unknown> | null;
    private getRandomOffset;
    /**
     * @param targetDistance The target distance between the previous and the current `HitObject`.
     * @param offset The angle (in radians) by which the target angle should be offset.
     * @param flowDirection Whether the relative angle should be positive (`false`) or negative (`true`).
     */
    private getRelativeTargetAngle;
    /**
     * Determines whether a new section should be started at the current [HitObject].
     */
    private shouldStartNewSection;
    private shouldApplyFlowChange;
    toString(): string;
}

/**
 * Represents the ReallyEasy mod.
 */
declare class ModReallyEasy extends Mod implements IModApplicableToDroid, IModApplicableToDifficultyWithMods {
    readonly acronym = "RE";
    readonly name = "ReallyEasy";
    readonly droidRanked = false;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    applyToDifficultyWithMods(mode: Modes, difficulty: BeatmapDifficulty, mods: ModMap): void;
}

/**
 * Represents the Relax mod.
 */
declare class ModRelax extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "RX";
    readonly name = "Relax";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Replay V6 mod.
 *
 * Some behavior of beatmap parsing was changed in replay version 7. More specifically, object stacking
 * behavior now matches osu!stable and osu!lazer.
 *
 * This `Mod` is meant to reapply the stacking behavior prior to replay version 7 to a `Beatmap` that
 * was played in replays recorded in version 6 and older for replayability and difficulty calculation.
 */
declare class ModReplayV6 extends Mod implements IModApplicableToDroid, IModApplicableToBeatmap, IModFacilitatesAdjustment {
    readonly name = "Replay V6";
    readonly acronym = "RV6";
    readonly userPlayable = false;
    readonly droidRanked = false;
    readonly facilitateAdjustment = true;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    applyToBeatmap(beatmap: Beatmap): void;
    private revertObjectScale;
}

/**
 * Represents the ScoreV2 mod.
 */
declare class ModScoreV2 extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "V2";
    readonly name = "ScoreV2";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly bitwise: number;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the SmallCircle mod.
 *
 * This is a legacy osu!droid mod that may still be exist when parsing replays.
 */
declare class ModSmallCircle extends Mod implements IModApplicableToDroid, IModApplicableToDifficulty, IMigratableDroidMod {
    readonly acronym = "SC";
    readonly name = "SmallCircle";
    readonly droidRanked = false;
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    migrateDroidMod(difficulty: BeatmapDifficulty): Mod & IModApplicableToDroid;
    applyToDifficulty(mode: Modes, difficulty: BeatmapDifficulty, adjustmentMods: ModMap): void;
}

/**
 * Represents the SpunOut mod.
 */
declare class ModSpunOut extends Mod implements IModApplicableToOsuStable {
    readonly acronym = "SO";
    readonly name = "SpunOut";
    readonly osuRanked = true;
    readonly bitwise: number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the SuddenDeath mod.
 */
declare class ModSuddenDeath extends Mod implements IModApplicableToDroid, IModApplicableToOsuStable {
    readonly acronym = "SD";
    readonly name = "Sudden Death";
    readonly droidRanked = true;
    readonly osuRanked = true;
    readonly bitwise: number;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents a mod that gradually adjusts the track's playback rate over time.
 */
declare abstract class ModTimeRamp extends Mod implements IModApplicableToBeatmap, IModApplicableToTrackRate {
    /**
     * The point in the beatmap at which the final rate should be reached.
     */
    static readonly finalRateProgress = 0.75;
    /**
     * The starting speed of the track.
     */
    abstract readonly initialRate: DecimalModSetting;
    /**
     * The final speed to ramp to.
     */
    abstract readonly finalRate: DecimalModSetting;
    private initialRateTime;
    private finalRateTime;
    constructor();
    copySettings(mod: SerializedMod): void;
    applyToBeatmap(beatmap: Beatmap): void;
    applyToRate(time: number, rate: number): number;
    protected serializeSettings(): Record<string, unknown> | null;
    toString(): string;
}

/**
 * Represents the TouchDevice mod.
 */
declare class ModTouchDevice extends Mod implements IModApplicableToOsuStable {
    readonly acronym = "TD";
    readonly name = "TouchDevice";
    readonly osuRanked = true;
    readonly bitwise: number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Traceable mod.
 */
declare class ModTraceable extends Mod implements IModApplicableToDroid, IModApplicableToOsu {
    readonly acronym = "TC";
    readonly name = "Traceable";
    readonly droidRanked = false;
    readonly osuRanked = false;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Wind Down mod.
 */
declare class ModWindDown extends ModTimeRamp implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Wind Down";
    readonly acronym = "WD";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly initialRate: DecimalModSetting;
    readonly finalRate: DecimalModSetting;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Represents the Wind Up mod.
 */
declare class ModWindUp extends ModTimeRamp implements IModApplicableToDroid, IModApplicableToOsu {
    readonly name = "Wind Up";
    readonly acronym = "WU";
    readonly droidRanked = false;
    readonly osuRanked = false;
    readonly initialRate: DecimalModSetting;
    readonly finalRate: DecimalModSetting;
    constructor();
    get isDroidRelevant(): boolean;
    calculateDroidScoreMultiplier(): number;
    get isOsuRelevant(): boolean;
    get osuScoreMultiplier(): number;
}

/**
 * Utilities for mods.
 */
declare abstract class ModUtil {
    /**
     * All `Mod`s that exists, mapped by their acronym.
     */
    static readonly allMods: ReadonlyMap<string, typeof Mod>;
    /**
     * Gets a list of mods from a PC modbits.
     *
     * @param modbits The modbits.
     * @returns The list of mods.
     */
    static pcModbitsToMods(modbits: number): ModMap;
    /**
     * Serializes a list of `Mod`s.
     *
     * @param mods The list of `Mod`s to serialize.
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns The serialized list of `Mod`s.
     */
    static serializeMods(mods: Iterable<Mod>, includeNonUserPlayable?: boolean): SerializedMod[];
    /**
     * Deserializes a list of `SerializedMod`s.
     *
     * @param mods The list of `SerializedMod`s to deserialize.
     * @returns The deserialized list of `Mod`s.
     */
    static deserializeMods(mods: Iterable<SerializedMod>): ModMap;
    /**
     * Gets a list of mods from a PC mod string, such as "HDHR".
     *
     * @param str The string.
     * @returns The list of mods.
     */
    static pcStringToMods(str: string): ModMap;
    /**
     * Converts a list of mods into its osu!standard string counterpart.
     *
     * @param mods The array of mods to convert.
     * @returns The string representing the mods in osu!standard.
     */
    static modsToOsuString(mods: Iterable<Mod>): string;
    /**
     * Converts a list of `Mod`s into an ordered string based on {@link allMods}.
     *
     * @param mods The list of `Mod`s to convert.
     * @param includeNonUserPlayable Whether to include non-user-playable mods. Defaults to `true`.
     * @returns The string representing the `Mod`s in ordered form.
     */
    static modsToOrderedString(mods: Mod[] | ModMap, includeNonUserPlayable?: boolean): string;
    /**
     * Removes speed-changing mods from an array of mods.
     *
     * @param mods The array of mods.
     * @returns A new array with speed changing mods filtered out.
     */
    static removeSpeedChangingMods<T extends Mod>(mods: T[]): T[];
    /**
     * Applies the selected `Mod`s to a `BeatmapDifficulty`.
     *
     * @param difficulty The `BeatmapDifficulty` to apply the `Mod`s to.
     * @param mode The game mode to apply the `Mod`s for.
     * @param mods The selected `Mod`s. Defaults to No Mod.
     * @param withRateChange Whether to apply rate changes. Defaults to `false`.
     */
    static applyModsToBeatmapDifficulty(difficulty: BeatmapDifficulty, mode: Modes, mods?: ModMap, withRateChange?: boolean): void;
    /**
     * Calculates the playback rate for the track with the selected `Mod`s at the given time.
     *
     * @param mods The list of selected `Mod`s.
     * @param time The time at which the playback rate is queried, in milliseconds. Defaults to 0.
     * @returns The rate with `Mod`s.
     */
    static calculateRateWithMods(mods: Iterable<Mod>, time?: number): number;
}

/**
 * Continuous Univariate Normal distribution, also known as Gaussian distribution.
 *
 * For details about this distribution, see {@link http://en.wikipedia.org/wiki/Normal_distribution Wikipedia - Normal distribution}.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
declare abstract class NormalDistribution {
    /**
     * Computes the inverse of the cumulative distribution function (InvCDF) for the distribution
     * at the given probability. This is also known as the quantile or percent point function.
     *
     * @param mean The mean (μ) of the normal distribution.
     * @param stdDev The standard deviation (σ) of the normal distribution. Range: σ ≥ 0.
     * @param p The location at which to compute the inverse cumulative density.
     * @returns The inverse cumulative density at `p`.
     */
    static invCDF(mean: number, stdDev: number, p: number): number;
}

/**
 * Omits properties from object `TObject` whose types are assignable to `TType`.
 */
type OmitType<TObject extends object, TType> = Omit<TObject, {
    [K in keyof TObject]-?: [TType] extends [TObject[K]] ? K : never;
}[keyof TObject]>;

/**
 * Available endpoints for osu! API.
 */
type OsuAPIEndpoint = "get_beatmaps" | "get_user" | "get_scores" | "get_user_best" | "get_user_recent" | "get_match" | "get_replay";
/**
 * An API request builder for osu!standard.
 */
declare class OsuAPIRequestBuilder extends APIRequestBuilder<OsuAPIEndpoint> {
    private static apiKey;
    /**
     * Sets the API key for all subsequent initializations of an `OsuAPIRequestBuilder`.
     *
     * @param key The API key.
     */
    static setAPIKey(key: string): void;
    protected readonly host = "https://osu.ppy.sh/api/";
    protected readonly APIkey: string;
    protected readonly APIkeyParam: string;
}

/**
 * Represents the hit window of osu!standard.
 */
declare class OsuHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a meh hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value: number): number;
    get greatWindow(): number;
    get okWindow(): number;
    get mehWindow(): number;
}

/**
 * Path approximator for sliders.
 */
declare abstract class PathApproximator {
    private static readonly bezierTolerance;
    /**
     * The amount of pieces to calculate for each control point quadruplet.
     */
    private static readonly catmullDetail;
    private static readonly circularArcTolerance;
    /**
     * Approximates a bezier slider's path.
     *
     * Creates a piecewise-linear approximation of a bezier curve by adaptively repeatedly subdividing
     * the control points until their approximation error vanishes below a given threshold.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateBezier(controlPoints: Vector2[]): Vector2[];
    /**
     * Approximates a catmull slider's path.
     *
     * Creates a piecewise-linear approximation of a Catmull-Rom spline.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateCatmull(controlPoints: Vector2[]): Vector2[];
    /**
     * Approximates a slider's circular arc.
     *
     * Creates a piecewise-linear approximation of a circular arc curve.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateCircularArc(controlPoints: Vector2[]): Vector2[];
    /**
     * Approximates a linear slider's path.
     *
     * Creates a piecewise-linear approximation of a linear curve.
     * Basically, returns the input.
     *
     * @param controlPoints The anchor points of the slider.
     */
    static approximateLinear(controlPoints: Vector2[]): Vector2[];
    /**
     * Checks if a bezier slider is flat enough to be approximated.
     *
     * Make sure the 2nd order derivative (approximated using finite elements) is within tolerable bounds.
     *
     * NOTE: The 2nd order derivative of a 2D curve represents its curvature, so intuitively this function
     * checks (as the name suggests) whether our approximation is _locally_ "flat". More curvy parts
     * need to have a denser approximation to be more "flat".
     *
     * @param controlPoints The anchor points of the slider.
     */
    private static bezierIsFlatEnough;
    /**
     * Approximates a bezier slider's path.
     *
     * This uses {@link https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm De Casteljau's algorithm} to obtain an optimal
     * piecewise-linear approximation of the bezier curve with the same amount of points as there are control points.
     *
     * @param controlPoints The control points describing the bezier curve to be approximated.
     * @param output The points representing the resulting piecewise-linear approximation.
     * @param subdivisionBuffer1 The first buffer containing the current subdivision state.
     * @param subdivisionBuffer2 The second buffer containing the current subdivision state.
     * @param count The number of control points in the original array.
     */
    private static bezierApproximate;
    /**
     * Subdivides `n` control points representing a bezier curve into 2 sets of `n` control points, each
     * describing a bezier curve equivalent to a half of the original curve. Effectively this splits
     * the original curve into 2 curves which result in the original curve when pieced back together.
     *
     * @param controlPoints The anchor points of the slider.
     * @param l Parts of the slider for approximation.
     * @param r Parts of the slider for approximation.
     * @param subdivisionBuffer Parts of the slider for approximation.
     * @param count The amount of anchor points in the slider.
     */
    private static bezierSubdivide;
    /**
     * Finds a point on the spline at the position of a parameter.
     *
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @param vec3 The third vector.
     * @param vec4 The fourth vector.
     * @param t The parameter at which to find the point on the spline, in the range [0, 1].
     */
    private static catmullFindPoint;
}

/**
 * Normalize a string path, reducing '..' and '.' parts.
 * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash,
 * it is preserved.
 *
 * This function's implementation matches Node.js v10.3 API.
 *
 * @param path string path to normalize.
 * @returns The normalized path.
 * @throws {TypeError} if `path` is not a string.
 */
declare function normalize(path: string): string;

/**
 * Represents the osu! playfield.
 */
declare abstract class Playfield {
    /**
     * The size of the playfield, which is 512x384.
     */
    static readonly baseSize: Vector2;
    /**
     * The center of the playfield, which is at (256, 192).
     */
    static readonly center: Vector2;
}

/**
 * A single-variable polynomial with real-valued coefficients and non-negative exponents.
 *
 * This class shares the same implementation as {@link https://numerics.mathdotnet.com/ Math.NET Numerics}.
 */
declare abstract class Polynomial {
    /**
     * Evaluates a polynomial at point `z`.
     *
     * Coefficients are ordered ascending by power with power `k` at index `k`.
     * For example, coefficients `[3, -1, 2]` represent `y = 2x^2 - x + 3`.
     *
     * @param z The location where to evaluate the polynomial at.
     * @param coefficients The coefficients of the polynomial, coefficient for power `k` at index `k`.
     * @returns The polynomial at `z`.
     */
    static evaluate(z: number, coefficients: readonly number[]): number;
}

/**
 * Represents the hit window of osu!droid _with_ the Precise mod.
 */
declare class PreciseDroidHitWindow extends HitWindow {
    /**
     * Calculates the overall difficulty value of a great (300) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static greatWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a good (100) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static okWindowToOD(value: number): number;
    /**
     * Calculates the overall difficulty value of a meh (50) hit window.
     *
     * @param value The value of the hit window, in milliseconds.
     * @returns The overall difficulty value.
     */
    static mehWindowToOD(value: number): number;
    get greatWindow(): number;
    get okWindow(): number;
    get mehWindow(): number;
}

/**
 * Precision utilities.
 */
declare abstract class Precision {
    static readonly FLOAT_EPSILON = 0.001;
    /**
     * Checks if two numbers are equal with a given tolerance.
     *
     * @param value1 The first number.
     * @param value2 The second number.
     * @param acceptableDifference The acceptable difference as threshold. Default is `Precision.FLOAT_EPSILON = 1e-3`.
     */
    static almostEqualsNumber(value1: number, value2: number, acceptableDifference?: number): boolean;
    /**
     * Checks if two vectors are equal with a given tolerance.
     *
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @param acceptableDifference The acceptable difference as threshold. Default is `Precision.FLOAT_EPSILON = 1e-3`.
     */
    static almostEqualsVector(vec1: Vector2, vec2: Vector2, acceptableDifference?: number): boolean;
    /**
     * Checks whether two real numbers are almost equal.
     *
     * @param a The first number.
     * @param b The second number.
     * @param maximumError The accuracy required for being almost equal. Defaults to `10 * 2^(-53)`.
     * @returns Whether the two values differ by no more than 10 * 2^(-52).
     */
    static almostEqualRelative(a: number, b: number, maximumError?: number): boolean;
    /**
     * Compares two numbers and determines if they are equal within the specified maximum error.
     *
     * @param a The norm of the first value (can be negative).
     * @param b The norm of the second value (can be negative).
     * @param diff The norm of the difference of the two values (can be negative).
     * @param maximumError The accuracy required for being almost equal.
     * @returns Whether both numbers are almost equal up to the specified maximum error.
     */
    static almostEqualNormRelative(a: number, b: number, diff: number, maximumError: number): boolean;
}

/**
 * Represents an information about a hitobject-specific sample bank.
 */
declare class SampleBankInfo {
    /**
     * The name of the sample bank file, if this sample bank uses custom samples.
     */
    filename: string;
    /**
     * The main sample bank.
     */
    normal: SampleBank;
    /**
     * The addition sample bank.
     */
    add: SampleBank;
    /**
     * The volume at which the sample bank is played.
     *
     * If this is 0, the control point's volume should be used instead.
     */
    volume: number;
    /**
     * The index of the sample bank, if this sample bank uses custom samples.
     *
     * If this is 0, the control point's sample index should be used instead.
     */
    customSampleBank: number;
    constructor(bankInfo?: SampleBankInfo);
}

/**
 * Possible ranks that a score can have.
 */
type ScoreRank = "XH" | "SH" | "X" | "S" | "A" | "B" | "C" | "D";

/**
 * Represents a slider repeat.
 */
declare class SliderRepeat extends SliderEndCircle {
}

/**
 * Represents a slider tick in a slider.
 */
declare class SliderTick extends SliderNestedHitObject {
    applyDefaults(controlPoints: BeatmapControlPoints, difficulty: BeatmapDifficulty, mode: Modes): void;
    protected createHitWindow(): HitWindow | null;
}

/**
 * Represents a storyboard sprite.
 */
declare class StoryboardSprite extends StoryboardElement {
    /**
     * The loop commands of the sprite.
     */
    readonly loops: CommandLoop[];
    /**
     * The trigger commands of the sprite.
     */
    readonly triggers: CommandTrigger[];
    /**
     * The origin of the sprite.
     */
    origin: Anchor;
    /**
     * The initial position of the sprite.
     */
    initialPosition: Vector2;
    /**
     * The command timeline group of the sprite.
     */
    readonly timelineGroup: CommandTimelineGroup;
    get startTime(): number;
    /**
     * The time at which the first transformation occurs.
     */
    get earliestTransformTime(): number;
    get endTime(): number;
    /**
     * Whether this sprite has at least one command.
     */
    get hasCommands(): boolean;
    constructor(path: string, origin: Anchor, initialPosition: Vector2);
    /**
     * Adds a loop command to the sprite.
     *
     * @param startTime The start time of the command.
     * @param repeatCount The total number of times this loop is played back. Must be greater than zero.
     * @returns The added command.
     */
    addLoop(startTime: number, repeatCount: number): CommandLoop;
    /**
     * Adds a trigger command.
     *
     * @param triggerName The name of the trigger.
     * @param startTime The start time of the command.
     * @param endTime The end time of the command.
     * @param groupNumber The group number of the command.
     * @returns The added command.
     */
    addTrigger(triggerName: string, startTime: number, endTime: number, groupNumber: number): CommandTrigger;
    toString(): string;
}

/**
 * Represents a storyboard's animation.
 */
declare class StoryboardAnimation extends StoryboardSprite {
    /**
     * The amount of frames that the animation has.
     */
    frameCount: number;
    /**
     * The delay between frames, in milliseconds.
     */
    frameDelay: number;
    /**
     * The loop type of the animation.
     */
    loopType: AnimationLoopType;
    constructor(path: string, origin: Anchor, initialPosition: Vector2, frameCount: number, frameDelay: number, loopType: AnimationLoopType);
}

/**
 * A storyboard decoder.
 */
declare class StoryboardDecoder extends Decoder<Storyboard, SectionDecoder<Storyboard>> {
    protected finalResult: Storyboard;
    protected decoders: Partial<Record<BeatmapSection, SectionDecoder<Storyboard>>>;
    constructor(formatVersion?: number);
    protected reset(): void;
}

/**
 * The base of per-section storyboard encoders.
 */
declare abstract class StoryboardBaseEncoder extends BaseEncoder {
    /**
     * The storyboard that is being encoded.
     */
    readonly storyboard: Storyboard;
    constructor(storyboard: Storyboard, encodeSections?: boolean);
}

/**
 * A storyboard encoder.
 *
 * Note that this storyboard encoder does not encode storyboards, and as such equality with the
 * original beatmap or storyboard file is not guaranteed (and usually will not be equal).
 */
declare class StoryboardEncoder extends Encoder<Storyboard, StoryboardBaseEncoder> {
    protected finalResult: string;
    protected encoders: StoryboardBaseEncoder[];
    private readonly encodeSections;
    constructor(target: Storyboard, encodeSections?: boolean);
    protected reset(): void;
}

/**
 * Types of storyboard events.
 */
declare enum StoryboardEventType {
    background = "Background",
    sprite = "Sprite",
    color = "Colour",
    sample = "Sample",
    animation = "Animation"
}

/**
 * Represents a storyboard sample.
 */
declare class StoryboardSample extends StoryboardElement {
    private _startTime;
    get startTime(): number;
    /**
     * The volume at which the sample is played.
     */
    readonly volume: number;
    constructor(path: string, time: number, volume: number);
}

/**
 * Some utilities, no biggie.
 */
declare abstract class Utils {
    /**
     * Returns a random element of an array.
     *
     * @param array The array to get the element from.
     */
    static getRandomArrayElement<T>(array: T[]): T;
    /**
     * Creates an array with specific length that's prefilled with an initial value.
     *
     * @param length The length of the array.
     * @param initialValue The initial value of each element, or a function that returns the initial value of each element.
     * @returns The array.
     */
    static initializeArray<T>(length: number, initialValue?: T | ((index: number) => T)): T[];
    /**
     * Pauses the execution of a function for
     * the specified duration.
     *
     * @param duration The duration to pause for, in seconds.
     */
    static sleep(duration: number): Promise<void>;
}

declare abstract class ZeroCrossingBracketing {
    /**
     * Detect a range containing at least one root.
     *
     * This iterative method stops when two values with opposite signs are found.
     *
     * @param f The function to detect roots from.
     * @param bounds The upper and lower value of the range.
     * @param factor The growing factor of research. Defaults to 1.6.
     * @param maxIterations Maximum number of iterations. Defaults to 50.
     * @returns Whether the bracketing operation succeeded.
     */
    static expand(f: (x: number) => number, bounds: RootBounds, factor?: number, maxIterations?: number): boolean;
    static reduce(f: (x: number) => number, bounds: RootBounds, subdivisions?: number): boolean;
    static expandReduce(f: (x: number) => number, bounds: RootBounds, expansionFactor?: number, expansionMaxIterations?: number, reduceSubdivisions?: number): boolean;
}

export { Accuracy, Anchor, AnimationLoopType, AnimationStyle, Axes, BankHitSampleInfo, Beatmap, BeatmapBackground, BeatmapColor, BeatmapControlPoints, BeatmapConverter, BeatmapCountdown, BeatmapDecoder, BeatmapDifficulty, BeatmapEditor, BeatmapEncoder, BeatmapEvents, BeatmapGeneral, BeatmapGenre, BeatmapHitObjects, BeatmapLanguage, BeatmapMetadata, BeatmapOverlayPosition, BeatmapProcessor, BeatmapVideo, BlendingEquation, BlendingParameters, BlendingType, BooleanModSetting, BreakPoint, Brent, Circle, CircleSizeCalculator, Command, CommandLoop, CommandTimeline, CommandTimelineGroup, type CommandTimelineSelector, CommandTrigger, ControlPointManager, DecimalModSetting, DifficultyControlPoint, DifficultyControlPointManager, type DroidAPIEndpoint, DroidAPIRequestBuilder, DroidHitWindow, DroidLegacyModConverter, DroidPlayableBeatmap, Easing, EditorGridSize, EffectControlPoint, EffectControlPointManager, EmptyHitWindow, ErrorFunction, FileHitSampleInfo, GameMode, HitObject, HitObjectGenerationUtils, HitSampleInfo, HitSoundType, HitWindow, type IBeatmap, type ICommandTimeline, type IMigratableDroidMod, type IModApplicableToBeatmap, type IModApplicableToDifficulty, type IModApplicableToDifficultyWithMods, type IModApplicableToDroid, type IModApplicableToHitObject, type IModApplicableToHitObjectWithMods, type IModApplicableToOsu, type IModApplicableToOsuStable, type IModApplicableToTrackRate, type IModFacilitatesAdjustment, type If, IntegerModSetting, Interpolation, MapInfo, MathUtils, Mod, ModApproachDifferent, ModAuto, ModAutopilot, ModCustomSpeed, ModDeflate, ModDifficultyAdjust, ModDoubleTime, ModEasy, ModFlashlight, ModFreezeFrame, ModGrow, ModHalfTime, ModHardRock, ModHidden, ModMap, ModMirror, ModMuted, ModNightCore, ModNoFail, ModObjectScaleTween, ModOldNightCore, ModPerfect, ModPrecise, ModRandom, ModRateAdjust, ModReallyEasy, ModRelax, ModReplayV6, ModScoreV2, ModSetting, type ModSettingValueChangedListener, ModSmallCircle, ModSpunOut, ModSuddenDeath, ModTimeRamp, ModTouchDevice, ModTraceable, ModUtil, ModWindDown, ModWindUp, Modes, NormalDistribution, NullableDecimalModSetting, NullableIntegerModSetting, NumberModSetting, ObjectTypes, type OmitType, type OsuAPIEndpoint, OsuAPIRequestBuilder, type OsuAPIResponse, OsuHitWindow, OsuPlayableBeatmap, PathApproximator, PathType, type PlaceableHitObject, PlayableBeatmap, Playfield, Polynomial, PreciseDroidHitWindow, Precision, RGBColor, Random, RangeConstrainedModSetting, RankedStatus, type RequestResponse, type RootBounds, SampleBank, SampleBankInfo, SampleControlPoint, SampleControlPointManager, type ScoreRank, SequenceHitSampleInfo, type SerializedMod, Slider, SliderHead, SliderNestedHitObject, SliderPath, SliderRepeat, SliderTail, SliderTick, Spinner, Storyboard, StoryboardAnimation, StoryboardCommandType, StoryboardDecoder, StoryboardElement, StoryboardEncoder, StoryboardEventType, StoryboardLayer, StoryboardLayerType, StoryboardParameterCommandType, StoryboardSample, StoryboardSprite, TimedHitSampleInfo, TimingControlPoint, TimingControlPointManager, Utils, Vector2, Vector4, ZeroCrossingBracketing, normalize };
