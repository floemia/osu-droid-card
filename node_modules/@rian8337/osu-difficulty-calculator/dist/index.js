'use strict';

var osuBase = require('@rian8337/osu-base');

/**
 * Holds data that can be used to calculate performance points.
 */
class DifficultyAttributes {
    constructor(cacheableAttributes) {
        this.mods = new osuBase.ModMap();
        this.starRating = 0;
        this.maxCombo = 0;
        this.aimDifficulty = 0;
        this.flashlightDifficulty = 0;
        this.speedNoteCount = 0;
        this.sliderFactor = 1;
        this.clockRate = 1;
        this.overallDifficulty = 0;
        this.hitCircleCount = 0;
        this.sliderCount = 0;
        this.spinnerCount = 0;
        this.aimDifficultSliderCount = 0;
        this.aimDifficultStrainCount = 0;
        if (!cacheableAttributes) {
            return;
        }
        this.mods = osuBase.ModUtil.deserializeMods(cacheableAttributes.mods);
        this.starRating = cacheableAttributes.starRating;
        this.maxCombo = cacheableAttributes.maxCombo;
        this.aimDifficulty = cacheableAttributes.aimDifficulty;
        this.flashlightDifficulty = cacheableAttributes.flashlightDifficulty;
        this.speedNoteCount = cacheableAttributes.speedNoteCount;
        this.sliderFactor = cacheableAttributes.sliderFactor;
        this.clockRate = cacheableAttributes.clockRate;
        this.overallDifficulty = cacheableAttributes.overallDifficulty;
        this.hitCircleCount = cacheableAttributes.hitCircleCount;
        this.sliderCount = cacheableAttributes.sliderCount;
        this.spinnerCount = cacheableAttributes.spinnerCount;
        this.aimDifficultSliderCount =
            cacheableAttributes.aimDifficultSliderCount;
        this.aimDifficultStrainCount =
            cacheableAttributes.aimDifficultStrainCount;
    }
    /**
     * Converts this `DifficultyAttributes` instance to an attribute structure that can be cached.
     *
     * @returns The cacheable attributes.
     */
    toCacheableAttributes() {
        return Object.assign(Object.assign({}, this), { mods: this.mods.serializeMods() });
    }
    /**
     * Returns a string representation of the difficulty attributes.
     */
    toString() {
        return `${this.starRating.toFixed(2)} stars`;
    }
}

/**
 * The base of a difficulty calculator.
 */
class DifficultyCalculator {
    constructor() {
        /**
         * `Mod`s that adjust the difficulty of a beatmap.
         */
        this.difficultyAdjustmentMods = new Set([
            osuBase.ModDoubleTime,
            osuBase.ModNightCore,
            osuBase.ModDifficultyAdjust,
            osuBase.ModCustomSpeed,
            osuBase.ModHalfTime,
            osuBase.ModEasy,
            osuBase.ModHardRock,
            osuBase.ModFlashlight,
            osuBase.ModHidden,
            osuBase.ModRelax,
            osuBase.ModAutopilot,
        ]);
    }
    calculate(beatmap, mods) {
        const playableBeatmap = beatmap instanceof osuBase.PlayableBeatmap
            ? beatmap
            : this.createPlayableBeatmap(beatmap, mods);
        const skills = this.createSkills(playableBeatmap);
        const objects = this.createDifficultyHitObjects(playableBeatmap);
        for (const object of objects) {
            for (const skill of skills) {
                skill.process(object);
            }
        }
        return this.createDifficultyAttributes(playableBeatmap, skills, objects);
    }
    calculateStrainPeaks(beatmap, mods) {
        const playableBeatmap = beatmap instanceof osuBase.PlayableBeatmap
            ? beatmap
            : this.createPlayableBeatmap(beatmap, mods);
        const skills = this.createStrainPeakSkills(playableBeatmap);
        const objects = this.createDifficultyHitObjects(playableBeatmap);
        for (const object of objects) {
            for (const skill of skills) {
                skill.process(object);
            }
        }
        return {
            aimWithSliders: skills[0].strainPeaks,
            aimWithoutSliders: skills[1].strainPeaks,
            speed: skills[2].strainPeaks,
            flashlight: skills[3].strainPeaks,
        };
    }
    /**
     * Calculates the base rating of a `Skill`.
     *
     * @param skill The `Skill` to calculate the rating of.
     * @returns The rating of the `Skill`.
     */
    calculateRating(skill) {
        return Math.sqrt(skill.difficultyValue()) * this.difficultyMultiplier;
    }
    /**
     * Calculates the base performance value of a difficulty rating.
     *
     * @param rating The difficulty rating.
     */
    basePerformanceValue(rating) {
        return Math.pow(5 * Math.max(1, rating / 0.0675) - 4, 3) / 100000;
    }
}

/**
 * Represents a hit object with difficulty calculation values.
 */
class DifficultyHitObject {
    /**
     * The normalized diameter of the hitobject.
     */
    static get normalizedDiameter() {
        return this.normalizedRadius * 2;
    }
    /**
     * Note: You **must** call `computeProperties` at some point due to how TypeScript handles
     * overridden properties (see [this](https://github.com/microsoft/TypeScript/issues/1617) GitHub issue).
     *
     * @param object The underlying hitobject.
     * @param lastObject The hitobject before this hitobject.
     * @param lastLastObject The hitobject before the last hitobject.
     * @param difficultyHitObjects All difficulty hitobjects in the processed beatmap.
     * @param clockRate The clock rate of the beatmap.
     */
    constructor(object, lastObject, lastLastObject, difficultyHitObjects, clockRate, index) {
        var _a, _b, _c, _d;
        /**
         * The aim strain generated by the hitobject if sliders are considered.
         */
        this.aimStrainWithSliders = 0;
        /**
         * The aim strain generated by the hitobject if sliders are not considered.
         */
        this.aimStrainWithoutSliders = 0;
        /**
         * The rhythm multiplier generated by the hitobject. This is used to alter tap strain.
         */
        this.rhythmMultiplier = 0;
        /**
         * The normalized distance from the "lazy" end position of the previous hitobject to the start position of this hitobject.
         *
         * The "lazy" end position is the position at which the cursor ends up if the previous hitobject is followed with as minimal movement as possible (i.e. on the edge of slider follow circles).
         */
        this.lazyJumpDistance = 0;
        /**
         * The normalized shortest distance to consider for a jump between the previous hitobject and this hitobject.
         *
         * This is bounded from above by `lazyJumpDistance`, and is smaller than the former if a more natural path is able to be taken through the previous hitobject.
         *
         * Suppose a linear slider - circle pattern. Following the slider lazily (see: `lazyJumpDistance`) will result in underestimating the true end position of the slider as being closer towards the start position.
         * As a result, `lazyJumpDistance` overestimates the jump distance because the player is able to take a more natural path by following through the slider to its end,
         * such that the jump is felt as only starting from the slider's true end position.
         *
         * Now consider a slider - circle pattern where the circle is stacked along the path inside the slider.
         * In this case, the lazy end position correctly estimates the true end position of the slider and provides the more natural movement path.
         */
        this.minimumJumpDistance = 0;
        /**
         * The time taken to travel through `minimumJumpDistance`, with a minimum value of 25ms.
         */
        this.minimumJumpTime = 0;
        /**
         * The normalized distance between the start and end position of this hitobject.
         */
        this.travelDistance = 0;
        /**
         * The time taken to travel through `travelDistance`, with a minimum value of 25ms for sliders.
         */
        this.travelTime = 0;
        /**
         * Angle the player has to take to hit this hitobject.
         *
         * Calculated as the angle between the circles (current-2, current-1, current).
         */
        this.angle = null;
        this.maximumSliderRadius = DifficultyHitObject.normalizedRadius * 2.4;
        this.assumedSliderRadius = DifficultyHitObject.normalizedRadius * 1.8;
        this.object = object;
        this.lastObject = lastObject;
        this.lastLastObject = lastLastObject;
        this.hitObjects = difficultyHitObjects;
        if (object instanceof osuBase.Slider) {
            this.fullGreatWindow =
                ((_b = (_a = object.head.hitWindow) === null || _a === void 0 ? void 0 : _a.greatWindow) !== null && _b !== void 0 ? _b : 1200) * 2;
        }
        else {
            this.fullGreatWindow = ((_d = (_c = object.hitWindow) === null || _c === void 0 ? void 0 : _c.greatWindow) !== null && _d !== void 0 ? _d : 1200) * 2;
        }
        this.fullGreatWindow /= clockRate;
        this.index = index;
        // Capped to 25ms to prevent difficulty calculation breaking from simultaneous objects.
        this.startTime = object.startTime / clockRate;
        this.endTime = object.endTime / clockRate;
        if (lastObject) {
            this.deltaTime = this.startTime - lastObject.startTime / clockRate;
            this.strainTime = Math.max(this.deltaTime, DifficultyHitObject.minDeltaTime);
        }
        else {
            this.deltaTime = 0;
            this.strainTime = 0;
        }
    }
    /**
     * Computes the properties of this hitobject.
     *
     * @param clockRate The clock rate of the beatmap.
     * @param hitObjects The hitobjects in the beatmap.
     */
    computeProperties(clockRate, 
    // Required for `DroidDifficultyHitObject` override.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hitObjects) {
        this.setDistances(clockRate);
    }
    /**
     * Gets the difficulty hitobject at a specific index with respect to the current
     * difficulty hitobject's index.
     *
     * Will return `null` if the index is out of range.
     *
     * @param backwardsIndex The index to move backwards for.
     * @returns The difficulty hitobject at the index with respect to the current
     * difficulty hitobject's index, `null` if the index is out of range.
     */
    previous(backwardsIndex) {
        var _a;
        return ((_a = this.hitObjects[this.index - backwardsIndex - 1]) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * Gets the difficulty hitobject at a specific index with respect to the current
     * difficulty hitobject's index.
     *
     * Will return `null` if the index is out of range.
     *
     * @param forwardsIndex The index to move forwards for.
     * @returns The difficulty hitobject at the index with respect to the current
     * difficulty hitobject's index, `null` if the index is out of range.
     */
    next(forwardsIndex) {
        var _a;
        return ((_a = this.hitObjects[this.index + forwardsIndex + 1]) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * Calculates the opacity of the hitobject at a given time.
     *
     * @param time The time to calculate the hitobject's opacity at.
     * @param mods The mods used.
     * @returns The opacity of the hitobject at the given time.
     */
    opacityAt(time, mods) {
        if (time > this.object.startTime) {
            // Consider a hitobject as being invisible when its start time is passed.
            // In reality the hitobject will be visible beyond its start time up until its hittable window has passed,
            // but this is an approximation and such a case is unlikely to be hit where this function is used.
            return 0;
        }
        const fadeInStartTime = this.object.startTime - this.object.timePreempt;
        const fadeInDuration = this.object.timeFadeIn;
        if (mods.has(osuBase.ModHidden)) {
            const fadeOutStartTime = fadeInStartTime + fadeInDuration;
            const fadeOutDuration = this.object.timePreempt * osuBase.ModHidden.fadeOutDurationMultiplier;
            return Math.min(osuBase.MathUtils.clamp((time - fadeInStartTime) / fadeInDuration, 0, 1), 1 -
                osuBase.MathUtils.clamp((time - fadeOutStartTime) / fadeOutDuration, 0, 1));
        }
        return osuBase.MathUtils.clamp((time - fadeInStartTime) / fadeInDuration, 0, 1);
    }
    /**
     * How possible is it to doubletap this object together with the next one and get perfect
     * judgement in range from 0 to 1.
     *
     * A value closer to 1 indicates a higher possibility.
     */
    get doubletapness() {
        const next = this.next(0);
        if (!next) {
            return 0;
        }
        const currentDeltaTime = Math.max(1, this.deltaTime);
        const nextDeltaTime = Math.max(1, next.deltaTime);
        const deltaDifference = Math.abs(nextDeltaTime - currentDeltaTime);
        const speedRatio = currentDeltaTime / Math.max(currentDeltaTime, deltaDifference);
        const windowRatio = Math.pow(Math.min(1, currentDeltaTime / this.fullGreatWindow), 2);
        return 1 - Math.pow(speedRatio, 1 - windowRatio);
    }
    setDistances(clockRate) {
        if (this.object instanceof osuBase.Slider) {
            this.calculateSliderCursorPosition(this.object);
            this.travelDistance = this.object.lazyTravelDistance;
            // Bonus for repeat sliders until a better per nested object strain system can be achieved.
            if (this.mode === osuBase.Modes.droid) {
                this.travelDistance *= Math.pow(1 + this.object.repeatCount / 4, 1 / 4);
            }
            else {
                this.travelDistance *= Math.pow(1 + this.object.repeatCount / 2.5, 1 / 2.5);
            }
            this.travelTime = Math.max(this.object.lazyTravelTime / clockRate, DifficultyHitObject.minDeltaTime);
        }
        // We don't need to calculate either angle or distance when one of the last->curr objects is a spinner.
        if (!this.lastObject ||
            this.object instanceof osuBase.Spinner ||
            this.lastObject instanceof osuBase.Spinner) {
            return;
        }
        // We will scale distances by this factor, so we can assume a uniform CircleSize among beatmaps.
        const { scalingFactor } = this;
        const lastCursorPosition = this.getEndCursorPosition(this.lastObject);
        this.lazyJumpDistance = this.object
            .getStackedPosition(this.mode)
            .scale(scalingFactor)
            .subtract(lastCursorPosition.scale(scalingFactor)).length;
        this.minimumJumpTime = this.strainTime;
        this.minimumJumpDistance = this.lazyJumpDistance;
        if (this.lastObject instanceof osuBase.Slider) {
            const lastTravelTime = Math.max(this.lastObject.lazyTravelTime / clockRate, DifficultyHitObject.minDeltaTime);
            this.minimumJumpTime = Math.max(this.strainTime - lastTravelTime, DifficultyHitObject.minDeltaTime);
            // There are two types of slider-to-object patterns to consider in order to better approximate the real movement a player will take to jump between the hitobjects.
            //
            // 1. The anti-flow pattern, where players cut the slider short in order to move to the next hitobject.
            //
            //      <======o==>  ← slider
            //             |     ← most natural jump path
            //             o     ← a follow-up hitcircle
            //
            // In this case the most natural jump path is approximated by LazyJumpDistance.
            //
            // 2. The flow pattern, where players follow through the slider to its visual extent into the next hitobject.
            //
            //      <======o==>---o
            //                  ↑
            //        most natural jump path
            //
            // In this case the most natural jump path is better approximated by a new distance called "tailJumpDistance" - the distance between the slider's tail and the next hitobject.
            //
            // Thus, the player is assumed to jump the minimum of these two distances in all cases.
            const tailJumpDistance = this.lastObject.tail
                .getStackedPosition(this.mode)
                .subtract(this.object.getStackedPosition(this.mode))
                .length * scalingFactor;
            this.minimumJumpDistance = Math.max(0, Math.min(this.lazyJumpDistance -
                (this.maximumSliderRadius - this.assumedSliderRadius), tailJumpDistance - this.maximumSliderRadius));
        }
        if (this.lastLastObject && !(this.lastLastObject instanceof osuBase.Spinner)) {
            const lastLastCursorPosition = this.getEndCursorPosition(this.lastLastObject);
            const v1 = lastLastCursorPosition.subtract(this.lastObject.getStackedPosition(this.mode));
            const v2 = this.object
                .getStackedPosition(this.mode)
                .subtract(lastCursorPosition);
            const dot = v1.dot(v2);
            const det = v1.x * v2.y - v1.y * v2.x;
            this.angle = Math.abs(Math.atan2(det, dot));
        }
    }
    calculateSliderCursorPosition(slider) {
        if (slider.lazyEndPosition) {
            return;
        }
        let trackingEndTime = slider.endTime;
        let { nestedHitObjects: nestedObjects } = slider;
        if (this.mode === osuBase.Modes.osu) {
            trackingEndTime = Math.max(slider.endTime - osuBase.Slider.legacyLastTickOffset, slider.startTime + slider.duration / 2);
            let lastRealTick = null;
            for (let i = nestedObjects.length - 2; i > 0; --i) {
                const current = nestedObjects[i];
                if (current instanceof osuBase.SliderTick) {
                    lastRealTick = current;
                    break;
                }
                if (current instanceof osuBase.SliderRepeat) {
                    // A repeat means the slider does not have a slider tick.
                    break;
                }
            }
            if (lastRealTick && lastRealTick.startTime > trackingEndTime) {
                trackingEndTime = lastRealTick.startTime;
                // When the last tick falls after the tracking end time, we need to re-sort the nested objects
                // based on time. This creates a somewhat weird ordering which is counter to how a user would
                // understand the slider, but allows a zero-diff with known diffcalc output.
                //
                // To reiterate, this is definitely not correct from a difficulty calculation perspective
                // and should be revisited at a later date.
                const reordered = nestedObjects.slice();
                reordered.splice(reordered.indexOf(lastRealTick), 1);
                reordered.push(lastRealTick);
                nestedObjects = reordered;
            }
        }
        if (this.mode === osuBase.Modes.droid) {
            // Temporary lazy end position until a real result can be derived.
            slider.lazyEndPosition = slider.getStackedPosition(this.mode);
            // Stop here if the slider has too short duration, allowing the player to essentially
            // complete the slider without movement, making travel distance and time irrelevant.
            if (osuBase.Precision.almostEqualsNumber(slider.startTime, slider.endTime)) {
                return;
            }
        }
        slider.lazyTravelTime = trackingEndTime - slider.startTime;
        let endTimeMin = slider.lazyTravelTime / slider.spanDuration;
        if (endTimeMin % 2 >= 1) {
            endTimeMin = 1 - (endTimeMin % 1);
        }
        else {
            endTimeMin %= 1;
        }
        // Temporary lazy end position until a real result can be derived.
        slider.lazyEndPosition = slider
            .getStackedPosition(this.mode)
            .add(slider.path.positionAt(endTimeMin));
        let currentCursorPosition = slider.getStackedPosition(this.mode);
        const scalingFactor = DifficultyHitObject.normalizedRadius / slider.radius;
        for (let i = 1; i < nestedObjects.length; ++i) {
            const currentMovementObject = nestedObjects[i];
            let currentMovement = currentMovementObject
                .getStackedPosition(this.mode)
                .subtract(currentCursorPosition);
            let currentMovementLength = scalingFactor * currentMovement.length;
            // The amount of movement required so that the cursor position needs to be updated.
            let requiredMovement = this.assumedSliderRadius;
            if (i === nestedObjects.length - 1) {
                // The end of a slider has special aim rules due to the relaxed time constraint on position.
                // There is both a lazy end position as well as the actual end slider position. We assume the player takes the simpler movement.
                // For sliders that are circular, the lazy end position may actually be farther away than the sliders' true end.
                // This code is designed to prevent buffing situations where lazy end is actually a less efficient movement.
                const lazyMovement = slider.lazyEndPosition.subtract(currentCursorPosition);
                if (lazyMovement.length < currentMovement.length) {
                    currentMovement = lazyMovement;
                }
                currentMovementLength = scalingFactor * currentMovement.length;
            }
            else if (currentMovementObject instanceof osuBase.SliderRepeat) {
                // For a slider repeat, assume a tighter movement threshold to better assess repeat sliders.
                requiredMovement = DifficultyHitObject.normalizedRadius;
            }
            if (currentMovementLength > requiredMovement) {
                // This finds the positional delta from the required radius and the current position,
                // and updates the currentCursorPosition accordingly, as well as rewarding distance.
                currentCursorPosition = currentCursorPosition.add(currentMovement.scale((currentMovementLength - requiredMovement) /
                    currentMovementLength));
                currentMovementLength *=
                    (currentMovementLength - requiredMovement) /
                        currentMovementLength;
                slider.lazyTravelDistance += currentMovementLength;
            }
            if (i === nestedObjects.length - 1) {
                slider.lazyEndPosition = currentCursorPosition;
            }
        }
    }
    getEndCursorPosition(object) {
        var _a;
        let pos = object.getStackedPosition(this.mode);
        if (object instanceof osuBase.Slider) {
            this.calculateSliderCursorPosition(object);
            pos = (_a = object.lazyEndPosition) !== null && _a !== void 0 ? _a : pos;
        }
        return pos;
    }
}
/**
 * The normalized radius of the hitobject.
 */
DifficultyHitObject.normalizedRadius = 50;
/**
 * The lowest possible delta time value.
 */
DifficultyHitObject.minDeltaTime = 25;

/**
 * Represents an osu!droid hit object with difficulty calculation values.
 */
class DroidDifficultyHitObject extends DifficultyHitObject {
    get scalingFactor() {
        const radius = this.object.radius;
        // We will scale distances by this factor, so we can assume a uniform CircleSize among beatmaps.
        let scalingFactor = DifficultyHitObject.normalizedRadius / radius;
        // High circle size (small CS) bonus
        if (radius < this.radiusBuffThreshold) {
            scalingFactor *=
                1 + Math.pow((this.radiusBuffThreshold - radius) / 50, 2);
        }
        return scalingFactor;
    }
    /**
     * Note: You **must** call `computeProperties` at some point due to how TypeScript handles
     * overridden properties (see [this](https://github.com/microsoft/TypeScript/issues/1617) GitHub issue).
     *
     * @param object The underlying hitobject.
     * @param lastObject The hitobject before this hitobject.
     * @param lastLastObject The hitobject before the last hitobject.
     * @param difficultyHitObjects All difficulty hitobjects in the processed beatmap.
     * @param clockRate The clock rate of the beatmap.
     */
    constructor(object, lastObject, lastLastObject, difficultyHitObjects, clockRate, index) {
        super(object, lastObject, lastLastObject, difficultyHitObjects, clockRate, index);
        /**
         * The tap strain generated by the hitobject.
         */
        this.tapStrain = 0;
        /**
         * The tap strain generated by the hitobject if `strainTime` isn't modified by
         * OD. This is used in three-finger detection.
         */
        this.originalTapStrain = 0;
        /**
         * The rhythm strain generated by the hitobject.
         */
        this.rhythmStrain = 0;
        /**
         * The flashlight strain generated by the hitobject if sliders are considered.
         */
        this.flashlightStrainWithSliders = 0;
        /**
         * The flashlight strain generated by the hitobject if sliders are not considered.
         */
        this.flashlightStrainWithoutSliders = 0;
        /**
         * The visual strain generated by the hitobject if sliders are considered.
         */
        this.visualStrainWithSliders = 0;
        /**
         * The visual strain generated by the hitobject if sliders are not considered.
         */
        this.visualStrainWithoutSliders = 0;
        /**
         * The note density of the hitobject.
         */
        this.noteDensity = 1;
        /**
         * The overlapping factor of the hitobject.
         *
         * This is used to scale visual skill.
         */
        this.overlappingFactor = 0;
        this.radiusBuffThreshold = 70;
        this.mode = osuBase.Modes.droid;
        this.maximumSliderRadius = DifficultyHitObject.normalizedRadius * 2;
        this.timePreempt = object.timePreempt / clockRate;
    }
    computeProperties(clockRate, hitObjects) {
        super.computeProperties(clockRate, hitObjects);
        this.setVisuals(clockRate, hitObjects);
    }
    opacityAt(time, mods) {
        // Traceable hides the primary piece of a hit circle (that is, its body), so consider it as fully invisible.
        if (this.object instanceof osuBase.Circle && mods.has(osuBase.ModTraceable)) {
            return 0;
        }
        return super.opacityAt(time, mods);
    }
    previous(backwardsIndex) {
        var _a;
        return (_a = this.hitObjects[this.index - backwardsIndex]) !== null && _a !== void 0 ? _a : null;
    }
    next(forwardsIndex) {
        var _a;
        return ((_a = this.hitObjects[this.index + forwardsIndex + 2]) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * Determines whether this hitobject is considered overlapping with the hitobject before it.
     *
     * Keep in mind that "overlapping" in this case is overlapping to the point where both hitobjects
     * can be hit with just a single tap in osu!droid.
     *
     * In the case of sliders, it is considered overlapping if all nested hitobjects can be hit with
     * one aim motion.
     *
     * @param considerDistance Whether to consider the distance between both hitobjects.
     * @returns Whether the hitobject is considered overlapping.
     */
    isOverlapping(considerDistance) {
        if (this.object instanceof osuBase.Spinner) {
            return false;
        }
        const prev = this.previous(0);
        if (!prev || prev.object instanceof osuBase.Spinner) {
            return false;
        }
        if (this.object.startTime !== prev.object.startTime) {
            return false;
        }
        if (!considerDistance) {
            return true;
        }
        const distanceThreshold = 2 * this.object.radius;
        const startPosition = this.object.getStackedPosition(osuBase.Modes.droid);
        const prevStartPosition = prev.object.getStackedPosition(osuBase.Modes.droid);
        // We need to consider two cases:
        //
        // Case 1: Current object is a circle, or previous object is a circle.
        // In this case, we only need to check if their positions are close enough to be tapped together.
        //
        // Case 2: Both objects are sliders.
        // In this case, we need to check if all nested hitobjects can be hit together.
        // To start with, check if the starting positions can be tapped together.
        if (startPosition.getDistance(prevStartPosition) > distanceThreshold) {
            return false;
        }
        if (this.object instanceof osuBase.Circle || prev.object instanceof osuBase.Circle) {
            return true;
        }
        // Check if all nested hitobjects can be hit together.
        for (let i = 1; i < this.object.nestedHitObjects.length; ++i) {
            const position = this.object.nestedHitObjects[i].getStackedPosition(osuBase.Modes.droid);
            const prevPosition = prevStartPosition.add(prev.object.curvePositionAt(i / (this.object.nestedHitObjects.length - 1)));
            if (position.getDistance(prevPosition) > distanceThreshold) {
                return false;
            }
        }
        // Do the same for the previous slider as well.
        for (let i = 1; i < prev.object.nestedHitObjects.length; ++i) {
            const prevPosition = prev.object.nestedHitObjects[i].getStackedPosition(osuBase.Modes.droid);
            const position = startPosition.add(this.object.curvePositionAt(i / (prev.object.nestedHitObjects.length - 1)));
            if (prevPosition.getDistance(position) > distanceThreshold) {
                return false;
            }
        }
        return true;
    }
    setVisuals(clockRate, hitObjects) {
        // We'll have two visible object arrays. The first array contains objects before the current object starts in a reversed order,
        // while the second array contains objects after the current object ends.
        // For overlapping factor, we also need to consider previous visible objects.
        const prevVisibleObjects = [];
        const nextVisibleObjects = [];
        for (let j = this.index + 2; j < hitObjects.length; ++j) {
            const o = hitObjects[j];
            if (o instanceof osuBase.Spinner) {
                continue;
            }
            if (o.startTime / clockRate > this.endTime + this.timePreempt) {
                break;
            }
            nextVisibleObjects.push(o);
        }
        for (let j = 0; j < this.index; ++j) {
            const prev = this.previous(j);
            if (prev.object instanceof osuBase.Spinner) {
                continue;
            }
            if (prev.startTime >= this.startTime) {
                continue;
            }
            if (prev.startTime < this.startTime - this.timePreempt) {
                break;
            }
            prevVisibleObjects.push(prev.object);
        }
        for (const hitObject of prevVisibleObjects) {
            const distance = this.object
                .getStackedPosition(this.mode)
                .getDistance(hitObject.getStackedEndPosition(this.mode));
            const deltaTime = this.startTime - hitObject.endTime / clockRate;
            this.applyToOverlappingFactor(distance, deltaTime);
        }
        for (const hitObject of nextVisibleObjects) {
            const distance = hitObject
                .getStackedPosition(this.mode)
                .getDistance(this.object.getStackedEndPosition(this.mode));
            const deltaTime = hitObject.startTime / clockRate - this.endTime;
            if (deltaTime >= 0) {
                this.noteDensity += 1 - deltaTime / this.timePreempt;
            }
            this.applyToOverlappingFactor(distance, deltaTime);
        }
    }
    applyToOverlappingFactor(distance, deltaTime) {
        // Penalize objects that are too close to the object in both distance
        // and delta time to prevent stream maps from being overweighted.
        this.overlappingFactor +=
            Math.max(0, 1 - distance / (2.5 * this.object.radius)) *
                (7.5 /
                    (1 +
                        Math.exp(0.15 *
                            (Math.max(deltaTime, DifficultyHitObject.minDeltaTime) -
                                75))));
    }
}

/**
 * An evaluator for calculating osu!droid Aim skill.
 */
class DroidAimEvaluator {
    /**
     * Evaluates the difficulty of aiming the current object, based on:
     *
     * - cursor velocity to the current object,
     * - angle difficulty,
     * - sharp velocity increases,
     * - and slider difficulty.
     *
     * @param current The current object.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current, withSliders) {
        if (current.object instanceof osuBase.Spinner ||
            // Exclude overlapping objects that can be tapped at once.
            current.isOverlapping(true)) {
            return 0;
        }
        return (this.snapAimStrainOf(current, withSliders) +
            this.flowAimStrainOf(current));
    }
    /**
     * Calculates the snap aim strain of a hitobject.
     */
    static snapAimStrainOf(current, withSliders) {
        var _a;
        if (current.index <= 1 ||
            ((_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.object) instanceof osuBase.Spinner) {
            return 0;
        }
        const last = current.previous(0);
        const lastLast = current.previous(1);
        const radius = DroidDifficultyHitObject.normalizedRadius;
        const diameter = DroidDifficultyHitObject.normalizedDiameter;
        // Calculate the velocity to the current hitobject, which starts with a base distance / time assuming the last object is a hitcircle.
        let currentVelocity = current.lazyJumpDistance / current.strainTime;
        // But if the last object is a slider, then we extend the travel velocity through the slider into the current object.
        if (last.object instanceof osuBase.Slider && withSliders) {
            // Calculate the slider velocity from slider head to slider end.
            const travelVelocity = last.travelDistance / last.travelTime;
            // Calculate the movement velocity from slider end to current object.
            const movementVelocity = current.minimumJumpTime !== 0
                ? current.minimumJumpDistance / current.minimumJumpTime
                : 0;
            // Take the larger total combined velocity.
            currentVelocity = Math.max(currentVelocity, movementVelocity + travelVelocity);
        }
        // As above, do the same for the previous hitobject.
        let prevVelocity = last.lazyJumpDistance / last.strainTime;
        if (lastLast.object instanceof osuBase.Slider && withSliders) {
            const travelVelocity = lastLast.travelDistance / lastLast.travelTime;
            const movementVelocity = last.minimumJumpTime !== 0
                ? last.minimumJumpDistance / last.minimumJumpTime
                : 0;
            prevVelocity = Math.max(prevVelocity, movementVelocity + travelVelocity);
        }
        let wideAngleBonus = 0;
        let acuteAngleBonus = 0;
        let sliderBonus = 0;
        let velocityChangeBonus = 0;
        let wiggleBonus = 0;
        // Start strain with regular velocity.
        let strain = currentVelocity;
        if (
        // If rhythms are the same.
        Math.max(current.strainTime, last.strainTime) <
            1.25 * Math.min(current.strainTime, last.strainTime) &&
            current.angle !== null &&
            last.angle !== null) {
            const currentAngle = current.angle;
            const lastAngle = last.angle;
            // Rewarding angles, take the smaller velocity as base.
            const angleBonus = Math.min(currentVelocity, prevVelocity);
            wideAngleBonus = this.calculateWideAngleBonus(current.angle);
            acuteAngleBonus = this.calculateAcuteAngleBonus(current.angle);
            // Penalize angle repetition.
            wideAngleBonus *=
                1 -
                    Math.min(wideAngleBonus, Math.pow(this.calculateWideAngleBonus(lastAngle), 3));
            acuteAngleBonus *=
                0.08 +
                    0.92 *
                        (1 -
                            Math.min(acuteAngleBonus, Math.pow(this.calculateAcuteAngleBonus(lastAngle), 3)));
            // Apply full wide angle bonus for distance more than one diameter
            wideAngleBonus *=
                angleBonus *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, 0, diameter);
            // Apply acute angle bonus for BPM above 300 1/2 and distance more than one diameter
            acuteAngleBonus *=
                angleBonus *
                    osuBase.MathUtils.smootherstep(osuBase.MathUtils.millisecondsToBPM(current.strainTime, 2), 300, 400) *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, diameter, diameter * 2);
            // Apply wiggle bonus for jumps that are [radius, 3*diameter] in distance, with < 110 angle
            // https://www.desmos.com/calculator/dp0v0nvowc
            wiggleBonus =
                angleBonus *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, radius, diameter) *
                    Math.pow(osuBase.MathUtils.reverseLerp(current.lazyJumpDistance, diameter * 3, diameter), 1.8) *
                    osuBase.MathUtils.smootherstep(currentAngle, osuBase.MathUtils.degreesToRadians(110), osuBase.MathUtils.degreesToRadians(60)) *
                    osuBase.MathUtils.smootherstep(last.lazyJumpDistance, radius, diameter) *
                    Math.pow(osuBase.MathUtils.reverseLerp(last.lazyJumpDistance, diameter * 3, diameter), 1.8) *
                    osuBase.MathUtils.smootherstep(lastAngle, osuBase.MathUtils.degreesToRadians(110), osuBase.MathUtils.degreesToRadians(60));
        }
        if (Math.max(prevVelocity, currentVelocity)) {
            // We want to use the average velocity over the whole object when awarding differences, not the individual jump and slider path velocities.
            prevVelocity =
                (last.lazyJumpDistance + lastLast.travelDistance) /
                    last.strainTime;
            currentVelocity =
                (current.lazyJumpDistance + last.travelDistance) /
                    current.strainTime;
            // Scale with ratio of difference compared to half the max distance.
            const distanceRatio = Math.pow(Math.sin(((Math.PI / 2) * Math.abs(prevVelocity - currentVelocity)) /
                Math.max(prevVelocity, currentVelocity)), 2);
            // Reward for % distance up to 125 / strainTime for overlaps where velocity is still changing.
            const overlapVelocityBuff = Math.min(125 / Math.min(current.strainTime, last.strainTime), Math.abs(prevVelocity - currentVelocity));
            velocityChangeBonus = overlapVelocityBuff * distanceRatio;
            // Penalize for rhythm changes.
            velocityChangeBonus *= Math.pow(Math.min(current.strainTime, last.strainTime) /
                Math.max(current.strainTime, last.strainTime), 2);
        }
        if (last.object instanceof osuBase.Slider) {
            // Reward sliders based on velocity.
            sliderBonus = last.travelDistance / last.travelTime;
        }
        strain += wiggleBonus * this.wiggleMultiplier;
        // Add in acute angle bonus or wide angle bonus + velocity change bonus, whichever is larger.
        strain += Math.max(acuteAngleBonus * this.acuteAngleMultiplier, wideAngleBonus * this.wideAngleMultiplier +
            velocityChangeBonus * this.velocityChangeMultiplier);
        // Add in additional slider velocity bonus.
        if (withSliders) {
            strain +=
                Math.pow(1 + sliderBonus * this.sliderMultiplier, 1.25) - 1;
        }
        return strain;
    }
    /**
     * Calculates the flow aim strain of a hitobject.
     */
    static flowAimStrainOf(current) {
        var _a, _b;
        let speedBonus = 1;
        if (current.strainTime < this.minSpeedBonus) {
            speedBonus +=
                0.75 *
                    Math.pow((this.minSpeedBonus - current.strainTime) / 40, 2);
        }
        const travelDistance = (_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.travelDistance) !== null && _b !== void 0 ? _b : 0;
        const shortDistancePenalty = Math.pow(Math.min(this.singleSpacingThreshold, travelDistance + current.minimumJumpDistance) / this.singleSpacingThreshold, 3.5);
        return (200 * speedBonus * shortDistancePenalty) / current.strainTime;
    }
    static calculateWideAngleBonus(angle) {
        return osuBase.MathUtils.smoothstep(angle, osuBase.MathUtils.degreesToRadians(40), osuBase.MathUtils.degreesToRadians(140));
    }
    static calculateAcuteAngleBonus(angle) {
        return osuBase.MathUtils.smoothstep(angle, osuBase.MathUtils.degreesToRadians(140), osuBase.MathUtils.degreesToRadians(40));
    }
}
DroidAimEvaluator.wideAngleMultiplier = 1.5;
DroidAimEvaluator.acuteAngleMultiplier = 2.6;
DroidAimEvaluator.sliderMultiplier = 1.35;
DroidAimEvaluator.velocityChangeMultiplier = 0.75;
DroidAimEvaluator.wiggleMultiplier = 1.02;
DroidAimEvaluator.singleSpacingThreshold = 100;
// 200 1/4 BPM delta time
DroidAimEvaluator.minSpeedBonus = 75;

/**
 * A bare minimal abstract skill for fully custom skill implementations.
 *
 * This class should be considered a "processing" class and not persisted.
 */
class Skill {
    constructor(mods) {
        this.mods = mods;
    }
}

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
class StrainSkill extends Skill {
    constructor() {
        super(...arguments);
        /**
         * Strain peaks are stored here.
         */
        this.strainPeaks = [];
        this._objectStrains = [];
        this.difficulty = 0;
        this.sectionLength = 400;
        this.currentStrain = 0;
        this.currentSectionPeak = 0;
        this.currentSectionEnd = 0;
    }
    /**
     * The strains of hitobjects.
     */
    get objectStrains() {
        return this._objectStrains;
    }
    process(current) {
        // The first object doesn't generate a strain, so we begin with an incremented section end
        if (current.index === 0) {
            this.currentSectionEnd = this.calculateCurrentSectionStart(current);
        }
        while (current.startTime > this.currentSectionEnd) {
            this.saveCurrentPeak();
            this.startNewSectionFrom(this.currentSectionEnd, current);
            this.currentSectionEnd += this.sectionLength;
        }
        // Ignore the first hitobject.
        this.currentStrain = this.strainValueAt(current);
        this.saveToHitObject(current);
        this.currentSectionPeak = Math.max(this.currentStrain, this.currentSectionPeak);
        if (!current.next(0)) {
            // Don't forget to save the last strain peak, which would otherwise be ignored.
            this.saveCurrentPeak();
        }
    }
    /**
     * Saves the current peak strain level to the list of strain peaks, which will be used to calculate an overall difficulty.
     */
    saveCurrentPeak() {
        this.strainPeaks.push(this.currentSectionPeak);
    }
    /**
     * Returns the number of strains weighed against the top strain.
     *
     * The result is scaled by clock rate as it affects the total number of strains.
     */
    countDifficultStrains() {
        if (this.difficulty === 0) {
            return 0;
        }
        // This is what the top strain is if all strain values were identical.
        const consistentTopStrain = this.difficulty / 10;
        // Use a weighted sum of all strains.
        return this._objectStrains.reduce((total, next) => total +
            1.1 / (1 + Math.exp(-10 * (next / consistentTopStrain - 0.88))), 0);
    }
    /**
     * Calculates strain decay for a specified time frame.
     *
     * @param ms The time frame to calculate.
     */
    strainDecay(ms) {
        return Math.pow(this.strainDecayBase, ms / 1000);
    }
    /**
     * Calculates the starting time of a strain section at an object.
     *
     * @param current The object at which the strain section starts.
     * @returns The start time of the strain section.
     */
    calculateCurrentSectionStart(current) {
        return (Math.ceil(current.startTime / this.sectionLength) *
            this.sectionLength);
    }
    /**
     * Sets the initial strain level for a new section.
     *
     * @param time The beginning of the new section in milliseconds.
     * @param current The current hitobject.
     */
    startNewSectionFrom(time, current) {
        // The maximum strain of the new section is not zero by default.
        // This means we need to capture the strain level at the beginning of the new section, and use that as the initial peak level.
        this.currentSectionPeak = this.calculateInitialStrain(time, current);
    }
}

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
class DroidSkill extends StrainSkill {
    process(current) {
        if (current.index < 0) {
            return;
        }
        super.process(current);
        this._objectStrains.push(this.getObjectStrain(current));
    }
    difficultyValue() {
        const strains = this.strainPeaks.slice();
        if (this.reducedSectionCount > 0) {
            strains.sort((a, b) => b - a);
            // We are reducing the highest strains first to account for extreme difficulty spikes.
            for (let i = 0; i < Math.min(strains.length, this.reducedSectionCount); ++i) {
                const scale = Math.log10(osuBase.Interpolation.lerp(1, 10, osuBase.MathUtils.clamp(i / this.reducedSectionCount, 0, 1)));
                strains[i] *= osuBase.Interpolation.lerp(this.reducedSectionBaseline, 1, scale);
            }
        }
        // Math here preserves the property that two notes of equal difficulty x, we have their summed difficulty = x * starsPerDouble.
        // This also applies to two sets of notes with equal difficulty.
        this.difficulty = 0;
        for (const strain of strains) {
            this.difficulty += Math.pow(strain, 1 / Math.log2(this.starsPerDouble));
        }
        this.difficulty = Math.pow(this.difficulty, Math.log2(this.starsPerDouble));
        return this.difficulty;
    }
    calculateCurrentSectionStart(current) {
        return current.startTime;
    }
}

/**
 * Represents the skill required to correctly aim at every object in the map with a uniform CircleSize and normalized distances.
 */
class DroidAim extends DroidSkill {
    constructor(mods, withSliders) {
        super(mods);
        this.strainDecayBase = 0.15;
        this.reducedSectionCount = 10;
        this.reducedSectionBaseline = 0.75;
        this.starsPerDouble = 1.05;
        this.skillMultiplier = 25.6;
        this.currentAimStrain = 0;
        this.sliderStrains = [];
        this.withSliders = withSliders;
    }
    /**
     * Obtains the amount of sliders that are considered difficult in terms of relative strain.
     */
    countDifficultSliders() {
        if (this.sliderStrains.length === 0) {
            return 0;
        }
        const maxSliderStrain = osuBase.MathUtils.max(this.sliderStrains);
        if (maxSliderStrain === 0) {
            return 0;
        }
        return this.sliderStrains.reduce((total, strain) => total +
            1 / (1 + Math.exp(-((strain / maxSliderStrain) * 12 - 6))), 0);
    }
    strainValueAt(current) {
        this.currentAimStrain *= this.strainDecay(current.deltaTime);
        this.currentAimStrain +=
            DroidAimEvaluator.evaluateDifficultyOf(current, this.withSliders) *
                this.skillMultiplier;
        if (current.object instanceof osuBase.Slider) {
            this.sliderStrains.push(this.currentAimStrain);
        }
        return this.currentAimStrain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentAimStrain *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    getObjectStrain() {
        return this.currentAimStrain;
    }
    /**
     * @param current The hitobject to save to.
     */
    saveToHitObject(current) {
        if (this.withSliders) {
            current.aimStrainWithSliders = this.currentAimStrain;
        }
        else {
            current.aimStrainWithoutSliders = this.currentAimStrain;
        }
    }
}

/**
 * Holds data that can be used to calculate osu!droid performance points.
 */
class DroidDifficultyAttributes extends DifficultyAttributes {
    constructor(cacheableAttributes) {
        super(cacheableAttributes);
        this.tapDifficulty = 0;
        this.rhythmDifficulty = 0;
        this.visualDifficulty = 0;
        this.tapDifficultStrainCount = 0;
        this.flashlightDifficultStrainCount = 0;
        this.visualDifficultStrainCount = 0;
        this.averageSpeedDeltaTime = 0;
        this.vibroFactor = 1;
        if (!cacheableAttributes) {
            return;
        }
        this.tapDifficulty = cacheableAttributes.tapDifficulty;
        this.rhythmDifficulty = cacheableAttributes.rhythmDifficulty;
        this.visualDifficulty = cacheableAttributes.visualDifficulty;
        this.tapDifficultStrainCount =
            cacheableAttributes.tapDifficultStrainCount;
        this.flashlightDifficultStrainCount =
            cacheableAttributes.flashlightDifficultStrainCount;
        this.visualDifficultStrainCount =
            cacheableAttributes.visualDifficultStrainCount;
        this.averageSpeedDeltaTime = cacheableAttributes.averageSpeedDeltaTime;
        this.vibroFactor = cacheableAttributes.vibroFactor;
    }
    toString() {
        return (super.toString() +
            ` (${this.aimDifficulty.toFixed(2)} aim, ` +
            `${this.tapDifficulty.toFixed(2)} tap, ` +
            `${this.rhythmDifficulty.toFixed(2)} rhythm, ` +
            `${this.flashlightDifficulty.toFixed(2)} flashlight, ` +
            `${this.visualDifficulty.toFixed(2)} visual)`);
    }
}

/**
 * An evaluator for calculating osu!droid Flashlight skill.
 */
class DroidFlashlightEvaluator {
    /**
     * Evaluates the difficulty of memorizing and hitting the current object, based on:
     *
     * - distance between a number of previous objects and the current object,
     * - the visual opacity of the current object,
     * - the angle made by the current object,
     * - length and speed of the current object (for sliders),
     * - and whether Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current, mods, withSliders) {
        if (current.object instanceof osuBase.Spinner ||
            // Exclude overlapping objects that can be tapped at once.
            current.isOverlapping(true)) {
            return 0;
        }
        const scalingFactor = 52 / current.object.radius;
        let smallDistNerf = 1;
        let cumulativeStrainTime = 0;
        let result = 0;
        let last = current;
        let angleRepeatCount = 0;
        for (let i = 0; i < Math.min(current.index, 10); ++i) {
            const currentObject = current.previous(i);
            cumulativeStrainTime += last.strainTime;
            if (!(currentObject.object instanceof osuBase.Spinner) &&
                // Exclude overlapping objects that can be tapped at once.
                !currentObject.isOverlapping(false)) {
                const jumpDistance = current.object
                    .getStackedPosition(osuBase.Modes.droid)
                    .subtract(currentObject.object.getStackedEndPosition(osuBase.Modes.droid)).length;
                // We want to nerf objects that can be easily seen within the Flashlight circle radius.
                if (i === 0) {
                    smallDistNerf = Math.min(1, jumpDistance / 75);
                }
                // We also want to nerf stacks so that only the first object of the stack is accounted for.
                const stackNerf = Math.min(1, currentObject.lazyJumpDistance / scalingFactor / 25);
                // Bonus based on how visible the object is.
                const opacityBonus = 1 +
                    this.maxOpacityBonus *
                        (1 -
                            current.opacityAt(currentObject.object.startTime, mods));
                result +=
                    (stackNerf * opacityBonus * scalingFactor * jumpDistance) /
                        cumulativeStrainTime;
                if (currentObject.angle !== null && current.angle !== null) {
                    // Objects further back in time should count less for the nerf.
                    if (Math.abs(currentObject.angle - current.angle) < 0.02) {
                        angleRepeatCount += Math.max(0, 1 - 0.1 * i);
                    }
                }
            }
            last = currentObject;
        }
        result = Math.pow(smallDistNerf * result, 2);
        // Additional bonus for Hidden due to there being no approach circles.
        if (mods.has(osuBase.ModHidden)) {
            result *= 1 + this.hiddenBonus;
        }
        else if (mods.has(osuBase.ModTraceable)) {
            // Additional bonus for Traceable due to there being no primary or secondary object pieces.
            if (current.object instanceof osuBase.Circle) {
                // Additional bonus for hit circles due to there being no circle piece, which is the primary piece.
                result *= 1 + this.traceableCircleBonus;
            }
            else {
                // The rest of the objects only hide secondary pieces.
                result *= 1 + this.traceableObjectBonus;
            }
        }
        // Nerf patterns with repeated angles.
        result *=
            this.minAngleMultiplier +
                (1 - this.minAngleMultiplier) / (angleRepeatCount + 1);
        let sliderBonus = 0;
        if (current.object instanceof osuBase.Slider && withSliders) {
            // Invert the scaling factor to determine the true travel distance independent of circle size.
            const pixelTravelDistance = current.object.lazyTravelDistance / scalingFactor;
            // Reward sliders based on velocity.
            sliderBonus = Math.pow(Math.max(0, pixelTravelDistance / current.travelTime - this.minVelocity), 0.5);
            // Longer sliders require more memorization.
            sliderBonus *= pixelTravelDistance;
            // Nerf sliders with repeats, as less memorization is required.
            if (current.object.repeatCount > 0)
                sliderBonus /= current.object.repeatCount + 1;
        }
        result += sliderBonus * this.sliderMultiplier;
        return result;
    }
}
DroidFlashlightEvaluator.maxOpacityBonus = 0.4;
DroidFlashlightEvaluator.hiddenBonus = 0.2;
DroidFlashlightEvaluator.traceableCircleBonus = 0.15;
DroidFlashlightEvaluator.traceableObjectBonus = 0.1;
DroidFlashlightEvaluator.minVelocity = 0.5;
DroidFlashlightEvaluator.sliderMultiplier = 1.3;
DroidFlashlightEvaluator.minAngleMultiplier = 0.2;

/**
 * Represents the skill required to memorize and hit every object in a beatmap with the Flashlight mod enabled.
 */
class DroidFlashlight extends DroidSkill {
    constructor(mods, withSliders) {
        super(mods);
        this.strainDecayBase = 0.15;
        this.reducedSectionCount = 0;
        this.reducedSectionBaseline = 1;
        this.starsPerDouble = 1.06;
        this.skillMultiplier = 0.02;
        this.currentFlashlightStrain = 0;
        this.withSliders = withSliders;
    }
    strainValueAt(current) {
        this.currentFlashlightStrain *= this.strainDecay(current.deltaTime);
        this.currentFlashlightStrain +=
            DroidFlashlightEvaluator.evaluateDifficultyOf(current, this.mods, this.withSliders) * this.skillMultiplier;
        return this.currentFlashlightStrain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentFlashlightStrain *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    getObjectStrain() {
        return this.currentFlashlightStrain;
    }
    saveToHitObject(current) {
        if (this.withSliders) {
            current.flashlightStrainWithSliders = this.currentFlashlightStrain;
        }
        else {
            current.flashlightStrainWithoutSliders =
                this.currentFlashlightStrain;
        }
    }
    difficultyValue() {
        return (this.strainPeaks.reduce((a, v) => a + v, 0) * this.starsPerDouble);
    }
}

class Island {
    constructor(delta, deltaDifferenceEpsilon) {
        this.delta = Number.MAX_SAFE_INTEGER;
        this.deltaCount = 0;
        if (deltaDifferenceEpsilon === undefined) {
            this.deltaDifferenceEpsilon = delta;
        }
        else {
            this.deltaDifferenceEpsilon = deltaDifferenceEpsilon;
            this.addDelta(delta);
        }
    }
    addDelta(delta) {
        if (this.delta === Number.MAX_SAFE_INTEGER) {
            this.delta = Math.max(Math.trunc(delta), DifficultyHitObject.minDeltaTime);
        }
        ++this.deltaCount;
    }
    isSimilarPolarity(other) {
        // TODO: consider islands to be of similar polarity only if they're having the same average delta (we don't want to consider 3 singletaps similar to a triple)
        // naively adding delta check here breaks _a lot_ of maps because of the flawed ratio calculation
        return this.deltaCount % 2 == other.deltaCount % 2;
    }
    equals(other) {
        return (Math.abs(this.delta - other.delta) < this.deltaDifferenceEpsilon &&
            this.deltaCount === other.deltaCount);
    }
}

/**
 * An evaluator for calculating osu!droid Rhythm skill.
 */
class DroidRhythmEvaluator {
    /**
     * Calculates a rhythm multiplier for the difficulty of the tap associated
     * with historic data of the current object.
     *
     * @param current The current object.
     * @param useSliderAccuracy Whether to use slider accuracy.
     */
    static evaluateDifficultyOf(current, useSliderAccuracy) {
        if (current.object instanceof osuBase.Spinner) {
            return 1;
        }
        const deltaDifferenceEpsilon = current.fullGreatWindow * 0.3;
        let rhythmComplexitySum = 0;
        let island = new Island(deltaDifferenceEpsilon);
        let previousIsland = new Island(deltaDifferenceEpsilon);
        const islandCounts = new Map();
        // Store the ratio of the current start of an island to buff for tighter rhythms.
        let startRatio = 0;
        let firstDeltaSwitch = false;
        let rhythmStart = 0;
        const historicalNoteCount = Math.min(current.index, this.historyObjectsMax);
        // Exclude overlapping objects that can be tapped at once.
        const validPrevious = [];
        for (let i = 0; i < historicalNoteCount; ++i) {
            const object = current.previous(i);
            if (!object) {
                break;
            }
            if (!object.isOverlapping(false)) {
                validPrevious.push(object);
            }
        }
        while (rhythmStart < validPrevious.length - 2 &&
            current.startTime - validPrevious[rhythmStart].startTime <
                this.historyTimeMax) {
            ++rhythmStart;
        }
        for (let i = rhythmStart; i > 0; --i) {
            const currentObject = validPrevious[i - 1];
            const prevObject = validPrevious[i];
            const lastObject = validPrevious[i + 1];
            // Scale note 0 to 1 from history to now.
            const timeDecay = (this.historyTimeMax -
                (current.startTime - currentObject.startTime)) /
                this.historyTimeMax;
            const noteDecay = (validPrevious.length - i) / validPrevious.length;
            // Either we're limited by time or limited by object count.
            const currentHistoricalDecay = Math.min(timeDecay, noteDecay);
            const currentDelta = currentObject.strainTime;
            const prevDelta = prevObject.strainTime;
            const lastDelta = lastObject.strainTime;
            // Calculate how much current delta difference deserves a rhythm bonus
            // This function is meant to reduce rhythm bonus for deltas that are multiples of each other (i.e. 100 and 200)
            const deltaDifferenceRatio = Math.min(prevDelta, currentDelta) /
                Math.max(prevDelta, currentDelta);
            const currentRatio = 1 +
                this.rhythmRatioMultiplier *
                    Math.min(0.5, Math.pow(Math.sin(Math.PI / deltaDifferenceRatio), 2));
            // Reduce ratio bonus if delta difference is too big
            const fraction = Math.max(prevDelta / currentDelta, currentDelta / prevDelta);
            const fractionMultiplier = osuBase.MathUtils.clamp(2 - fraction / 8, 0, 1);
            const windowPenalty = Math.min(1, Math.max(0, Math.abs(prevDelta - currentDelta) - deltaDifferenceEpsilon) / deltaDifferenceEpsilon);
            let effectiveRatio = windowPenalty * currentRatio * fractionMultiplier;
            if (firstDeltaSwitch) {
                if (Math.abs(prevDelta - currentDelta) < deltaDifferenceEpsilon) {
                    // Island is still progressing, count size.
                    island.addDelta(currentDelta);
                }
                else {
                    if (!useSliderAccuracy) {
                        // BPM change is into slider, this is easy acc window.
                        if (currentObject.object instanceof osuBase.Slider) {
                            effectiveRatio /= 8;
                        }
                        // BPM change was from a slider, this is easier typically than circle -> circle.
                        // Unintentional side effect is that bursts with kicksliders at the ends might have lower difficulty
                        // than bursts without sliders.
                        if (prevObject.object instanceof osuBase.Slider) {
                            effectiveRatio *= 0.3;
                        }
                    }
                    // Repeated island polarity (2 -> 4, 3 -> 5).
                    if (island.isSimilarPolarity(previousIsland)) {
                        effectiveRatio /= 2;
                    }
                    // Previous increase happened a note ago.
                    // Albeit this is a 1/1 -> 1/2-1/4 type of transition, we don't want to buff this.
                    if (lastDelta > prevDelta + deltaDifferenceEpsilon &&
                        prevDelta > currentDelta + deltaDifferenceEpsilon) {
                        effectiveRatio /= 8;
                    }
                    // Repeated island size (ex: triplet -> triplet).
                    // TODO: remove this nerf since its staying here only for balancing purposes because of the flawed ratio calculation
                    if (previousIsland.deltaCount == island.deltaCount) {
                        effectiveRatio /= 2;
                    }
                    let islandFound = false;
                    for (const [currentIsland, count] of islandCounts) {
                        if (!island.equals(currentIsland)) {
                            continue;
                        }
                        islandFound = true;
                        let islandCount = count;
                        if (previousIsland.equals(island)) {
                            // Only add island to island counts if they're going one after another.
                            ++islandCount;
                            islandCounts.set(currentIsland, islandCount);
                        }
                        // Repeated island (ex: triplet -> triplet).
                        // Graph: https://www.desmos.com/calculator/pj7an56zwf
                        effectiveRatio *= Math.min(3 / islandCount, Math.pow(1 / islandCount, osuBase.MathUtils.offsetLogistic(island.delta, 58.33, 0.24, 2.75)));
                        break;
                    }
                    if (!islandFound) {
                        islandCounts.set(island, 1);
                    }
                    // Scale down the difficulty if the object is doubletappable.
                    effectiveRatio *= 1 - prevObject.doubletapness * 0.75;
                    rhythmComplexitySum +=
                        Math.sqrt(effectiveRatio * startRatio) *
                            currentHistoricalDecay;
                    startRatio = effectiveRatio;
                    previousIsland = island;
                    if (prevDelta + deltaDifferenceEpsilon < currentDelta) {
                        // We're slowing down, stop counting.
                        // If we're speeding up, this stays as is and we keep counting island size.
                        firstDeltaSwitch = false;
                    }
                    island = new Island(currentDelta, deltaDifferenceEpsilon);
                }
            }
            else if (prevDelta > currentDelta + deltaDifferenceEpsilon) {
                // We are speeding up.
                // Begin counting island until we change speed again.
                firstDeltaSwitch = true;
                // BPM change is into slider, this is easy acc window.
                if (currentObject.object instanceof osuBase.Slider) {
                    effectiveRatio *= 0.6;
                }
                // BPM change was from a slider, this is easier typically than circle -> circle
                // Unintentional side effect is that bursts with kicksliders at the ends might have lower difficulty
                // than bursts without sliders
                if (prevObject.object instanceof osuBase.Slider) {
                    effectiveRatio *= 0.6;
                }
                startRatio = effectiveRatio;
                island = new Island(currentDelta, deltaDifferenceEpsilon);
            }
        }
        return (Math.sqrt(4 + rhythmComplexitySum * this.rhythmOverallMultiplier) /
            2);
    }
}
DroidRhythmEvaluator.historyTimeMax = 5000; // 5 seconds of calculateRhythmBonus max.
DroidRhythmEvaluator.historyObjectsMax = 32;
DroidRhythmEvaluator.rhythmOverallMultiplier = 0.95;
DroidRhythmEvaluator.rhythmRatioMultiplier = 12;

/**
 * Represents the skill required to properly follow a beatmap's rhythm.
 */
class DroidRhythm extends DroidSkill {
    constructor(mods) {
        super(mods);
        this.reducedSectionCount = 5;
        this.reducedSectionBaseline = 0.75;
        this.strainDecayBase = 0.3;
        this.starsPerDouble = 1.75;
        this.currentRhythmStrain = 0;
        this.currentRhythmMultiplier = 1;
        this.useSliderAccuracy = mods.has(osuBase.ModScoreV2);
    }
    strainValueAt(current) {
        this.currentRhythmMultiplier =
            DroidRhythmEvaluator.evaluateDifficultyOf(current, this.useSliderAccuracy);
        this.currentRhythmStrain *= this.strainDecay(current.deltaTime);
        this.currentRhythmStrain += this.currentRhythmMultiplier - 1;
        return this.currentRhythmStrain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentRhythmStrain *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    getObjectStrain() {
        return this.currentRhythmStrain;
    }
    saveToHitObject(current) {
        current.rhythmStrain = this.currentRhythmStrain;
        current.rhythmMultiplier = this.currentRhythmMultiplier;
    }
}

/**
 * An evaluator for calculating osu!droid tap skill.
 */
class DroidTapEvaluator {
    /**
     * Evaluates the difficulty of tapping the current object, based on:
     *
     * - time between pressing the previous and current object,
     * - distance between those objects,
     * - how easily they can be cheesed,
     * - and the strain time cap.
     *
     * @param current The current object.
     * @param greatWindow The great hit window of the current object.
     * @param considerCheesability Whether to consider cheesability.
     * @param strainTimeCap The strain time to cap the object's strain time to.
     */
    static evaluateDifficultyOf(current, considerCheesability, strainTimeCap) {
        if (current.object instanceof osuBase.Spinner ||
            // Exclude overlapping objects that can be tapped at once.
            current.isOverlapping(false)) {
            return 0;
        }
        // Nerf doubletappable doubles.
        const doubletapness = considerCheesability
            ? 1 - current.doubletapness
            : 1;
        const strainTime = strainTimeCap !== undefined
            ? // We cap the strain time to 50 here as the chance of vibro is higher in any BPM higher than 300.
                Math.max(50, strainTimeCap, current.strainTime)
            : current.strainTime;
        let speedBonus = 1;
        if (strainTime < this.minSpeedBonus) {
            speedBonus +=
                0.75 *
                    Math.pow(osuBase.ErrorFunction.erf((this.minSpeedBonus - strainTime) / 40), 2);
        }
        return (speedBonus * Math.pow(doubletapness, 1.5) * 1000) / strainTime;
    }
}
// ~200 1/4 BPM streams
DroidTapEvaluator.minSpeedBonus = 75;

/**
 * Represents the skill required to press keys or tap with regards to keeping up with the speed at which objects need to be hit.
 */
class DroidTap extends DroidSkill {
    /**
     * The delta time of hitobjects.
     */
    get objectDeltaTimes() {
        return this._objectDeltaTimes;
    }
    constructor(mods, considerCheesability, strainTimeCap) {
        super(mods);
        this.reducedSectionCount = 10;
        this.reducedSectionBaseline = 0.75;
        this.strainDecayBase = 0.3;
        this.starsPerDouble = 1.1;
        this.currentTapStrain = 0;
        this.currentRhythmMultiplier = 0;
        this.skillMultiplier = 1.375;
        this._objectDeltaTimes = [];
        this.considerCheesability = considerCheesability;
        this.strainTimeCap = strainTimeCap;
    }
    /**
     * The amount of notes that are relevant to the difficulty.
     */
    relevantNoteCount() {
        if (this._objectStrains.length === 0) {
            return 0;
        }
        const maxStrain = osuBase.MathUtils.max(this._objectStrains);
        if (maxStrain === 0) {
            return 0;
        }
        return this._objectStrains.reduce((total, next) => total + 1 / (1 + Math.exp(-((next / maxStrain) * 12 - 6))), 0);
    }
    /**
     * The delta time relevant to the difficulty.
     */
    relevantDeltaTime() {
        if (this._objectStrains.length === 0) {
            return 0;
        }
        const maxStrain = osuBase.MathUtils.max(this._objectStrains);
        if (maxStrain === 0) {
            return 0;
        }
        return (this._objectDeltaTimes.reduce((total, next, index) => total +
            (next * 1) /
                (1 +
                    Math.exp(-((this._objectStrains[index] / maxStrain) *
                        25 -
                        20))), 0) /
            this._objectStrains.reduce((total, next) => total + 1 / (1 + Math.exp(-((next / maxStrain) * 25 - 20))), 0));
    }
    strainValueAt(current) {
        this.currentTapStrain *= this.strainDecay(current.strainTime);
        this.currentTapStrain +=
            DroidTapEvaluator.evaluateDifficultyOf(current, this.considerCheesability, this.strainTimeCap) * this.skillMultiplier;
        this.currentRhythmMultiplier = current.rhythmMultiplier;
        this._objectDeltaTimes.push(current.deltaTime);
        return this.currentTapStrain * current.rhythmMultiplier;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentTapStrain *
            this.currentRhythmMultiplier *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    getObjectStrain() {
        return this.currentTapStrain * this.currentRhythmMultiplier;
    }
    /**
     * @param current The hitobject to save to.
     */
    saveToHitObject(current) {
        if (this.strainTimeCap !== undefined) {
            return;
        }
        const strain = this.currentTapStrain * this.currentRhythmMultiplier;
        if (this.considerCheesability) {
            current.tapStrain = strain;
        }
        else {
            current.originalTapStrain = strain;
        }
    }
}

/**
 * An evaluator for calculating osu!droid visual skill.
 */
class DroidVisualEvaluator {
    /**
     * Evaluates the difficulty of reading the current object, based on:
     *
     * - note density of the current object,
     * - overlapping factor of the current object,
     * - the preempt time of the current object,
     * - the visual opacity of the current object,
     * - the velocity of the current object if it's a slider,
     * - past objects' velocity if they are sliders,
     * - and whether the Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current, mods, withSliders) {
        if (current.object instanceof osuBase.Spinner ||
            // Exclude overlapping objects that can be tapped at once.
            current.isOverlapping(true) ||
            current.index === 0) {
            return 0;
        }
        // Start with base density and give global bonus for Hidden and Traceable.
        // Add density caps for sanity.
        let strain;
        if (mods.has(osuBase.ModHidden)) {
            strain = Math.min(30, Math.pow(current.noteDensity, 3));
        }
        else if (mods.has(osuBase.ModTraceable)) {
            // Give more bonus for hit circles due to there being no circle piece.
            if (current.object instanceof osuBase.Circle) {
                strain = Math.min(25, Math.pow(current.noteDensity, 2.5));
            }
            else {
                strain = Math.min(22.5, Math.pow(current.noteDensity, 2.25));
            }
        }
        else {
            strain = Math.min(20, Math.pow(current.noteDensity, 2));
        }
        // Bonus based on how visible the object is.
        for (let i = 0; i < Math.min(current.index, 10); ++i) {
            const previous = current.previous(i);
            if (previous.object instanceof osuBase.Spinner ||
                // Exclude overlapping objects that can be tapped at once.
                previous.isOverlapping(true)) {
                continue;
            }
            // Do not consider objects that don't fall under time preempt.
            if (current.object.startTime - previous.object.endTime >
                current.object.timePreempt) {
                break;
            }
            strain +=
                (1 - current.opacityAt(previous.object.startTime, mods)) / 4;
        }
        if (current.timePreempt < 400) {
            // Give bonus for AR higher than 10.33.
            strain += Math.pow(400 - current.timePreempt, 1.35) / 100;
        }
        // Scale the value with overlapping factor.
        strain /= 10 * (1 + current.overlappingFactor);
        if (current.object instanceof osuBase.Slider && withSliders) {
            const scalingFactor = 50 / current.object.radius;
            // Invert the scaling factor to determine the true travel distance independent of circle size.
            const pixelTravelDistance = current.object.lazyTravelDistance / scalingFactor;
            const currentVelocity = pixelTravelDistance / current.travelTime;
            const spanTravelDistance = pixelTravelDistance / current.object.spanCount;
            strain +=
                // Reward sliders based on velocity, while also avoiding overbuffing extremely fast sliders.
                Math.min(6, currentVelocity * 1.5) *
                    // Longer sliders require more reading.
                    (spanTravelDistance / 100);
            let cumulativeStrainTime = 0;
            // Reward for velocity changes based on last few sliders.
            for (let i = 0; i < Math.min(current.index, 4); ++i) {
                const last = current.previous(i);
                cumulativeStrainTime += last.strainTime;
                if (!(last.object instanceof osuBase.Slider) ||
                    // Exclude overlapping objects that can be tapped at once.
                    last.isOverlapping(true)) {
                    continue;
                }
                // Invert the scaling factor to determine the true travel distance independent of circle size.
                const lastPixelTravelDistance = last.object.lazyTravelDistance / scalingFactor;
                const lastVelocity = lastPixelTravelDistance / last.travelTime;
                const lastSpanTravelDistance = lastPixelTravelDistance / last.object.spanCount;
                strain +=
                    // Reward past sliders based on velocity changes, while also
                    // avoiding overbuffing extremely fast velocity changes.
                    Math.min(10, 2.5 * Math.abs(currentVelocity - lastVelocity)) *
                        // Longer sliders require more reading.
                        (lastSpanTravelDistance / 125) *
                        // Avoid overbuffing past sliders.
                        Math.min(1, 300 / cumulativeStrainTime);
            }
        }
        return strain;
    }
}

/**
 * Represents the skill required to read every object in the map.
 */
class DroidVisual extends DroidSkill {
    constructor(mods, withSliders) {
        super(mods);
        this.starsPerDouble = 1.025;
        this.reducedSectionCount = 10;
        this.reducedSectionBaseline = 0.75;
        this.strainDecayBase = 0.1;
        this.currentVisualStrain = 0;
        this.currentRhythmMultiplier = 1;
        this.skillMultiplier = 10;
        this.withSliders = withSliders;
    }
    strainValueAt(current) {
        this.currentVisualStrain *= this.strainDecay(current.deltaTime);
        this.currentVisualStrain +=
            DroidVisualEvaluator.evaluateDifficultyOf(current, this.mods, this.withSliders) * this.skillMultiplier;
        this.currentRhythmMultiplier = current.rhythmMultiplier;
        return this.currentVisualStrain * this.currentRhythmMultiplier;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentVisualStrain *
            this.currentRhythmMultiplier *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    getObjectStrain() {
        return this.currentVisualStrain * this.currentRhythmMultiplier;
    }
    saveToHitObject(current) {
        const strain = this.currentVisualStrain * this.currentRhythmMultiplier;
        if (this.withSliders) {
            current.visualStrainWithSliders = strain;
        }
        else {
            current.visualStrainWithoutSliders = strain;
        }
    }
}

/**
 * Holds data that can be used to calculate osu!droid performance points as well
 * as doing some analysis using the replay of a score.
 */
class ExtendedDroidDifficultyAttributes extends DroidDifficultyAttributes {
    constructor(cacheableAttributes) {
        super(cacheableAttributes);
        this.mode = "live";
        this.possibleThreeFingeredSections = [];
        this.difficultSliders = [];
        this.aimNoteCount = 0;
        this.flashlightSliderFactor = 1;
        this.visualSliderFactor = 1;
        if (!cacheableAttributes) {
            return;
        }
        this.possibleThreeFingeredSections =
            cacheableAttributes.possibleThreeFingeredSections;
        this.difficultSliders = cacheableAttributes.difficultSliders;
        this.aimNoteCount = cacheableAttributes.aimNoteCount;
        this.flashlightSliderFactor =
            cacheableAttributes.flashlightSliderFactor;
        this.visualSliderFactor = cacheableAttributes.visualSliderFactor;
    }
}

/**
 * A difficulty calculator for osu!droid gamemode.
 */
class DroidDifficultyCalculator extends DifficultyCalculator {
    constructor() {
        super();
        this.difficultyMultiplier = 0.18;
        this.difficultyAdjustmentMods
            .add(osuBase.ModPrecise)
            .add(osuBase.ModScoreV2)
            .add(osuBase.ModTraceable);
    }
    retainDifficultyAdjustmentMods(mods) {
        return mods.filter((mod) => mod.isApplicableToDroid() &&
            this.difficultyAdjustmentMods.has(mod.constructor) &&
            mod.isDroidRelevant);
    }
    createDifficultyAttributes(beatmap, skills, objects) {
        const attributes = new ExtendedDroidDifficultyAttributes();
        attributes.mods = beatmap.mods;
        attributes.maxCombo = beatmap.maxCombo;
        attributes.clockRate = beatmap.speedMultiplier;
        attributes.hitCircleCount = beatmap.hitObjects.circles;
        attributes.sliderCount = beatmap.hitObjects.sliders;
        attributes.spinnerCount = beatmap.hitObjects.spinners;
        this.populateAimAttributes(attributes, skills, objects);
        this.populateTapAttributes(attributes, skills, objects);
        this.populateRhythmAttributes(attributes, skills);
        this.populateFlashlightAttributes(attributes, skills);
        this.populateVisualAttributes(attributes, skills);
        if (beatmap.mods.has(osuBase.ModRelax)) {
            attributes.aimDifficulty *= 0.9;
            attributes.tapDifficulty = 0;
            attributes.rhythmDifficulty = 0;
            attributes.flashlightDifficulty *= 0.7;
            attributes.visualDifficulty = 0;
        }
        else if (beatmap.mods.has(osuBase.ModAutopilot)) {
            attributes.aimDifficulty = 0;
            attributes.flashlightDifficulty *= 0.3;
            attributes.visualDifficulty *= 0.8;
        }
        const aimPerformanceValue = this.basePerformanceValue(Math.pow(attributes.aimDifficulty, 0.8));
        const tapPerformanceValue = this.basePerformanceValue(attributes.tapDifficulty);
        const flashlightPerformanceValue = Math.pow(attributes.flashlightDifficulty, 1.6) * 25;
        const visualPerformanceValue = Math.pow(attributes.visualDifficulty, 1.6) * 22.5;
        const basePerformanceValue = Math.pow(Math.pow(aimPerformanceValue, 1.1) +
            Math.pow(tapPerformanceValue, 1.1) +
            Math.pow(flashlightPerformanceValue, 1.1) +
            Math.pow(visualPerformanceValue, 1.1), 1 / 1.1);
        if (basePerformanceValue > 1e-5) {
            // Document for formula derivation:
            // https://docs.google.com/document/d/10DZGYYSsT_yjz2Mtp6yIJld0Rqx4E-vVHupCqiM4TNI/edit
            attributes.starRating =
                0.027 *
                    (Math.cbrt((100000 / Math.pow(2, 1 / 1.1)) * basePerformanceValue) +
                        4);
        }
        else {
            attributes.starRating = 0;
        }
        let greatWindow;
        if (attributes.mods.has(osuBase.ModPrecise)) {
            greatWindow = new osuBase.PreciseDroidHitWindow(beatmap.difficulty.od)
                .greatWindow;
        }
        else {
            greatWindow = new osuBase.DroidHitWindow(beatmap.difficulty.od).greatWindow;
        }
        attributes.overallDifficulty = osuBase.OsuHitWindow.greatWindowToOD(greatWindow / attributes.clockRate);
        return attributes;
    }
    createPlayableBeatmap(beatmap, mods) {
        return beatmap.createDroidPlayableBeatmap(mods);
    }
    createDifficultyHitObjects(beatmap) {
        var _a, _b;
        const clockRate = beatmap.speedMultiplier;
        const difficultyObjects = [];
        const { objects } = beatmap.hitObjects;
        for (let i = 0; i < objects.length; ++i) {
            const difficultyObject = new DroidDifficultyHitObject(objects[i], (_a = objects[i - 1]) !== null && _a !== void 0 ? _a : null, (_b = objects[i - 2]) !== null && _b !== void 0 ? _b : null, difficultyObjects, clockRate, i - 1);
            difficultyObject.computeProperties(clockRate, objects);
            difficultyObjects.push(difficultyObject);
        }
        return difficultyObjects;
    }
    createSkills(beatmap) {
        const { mods } = beatmap;
        const skills = [];
        if (!mods.has(osuBase.ModAutopilot)) {
            skills.push(new DroidAim(mods, true));
            skills.push(new DroidAim(mods, false));
        }
        if (!mods.has(osuBase.ModRelax)) {
            // Tap and visual skills depend on rhythm skill, so we put it first
            skills.push(new DroidRhythm(mods));
            skills.push(new DroidTap(mods, true));
            skills.push(new DroidTap(mods, false));
            skills.push(new DroidVisual(mods, true));
            skills.push(new DroidVisual(mods, false));
        }
        if (mods.has(osuBase.ModFlashlight)) {
            skills.push(new DroidFlashlight(mods, true));
            skills.push(new DroidFlashlight(mods, false));
        }
        return skills;
    }
    createStrainPeakSkills(beatmap) {
        const { mods } = beatmap;
        return [
            new DroidAim(mods, true),
            new DroidAim(mods, false),
            new DroidTap(mods, true),
            new DroidFlashlight(mods, true),
        ];
    }
    populateAimAttributes(attributes, skills, objects) {
        const aim = skills.find((s) => s instanceof DroidAim && s.withSliders);
        const aimNoSlider = skills.find((s) => s instanceof DroidAim && !s.withSliders);
        if (!aim || !aimNoSlider) {
            return;
        }
        attributes.aimDifficulty = this.calculateRating(aim);
        attributes.aimDifficultSliderCount = aim.countDifficultSliders();
        attributes.aimDifficultStrainCount = aim.countDifficultStrains();
        const topDifficultSliders = [];
        for (let i = 0; i < objects.length; ++i) {
            const object = objects[i];
            const velocity = object.travelDistance / object.travelTime;
            if (velocity > 0) {
                topDifficultSliders.push({
                    index: i,
                    velocity: velocity,
                });
            }
        }
        const velocitySum = topDifficultSliders.reduce((a, v) => a + v.velocity, 0);
        for (const slider of topDifficultSliders) {
            const difficultyRating = slider.velocity / velocitySum;
            // Only consider sliders that are fast enough.
            if (difficultyRating > 0.02) {
                attributes.difficultSliders.push({
                    index: slider.index,
                    difficultyRating: slider.velocity / velocitySum,
                });
            }
        }
        attributes.difficultSliders.sort((a, b) => b.difficultyRating - a.difficultyRating);
        // Take the top 15% most difficult sliders.
        while (attributes.difficultSliders.length >
            Math.ceil(0.15 * attributes.sliderCount)) {
            attributes.difficultSliders.pop();
        }
        if (attributes.aimDifficulty > 0) {
            attributes.sliderFactor =
                this.calculateRating(aimNoSlider) / attributes.aimDifficulty;
        }
        else {
            attributes.sliderFactor = 1;
        }
    }
    populateTapAttributes(attributes, skills, objects) {
        const tap = skills.find((s) => s instanceof DroidTap && s.considerCheesability);
        if (!tap) {
            return;
        }
        attributes.tapDifficulty = this.calculateRating(tap);
        attributes.tapDifficultStrainCount = tap.countDifficultStrains();
        attributes.speedNoteCount = tap.relevantNoteCount();
        attributes.averageSpeedDeltaTime = tap.relevantDeltaTime();
        if (attributes.tapDifficulty > 0) {
            const tapVibro = new DroidTap(attributes.mods, true, attributes.averageSpeedDeltaTime);
            for (const object of objects) {
                tapVibro.process(object);
            }
            attributes.vibroFactor =
                this.calculateRating(tapVibro) / attributes.tapDifficulty;
        }
        const { threeFingerStrainThreshold } = DroidDifficultyCalculator;
        const minSectionObjectCount = 5;
        let inSpeedSection = false;
        let firstSpeedObjectIndex = 0;
        for (let i = 2; i < objects.length; ++i) {
            const current = objects[i];
            const prev = objects[i - 1];
            if (!inSpeedSection &&
                current.originalTapStrain >= threeFingerStrainThreshold) {
                inSpeedSection = true;
                firstSpeedObjectIndex = i;
                continue;
            }
            const currentDelta = current.deltaTime;
            const prevDelta = prev.deltaTime;
            const deltaRatio = Math.min(prevDelta, currentDelta) /
                Math.max(prevDelta, currentDelta);
            if (inSpeedSection &&
                (current.originalTapStrain < threeFingerStrainThreshold ||
                    // Stop speed section on slowing down 1/2 rhythm change or anything slower.
                    (prevDelta < currentDelta && deltaRatio <= 0.5) ||
                    // Don't forget to manually add the last section, which would otherwise be ignored.
                    i === objects.length - 1)) {
                const lastSpeedObjectIndex = i - (i === objects.length - 1 ? 0 : 1);
                inSpeedSection = false;
                // Ignore sections that don't meet object count requirement.
                if (i - firstSpeedObjectIndex < minSectionObjectCount) {
                    continue;
                }
                attributes.possibleThreeFingeredSections.push({
                    firstObjectIndex: firstSpeedObjectIndex,
                    lastObjectIndex: lastSpeedObjectIndex,
                    sumStrain: Math.pow(objects
                        .slice(firstSpeedObjectIndex, lastSpeedObjectIndex + 1)
                        .reduce((a, v) => a +
                        v.originalTapStrain /
                            threeFingerStrainThreshold, 0), 0.75),
                });
            }
        }
    }
    populateRhythmAttributes(attributes, skills) {
        const rhythm = skills.find((s) => s instanceof DroidRhythm);
        if (!rhythm) {
            return;
        }
        attributes.rhythmDifficulty = this.calculateRating(rhythm);
    }
    populateFlashlightAttributes(attributes, skills) {
        const flashlight = skills.find((s) => s instanceof DroidFlashlight && s.withSliders);
        const flashlightNoSliders = skills.find((s) => s instanceof DroidFlashlight && !s.withSliders);
        if (!flashlight || !flashlightNoSliders) {
            return;
        }
        attributes.flashlightDifficulty = this.calculateRating(flashlight);
        attributes.flashlightDifficultStrainCount =
            flashlight.countDifficultStrains();
        if (attributes.flashlightDifficulty > 0) {
            attributes.flashlightSliderFactor =
                this.calculateRating(flashlightNoSliders) /
                    attributes.flashlightDifficulty;
        }
        else {
            attributes.flashlightSliderFactor = 1;
        }
    }
    populateVisualAttributes(attributes, skills) {
        const visual = skills.find((s) => s instanceof DroidVisual && s.withSliders);
        const visualNoSliders = skills.find((s) => s instanceof DroidVisual && !s.withSliders);
        if (!visual || !visualNoSliders) {
            return;
        }
        attributes.visualDifficulty = this.calculateRating(visual);
        attributes.visualDifficultStrainCount = visual.countDifficultStrains();
        if (attributes.visualDifficulty > 0) {
            attributes.visualSliderFactor =
                this.calculateRating(visualNoSliders) /
                    attributes.visualDifficulty;
        }
        else {
            attributes.visualSliderFactor = 1;
        }
    }
}
/**
 * The strain threshold to start detecting for possible three-fingered section.
 *
 * Increasing this number will result in less sections being flagged.
 */
DroidDifficultyCalculator.threeFingerStrainThreshold = 175;

/**
 * The base class of performance calculators.
 */
class PerformanceCalculator {
    /**
     * @param difficultyAttributes The difficulty attributes to calculate.
     */
    constructor(difficultyAttributes) {
        /**
         * The overall performance value.
         */
        this.total = 0;
        /**
         * The calculated accuracy.
         */
        this.computedAccuracy = new osuBase.Accuracy({});
        /**
         * The amount of misses that are filtered out from sliderbreaks.
         */
        this.effectiveMissCount = 0;
        /**
         * Nerf factor used for nerfing beatmaps with very likely dropped sliderends.
         */
        this.sliderNerfFactor = 1;
        this.difficultyAttributes = difficultyAttributes;
        this.mods = this.isCacheableAttribute(difficultyAttributes)
            ? osuBase.ModUtil.deserializeMods(difficultyAttributes.mods)
            : difficultyAttributes.mods;
    }
    /**
     * Calculates the performance points of the beatmap.
     *
     * @param options Options for performance calculation.
     * @returns The current instance.
     */
    calculate(options) {
        this.handleOptions(options);
        this.calculateValues();
        this.total = this.calculateTotalValue();
        return this;
    }
    /**
     * The total hits that can be done in the beatmap.
     */
    get totalHits() {
        return (this.difficultyAttributes.hitCircleCount +
            this.difficultyAttributes.sliderCount +
            this.difficultyAttributes.spinnerCount);
    }
    /**
     * The total hits that were successfully done.
     */
    get totalSuccessfulHits() {
        return (this.computedAccuracy.n300 +
            this.computedAccuracy.n100 +
            this.computedAccuracy.n50);
    }
    /**
     * The total of imperfect hits (100s, 50s, misses).
     */
    get totalImperfectHits() {
        return (this.computedAccuracy.n100 +
            this.computedAccuracy.n50 +
            this.computedAccuracy.nmiss);
    }
    /**
     * Calculates the base performance value of a star rating.
     */
    baseValue(stars) {
        return Math.pow(5 * Math.max(1, stars / 0.0675) - 4, 3) / 100000;
    }
    /**
     * Processes given options for usage in performance calculation.
     *
     * @param options Options for performance calculation.
     */
    handleOptions(options) {
        var _a;
        const maxCombo = this.difficultyAttributes.maxCombo;
        const miss = this.computedAccuracy.nmiss;
        const combo = (_a = options === null || options === void 0 ? void 0 : options.combo) !== null && _a !== void 0 ? _a : maxCombo - miss;
        if ((options === null || options === void 0 ? void 0 : options.accPercent) instanceof osuBase.Accuracy) {
            // Copy into new instance to not modify the original
            this.computedAccuracy = new osuBase.Accuracy(options.accPercent);
            if (this.computedAccuracy.n300 <= 0) {
                this.computedAccuracy.n300 = Math.max(0, this.totalHits -
                    this.computedAccuracy.n100 -
                    this.computedAccuracy.n50 -
                    this.computedAccuracy.nmiss);
            }
            else {
                this.computedAccuracy.nmiss = Math.max(0, this.totalHits - this.totalSuccessfulHits);
            }
        }
        else {
            this.computedAccuracy = new osuBase.Accuracy({
                percent: options === null || options === void 0 ? void 0 : options.accPercent,
                nobjects: this.totalHits,
                nmiss: (options === null || options === void 0 ? void 0 : options.miss) || 0,
            });
        }
        this.effectiveMissCount = this.calculateEffectiveMissCount(combo, maxCombo);
        if (this.mods.has(osuBase.ModNoFail)) {
            this.finalMultiplier *= Math.max(0.9, 1 - 0.02 * this.effectiveMissCount);
        }
        if (this.mods.has(osuBase.ModSpunOut)) {
            this.finalMultiplier *=
                1 -
                    Math.pow(this.difficultyAttributes.spinnerCount / this.totalHits, 0.85);
        }
        if (this.mods.has(osuBase.ModRelax)) {
            // Graph: https://www.desmos.com/calculator/bc9eybdthb
            // We use OD13.3 as maximum since it's the value at which great hit window becomes 0.
            const n100Multiplier = Math.max(0, this.difficultyAttributes.overallDifficulty > 0
                ? 1 -
                    Math.pow(this.difficultyAttributes.overallDifficulty /
                        13.33, 1.8)
                : 1);
            const n50Multiplier = Math.max(0, this.difficultyAttributes.overallDifficulty > 0
                ? 1 -
                    Math.pow(this.difficultyAttributes.overallDifficulty /
                        13.33, 5)
                : 1);
            // As we're adding 100s and 50s to an approximated number of combo breaks, the result can be higher
            // than total hits in specific scenarios (which breaks some calculations),  so we need to clamp it.
            this.effectiveMissCount = Math.min(this.effectiveMissCount +
                this.computedAccuracy.n100 * n100Multiplier +
                this.computedAccuracy.n50 * n50Multiplier, this.totalHits);
        }
        if (this.difficultyAttributes.sliderCount > 0) {
            // We assume 15% of sliders in a beatmap are difficult since there's no way to tell from the performance calculator.
            const estimateDifficultSliders = this.difficultyAttributes.sliderCount * 0.15;
            const estimateSliderEndsDropped = osuBase.MathUtils.clamp(Math.min(this.computedAccuracy.n100 +
                this.computedAccuracy.n50 +
                this.computedAccuracy.nmiss, maxCombo - combo), 0, estimateDifficultSliders);
            this.sliderNerfFactor =
                (1 - this.difficultyAttributes.sliderFactor) *
                    Math.pow(1 -
                        estimateSliderEndsDropped /
                            estimateDifficultSliders, 3) +
                    this.difficultyAttributes.sliderFactor;
        }
    }
    /**
     * Calculates a strain-based miss penalty.
     *
     * Strain-based miss penalty assumes that a player will miss on the hardest parts of a map,
     * so we use the amount of relatively difficult sections to adjust miss penalty
     * to make it more punishing on maps with lower amount of hard sections.
     */
    calculateStrainBasedMissPenalty(difficultStrainCount) {
        if (this.effectiveMissCount === 0) {
            return 1;
        }
        return (0.96 /
            (this.effectiveMissCount /
                (4 * Math.pow(Math.log(difficultStrainCount), 0.94)) +
                1));
    }
    /**
     * Calculates the amount of misses + sliderbreaks from combo.
     */
    calculateEffectiveMissCount(combo, maxCombo) {
        // Guess the number of misses + slider breaks from combo.
        let comboBasedMissCount = 0;
        if (this.difficultyAttributes.sliderCount > 0) {
            const fullComboThreshold = maxCombo - 0.1 * this.difficultyAttributes.sliderCount;
            if (combo < fullComboThreshold) {
                // Clamp miss count to maximum amount of possible breaks.
                comboBasedMissCount = Math.min(fullComboThreshold / Math.max(1, combo), this.computedAccuracy.n100 +
                    this.computedAccuracy.n50 +
                    this.computedAccuracy.nmiss);
            }
        }
        return Math.max(this.computedAccuracy.nmiss, comboBasedMissCount);
    }
    /**
     * Determines whether an attribute is a cacheable attribute.
     *
     * @param attributes The attributes to check.
     * @returns Whether the attributes are cacheable.
     */
    isCacheableAttribute(attributes) {
        return Array.isArray(attributes.mods);
    }
}

/**
 * A performance points calculator that calculates performance points for osu!droid gamemode.
 */
class DroidPerformanceCalculator extends PerformanceCalculator {
    constructor() {
        super(...arguments);
        /**
         * The aim performance value.
         */
        this.aim = 0;
        /**
         * The tap performance value.
         */
        this.tap = 0;
        /**
         * The accuracy performance value.
         */
        this.accuracy = 0;
        /**
         * The flashlight performance value.
         */
        this.flashlight = 0;
        /**
         * The visual performance value.
         */
        this.visual = 0;
        this.finalMultiplier = 1.24;
        this.mode = osuBase.Modes.droid;
        this._aimSliderCheesePenalty = 1;
        this._flashlightSliderCheesePenalty = 1;
        this._visualSliderCheesePenalty = 1;
        this._tapPenalty = 1;
        this._deviation = 0;
        this._tapDeviation = 0;
    }
    /**
     * The penalty used to penalize the tap performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get tapPenalty() {
        return this._tapPenalty;
    }
    /**
     * The estimated deviation of the score.
     */
    get deviation() {
        return this._deviation;
    }
    /**
     * The estimated tap deviation of the score.
     */
    get tapDeviation() {
        return this._tapDeviation;
    }
    /**
     * The penalty used to penalize the aim performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get aimSliderCheesePenalty() {
        return this._aimSliderCheesePenalty;
    }
    /**
     * The penalty used to penalize the flashlight performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get flashlightSliderCheesePenalty() {
        return this._flashlightSliderCheesePenalty;
    }
    /**
     * The penalty used to penalize the visual performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get visualSliderCheesePenalty() {
        return this._visualSliderCheesePenalty;
    }
    /**
     * Applies a tap penalty value to this calculator.
     *
     * The tap and total performance value will be recalculated afterwards.
     *
     * @param value The tap penalty value. Must be greater than or equal to 1.
     */
    applyTapPenalty(value) {
        if (value < 1) {
            throw new RangeError("New tap penalty must be greater than or equal to one.");
        }
        if (value === this._tapPenalty) {
            return;
        }
        this._tapPenalty = value;
        this.tap = this.calculateTapValue();
        this.total = this.calculateTotalValue();
    }
    /**
     * Applies an aim slider cheese penalty value to this calculator.
     *
     * The aim and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between than 0 and 1.
     */
    applyAimSliderCheesePenalty(value) {
        if (value < 0) {
            throw new RangeError("New aim slider cheese penalty must be greater than or equal to zero.");
        }
        if (value > 1) {
            throw new RangeError("New aim slider cheese penalty must be less than or equal to one.");
        }
        if (value === this._aimSliderCheesePenalty) {
            return;
        }
        this._aimSliderCheesePenalty = value;
        this.aim = this.calculateAimValue();
        this.total = this.calculateTotalValue();
    }
    /**
     * Applies a flashlight slider cheese penalty value to this calculator.
     *
     * The flashlight and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between 0 and 1.
     */
    applyFlashlightSliderCheesePenalty(value) {
        if (value < 0) {
            throw new RangeError("New flashlight slider cheese penalty must be greater than or equal to zero.");
        }
        if (value > 1) {
            throw new RangeError("New flashlight slider cheese penalty must be less than or equal to one.");
        }
        if (value === this._flashlightSliderCheesePenalty) {
            return;
        }
        this._flashlightSliderCheesePenalty = value;
        this.flashlight = this.calculateFlashlightValue();
        this.total = this.calculateTotalValue();
    }
    /**
     * Applies a visual slider cheese penalty value to this calculator.
     *
     * The visual and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between 0 and 1.
     */
    applyVisualSliderCheesePenalty(value) {
        if (value < 0) {
            throw new RangeError("New visual slider cheese penalty must be greater than or equal to zero.");
        }
        if (value > 1) {
            throw new RangeError("New visual slider cheese penalty must be less than or equal to one.");
        }
        if (value === this._visualSliderCheesePenalty) {
            return;
        }
        this._visualSliderCheesePenalty = value;
        this.visual = this.calculateVisualValue();
        this.total = this.calculateTotalValue();
    }
    calculateValues() {
        this._deviation = this.calculateDeviation();
        this._tapDeviation = this.calculateTapDeviation();
        this.aim = this.calculateAimValue();
        this.tap = this.calculateTapValue();
        this.accuracy = this.calculateAccuracyValue();
        this.flashlight = this.calculateFlashlightValue();
        this.visual = this.calculateVisualValue();
    }
    calculateTotalValue() {
        return (Math.pow(Math.pow(this.aim, 1.1) +
            Math.pow(this.tap, 1.1) +
            Math.pow(this.accuracy, 1.1) +
            Math.pow(this.flashlight, 1.1) +
            Math.pow(this.visual, 1.1), 1 / 1.1) * this.finalMultiplier);
    }
    handleOptions(options) {
        var _a, _b, _c, _d, _e;
        this._tapPenalty = (_a = options === null || options === void 0 ? void 0 : options.tapPenalty) !== null && _a !== void 0 ? _a : 1;
        this._aimSliderCheesePenalty = (_b = options === null || options === void 0 ? void 0 : options.aimSliderCheesePenalty) !== null && _b !== void 0 ? _b : 1;
        this._flashlightSliderCheesePenalty =
            (_c = options === null || options === void 0 ? void 0 : options.flashlightSliderCheesePenalty) !== null && _c !== void 0 ? _c : 1;
        this._visualSliderCheesePenalty =
            (_d = options === null || options === void 0 ? void 0 : options.visualSliderCheesePenalty) !== null && _d !== void 0 ? _d : 1;
        super.handleOptions(options);
        const { maxCombo, aimDifficultSliderCount, sliderFactor } = this.difficultyAttributes;
        const combo = (_e = options === null || options === void 0 ? void 0 : options.combo) !== null && _e !== void 0 ? _e : maxCombo - this.computedAccuracy.nmiss;
        if (aimDifficultSliderCount > 0) {
            // Consider all missing combo to be dropped difficult sliders.
            const estimateImproperlyFollowedDifficultSliders = osuBase.MathUtils.clamp(Math.min(this.totalImperfectHits, maxCombo - combo), 0, aimDifficultSliderCount);
            this.sliderNerfFactor =
                (1 - sliderFactor) *
                    Math.pow(1 -
                        estimateImproperlyFollowedDifficultSliders /
                            aimDifficultSliderCount, 3) +
                    sliderFactor;
        }
    }
    /**
     * Calculates the aim performance value of the beatmap.
     */
    calculateAimValue() {
        let aimValue = this.baseValue(Math.pow(this.difficultyAttributes.aimDifficulty, 0.8));
        aimValue *= Math.min(this.calculateStrainBasedMissPenalty(this.difficultyAttributes.aimDifficultStrainCount), this.proportionalMissPenalty);
        // Scale the aim value with estimated full combo deviation.
        aimValue *= this.calculateDeviationBasedLengthScaling();
        // Scale the aim value with slider factor to nerf very likely dropped sliderends.
        aimValue *= this.sliderNerfFactor;
        // Scale the aim value with slider cheese penalty.
        aimValue *= this._aimSliderCheesePenalty;
        // Scale the aim value with deviation.
        aimValue *=
            1.025 *
                Math.pow(osuBase.ErrorFunction.erf(25 / (Math.SQRT2 * this._deviation)), 0.475);
        // OD 7 SS stays the same.
        aimValue *= 0.98 + Math.pow(7, 2) / 2500;
        return aimValue;
    }
    /**
     * Calculates the tap performance value of the beatmap.
     */
    calculateTapValue() {
        let tapValue = this.baseValue(this.difficultyAttributes.tapDifficulty);
        tapValue *= this.calculateStrainBasedMissPenalty(this.difficultyAttributes.tapDifficultStrainCount);
        // Scale the tap value with estimated full combo deviation.
        // Consider notes that are difficult to tap with respect to other notes, but
        // also cap the note count to prevent buffing filler patterns.
        tapValue *= this.calculateDeviationBasedLengthScaling(Math.min(this.difficultyAttributes.speedNoteCount, this.totalHits / 1.45));
        // Normalize the deviation to 300 BPM.
        const normalizedDeviation = this.tapDeviation *
            Math.max(1, 50 / this.difficultyAttributes.averageSpeedDeltaTime);
        // We expect the player to get 7500/x deviation when doubletapping x BPM.
        // Using this expectation, we penalize scores with deviation above 25.
        const averageBPM = 60000 / 4 / this.difficultyAttributes.averageSpeedDeltaTime;
        const adjustedDeviation = normalizedDeviation *
            (1 +
                1 /
                    (1 +
                        Math.exp(-(normalizedDeviation - 7500 / averageBPM) /
                            ((2 * 300) / averageBPM))));
        // Scale the tap value with tap deviation.
        tapValue *=
            1.05 *
                Math.pow(osuBase.ErrorFunction.erf(20 / (Math.SQRT2 * adjustedDeviation)), 0.6);
        // Additional scaling for tap value based on average BPM and how "vibroable" the beatmap is.
        // Higher BPMs require more precise tapping. When the deviation is too high,
        // it can be assumed that the player taps invariant to rhythm.
        // We harshen the punishment for such scenario.
        tapValue *=
            (1 - Math.pow(this.difficultyAttributes.vibroFactor, 6)) /
                (1 +
                    Math.exp((this._tapDeviation - 7500 / averageBPM) /
                        ((2 * 300) / averageBPM))) +
                Math.pow(this.difficultyAttributes.vibroFactor, 6);
        // Scale the tap value with three-fingered penalty.
        tapValue /= this._tapPenalty;
        // OD 8 SS stays the same.
        tapValue *= 0.95 + Math.pow(8, 2) / 750;
        return tapValue;
    }
    /**
     * Calculates the accuracy performance value of the beatmap.
     */
    calculateAccuracyValue() {
        if (this.mods.has(osuBase.ModRelax) || this.totalSuccessfulHits === 0) {
            return 0;
        }
        let accuracyValue = 650 * Math.exp(-0.1 * this._deviation);
        const ncircles = this.mods.has(osuBase.ModScoreV2)
            ? this.totalHits - this.difficultyAttributes.spinnerCount
            : this.difficultyAttributes.hitCircleCount;
        // Bonus for many hitcircles - it's harder to keep good accuracy up for longer.
        accuracyValue *= Math.min(1.15, Math.sqrt(Math.log(1 + ((Math.E - 1) * ncircles) / 1000)));
        // Scale the accuracy value with rhythm complexity.
        accuracyValue *=
            1.5 /
                (1 +
                    Math.exp(-(this.difficultyAttributes.rhythmDifficulty - 1) / 2));
        // Penalize accuracy pp after the first miss.
        accuracyValue *= Math.pow(0.97, Math.max(0, this.effectiveMissCount - 1));
        if (this.mods.has(osuBase.ModFlashlight)) {
            accuracyValue *= 1.02;
        }
        return accuracyValue;
    }
    /**
     * Calculates the flashlight performance value of the beatmap.
     */
    calculateFlashlightValue() {
        if (!this.mods.has(osuBase.ModFlashlight)) {
            return 0;
        }
        let flashlightValue = Math.pow(this.difficultyAttributes.flashlightDifficulty, 1.6) * 25;
        flashlightValue *= Math.min(this.calculateStrainBasedMissPenalty(this.difficultyAttributes.flashlightDifficultStrainCount), this.proportionalMissPenalty);
        // Account for shorter maps having a higher ratio of 0 combo/100 combo flashlight radius.
        flashlightValue *=
            0.7 +
                0.1 * Math.min(1, this.totalHits / 200) +
                (this.totalHits > 200
                    ? 0.2 * Math.min(1, (this.totalHits - 200) / 200)
                    : 0);
        // Scale the flashlight value with slider cheese penalty.
        flashlightValue *= this._flashlightSliderCheesePenalty;
        // Scale the flashlight value with deviation.
        flashlightValue *= osuBase.ErrorFunction.erf(50 / (Math.SQRT2 * this._deviation));
        return flashlightValue;
    }
    /**
     * Calculates the visual performance value of the beatmap.
     */
    calculateVisualValue() {
        let visualValue = Math.pow(this.difficultyAttributes.visualDifficulty, 1.6) * 22.5;
        visualValue *= Math.min(this.calculateStrainBasedMissPenalty(this.difficultyAttributes.visualDifficultStrainCount), this.proportionalMissPenalty);
        // Scale the visual value with estimated full combo deviation.
        // As visual is easily "bypassable" with memorization, punish for memorization.
        visualValue *= this.calculateDeviationBasedLengthScaling(undefined, true);
        // Scale the visual value with slider cheese penalty.
        visualValue *= this._visualSliderCheesePenalty;
        // Scale the visual value with deviation.
        visualValue *=
            1.05 *
                Math.pow(osuBase.ErrorFunction.erf(25 / (Math.SQRT2 * this._deviation)), 0.775);
        // OD 5 SS stays the same.
        visualValue *= 0.98 + Math.pow(5, 2) / 2500;
        return visualValue;
    }
    /**
     * The object-based proportional miss penalty.
     */
    get proportionalMissPenalty() {
        if (this.effectiveMissCount === 0) {
            return 1;
        }
        const missProportion = (this.totalHits - this.effectiveMissCount) / (this.totalHits + 1);
        const noMissProportion = this.totalHits / (this.totalHits + 1);
        return (
        // Aim deviation-based scale.
        (osuBase.ErrorFunction.erfInv(missProportion) /
            osuBase.ErrorFunction.erfInv(noMissProportion)) *
            // Cheesing-based scale (i.e. 50% misses is deliberately only hitting each other
            // note, 90% misses is deliberately only hitting 1 note every 10 notes).
            Math.pow(missProportion, 8));
    }
    /**
     * Calculates the object-based length scaling based on the deviation of a player for a full
     * combo in this beatmap, taking retries into account.
     *
     * @param objectCount The amount of objects to be considered. Defaults to the amount of
     * objects in this beatmap.
     * @param punishForMemorization Whether to punish the deviation for memorization. Defaults to `false`.
     */
    calculateDeviationBasedLengthScaling(objectCount = this.totalHits, punishForMemorization = false) {
        // Assume a sample proportion of hits for a full combo to be `(n - 0.5) / n` due to
        // continuity correction, where `n` is the object count.
        const calculateProportion = (notes) => (notes - 0.5) / notes;
        // Keeping `x` notes as the benchmark, assume that a player will retry a beatmap
        // `max(1, x/n)` times relative to an `x`-note beatmap.
        const benchmarkNotes = 700;
        // Calculate the proportion equivalent to the bottom half of retry count percentile of
        // scores and take it as the player's "real" proportion.
        const retryProportion = (proportion, notes, tries) => proportion +
            Math.sqrt((2 * proportion * (1 - proportion)) / notes) *
                osuBase.ErrorFunction.erfInv(1 / tries - 1);
        // Using the proportion, we calculate the deviation based off that proportion and again
        // compared to the hit deviation for proportion `(n - 0.5) / n`.
        let multiplier = Math.max(0, osuBase.ErrorFunction.erfInv(retryProportion(calculateProportion(objectCount), objectCount, Math.max(1, benchmarkNotes / objectCount))) / osuBase.ErrorFunction.erfInv(calculateProportion(benchmarkNotes)) || 0);
        // Punish for memorization if needed.
        if (punishForMemorization) {
            multiplier *= Math.min(1, Math.sqrt(objectCount / benchmarkNotes));
        }
        return multiplier;
    }
    /**
     * Estimates the player's tap deviation based on the OD, number of circles and sliders,
     * and number of 300s, 100s, 50s, and misses, assuming the player's mean hit error is 0.
     *
     * The estimation is consistent in that two SS scores on the same map
     * with the same settings will always return the same deviation.
     *
     * Sliders are treated as circles with a 50 hit window.
     *
     * Misses are ignored because they are usually due to misaiming, and 50s
     * are grouped with 100s since they are usually due to misreading.
     *
     * Inaccuracies are capped to the number of circles in the map.
     */
    calculateDeviation() {
        if (this.totalSuccessfulHits === 0) {
            return Number.POSITIVE_INFINITY;
        }
        const { clockRate } = this.difficultyAttributes;
        const hitWindow = this.getConvertedHitWindow();
        const hitWindow300 = hitWindow.greatWindow / clockRate;
        const hitWindow100 = hitWindow.okWindow / clockRate;
        const hitWindow50 = hitWindow.mehWindow / clockRate;
        const { n100, n50, nmiss } = this.computedAccuracy;
        const circleCount = this.difficultyAttributes.hitCircleCount;
        const missCountCircles = Math.min(nmiss, circleCount);
        const mehCountCircles = Math.min(n50, circleCount - missCountCircles);
        const okCountCircles = Math.min(n100, circleCount - missCountCircles - mehCountCircles);
        const greatCountCircles = Math.max(0, circleCount - missCountCircles - mehCountCircles - okCountCircles);
        // Assume 100s, 50s, and misses happen on circles. If there are less non-300s on circles than 300s,
        // compute the deviation on circles.
        if (greatCountCircles > 0) {
            // The probability that a player hits a circle is unknown, but we can estimate it to be
            // the number of greats on circles divided by the number of circles, and then add one
            // to the number of circles as a bias correction.
            const greatProbabilityCircle = greatCountCircles /
                (circleCount - missCountCircles - mehCountCircles + 1);
            // Compute the deviation assuming 300s and 100s are normally distributed, and 50s are uniformly distributed.
            // Begin with the normal distribution first.
            let deviationOnCircles = hitWindow300 /
                (Math.SQRT2 * osuBase.ErrorFunction.erfInv(greatProbabilityCircle));
            deviationOnCircles *= Math.sqrt(1 -
                (Math.sqrt(2 / Math.PI) *
                    hitWindow100 *
                    Math.exp(-0.5 *
                        Math.pow(hitWindow100 / deviationOnCircles, 2))) /
                    (deviationOnCircles *
                        osuBase.ErrorFunction.erf(hitWindow100 /
                            (Math.SQRT2 * deviationOnCircles))));
            // Then compute the variance for 50s.
            const mehVariance = (hitWindow50 * hitWindow50 +
                hitWindow100 * hitWindow50 +
                hitWindow100 * hitWindow100) /
                3;
            // Find the total deviation.
            deviationOnCircles = Math.sqrt(((greatCountCircles + okCountCircles) *
                Math.pow(deviationOnCircles, 2) +
                mehCountCircles * mehVariance) /
                (greatCountCircles + okCountCircles + mehCountCircles));
            return deviationOnCircles;
        }
        // If there are more non-300s than there are circles, compute the deviation on sliders instead.
        // Here, all that matters is whether or not the slider was missed, since it is impossible
        // to get a 100 or 50 on a slider by mis-tapping it.
        const sliderCount = this.difficultyAttributes.sliderCount;
        const missCountSliders = Math.min(sliderCount, nmiss - missCountCircles);
        const greatCountSliders = sliderCount - missCountSliders;
        // We only get here if nothing was hit. In this case, there is no estimate for deviation.
        // Note that this is never negative, so checking if this is only equal to 0 makes sense.
        if (greatCountSliders === 0) {
            return Number.POSITIVE_INFINITY;
        }
        const greatProbabilitySlider = greatCountSliders / (sliderCount + 1);
        return (hitWindow50 /
            (Math.SQRT2 * osuBase.ErrorFunction.erfInv(greatProbabilitySlider)));
    }
    /**
     * Does the same as {@link calculateDeviation}, but only for notes and inaccuracies that are relevant to tap difficulty.
     *
     * Treats all difficult speed notes as circles, so this method can sometimes return a lower deviation than {@link calculateDeviation}.
     * This is fine though, since this method is only used to scale tap pp.
     */
    calculateTapDeviation() {
        if (this.totalSuccessfulHits === 0) {
            return Number.POSITIVE_INFINITY;
        }
        const { speedNoteCount, clockRate } = this.difficultyAttributes;
        const hitWindow = this.getConvertedHitWindow();
        const hitWindow300 = hitWindow.greatWindow / clockRate;
        const hitWindow100 = hitWindow.okWindow / clockRate;
        const hitWindow50 = hitWindow.mehWindow / clockRate;
        const { n100, n50, nmiss } = this.computedAccuracy;
        // Assume a fixed ratio of non-300s hit in speed notes based on speed note count ratio and OD.
        // Graph: https://www.desmos.com/calculator/iskvgjkxr4
        const speedNoteRatio = speedNoteCount / this.totalHits;
        const nonGreatCount = n100 + n50 + nmiss;
        const nonGreatRatio = 1 -
            (Math.pow(Math.exp(Math.sqrt(hitWindow300)) + 1, 1 - speedNoteRatio) -
                1) /
                Math.exp(Math.sqrt(hitWindow300));
        const relevantCountGreat = Math.max(0, speedNoteCount - nonGreatCount * nonGreatRatio);
        const relevantCountOk = n100 * nonGreatRatio;
        const relevantCountMeh = n50 * nonGreatRatio;
        const relevantCountMiss = nmiss * nonGreatRatio;
        // Assume 100s, 50s, and misses happen on circles. If there are less non-300s on circles than 300s,
        // compute the deviation on circles.
        if (relevantCountGreat > 0) {
            // The probability that a player hits a circle is unknown, but we can estimate it to be
            // the number of greats on circles divided by the number of circles, and then add one
            // to the number of circles as a bias correction.
            const greatProbabilityCircle = relevantCountGreat /
                (speedNoteCount - relevantCountMiss - relevantCountMeh + 1);
            // Compute the deviation assuming 300s and 100s are normally distributed, and 50s are uniformly distributed.
            // Begin with the normal distribution first.
            let deviationOnCircles = hitWindow300 /
                (Math.SQRT2 * osuBase.ErrorFunction.erfInv(greatProbabilityCircle));
            deviationOnCircles *= Math.sqrt(1 -
                (Math.sqrt(2 / Math.PI) *
                    hitWindow100 *
                    Math.exp(-0.5 *
                        Math.pow(hitWindow100 / deviationOnCircles, 2))) /
                    (deviationOnCircles *
                        osuBase.ErrorFunction.erf(hitWindow100 /
                            (Math.SQRT2 * deviationOnCircles))));
            // Then compute the variance for 50s.
            const mehVariance = (hitWindow50 * hitWindow50 +
                hitWindow100 * hitWindow50 +
                hitWindow100 * hitWindow100) /
                3;
            // Find the total deviation.
            deviationOnCircles = Math.sqrt(((relevantCountGreat + relevantCountOk) *
                Math.pow(deviationOnCircles, 2) +
                relevantCountMeh * mehVariance) /
                (relevantCountGreat + relevantCountOk + relevantCountMeh));
            return deviationOnCircles;
        }
        return Number.POSITIVE_INFINITY;
    }
    getConvertedHitWindow() {
        const hitWindow300 = new osuBase.OsuHitWindow(this.difficultyAttributes.overallDifficulty).greatWindow;
        if (this.mods.has(osuBase.ModPrecise)) {
            return new osuBase.PreciseDroidHitWindow(osuBase.PreciseDroidHitWindow.greatWindowToOD(hitWindow300 * this.difficultyAttributes.clockRate));
        }
        else {
            return new osuBase.DroidHitWindow(osuBase.DroidHitWindow.greatWindowToOD(hitWindow300 * this.difficultyAttributes.clockRate));
        }
    }
    toString() {
        return (this.total.toFixed(2) +
            " pp (" +
            this.aim.toFixed(2) +
            " aim, " +
            this.tap.toFixed(2) +
            " tap, " +
            this.accuracy.toFixed(2) +
            " acc, " +
            this.flashlight.toFixed(2) +
            " flashlight, " +
            this.visual.toFixed(2) +
            " visual)");
    }
}

/**
 * Represents an osu!standard hit object with difficulty calculation values.
 */
class OsuDifficultyHitObject extends DifficultyHitObject {
    constructor() {
        super(...arguments);
        /**
         * The speed strain generated by the hitobject.
         */
        this.speedStrain = 0;
        /**
         * The flashlight strain generated by this hitobject.
         */
        this.flashlightStrain = 0;
        this.radiusBuffThreshold = 30;
        this.mode = osuBase.Modes.osu;
    }
    get scalingFactor() {
        const radius = this.object.radius;
        // We will scale distances by this factor, so we can assume a uniform CircleSize among beatmaps.
        let scalingFactor = DifficultyHitObject.normalizedRadius / radius;
        // High circle size (small CS) bonus
        if (radius < this.radiusBuffThreshold) {
            scalingFactor *=
                1 + Math.min(this.radiusBuffThreshold - radius, 5) / 50;
        }
        return scalingFactor;
    }
}

/**
 * An evaluator for calculating osu!standard Aim skill.
 */
class OsuAimEvaluator {
    /**
     * Evaluates the difficulty of aiming the current object, based on:
     *
     * - cursor velocity to the current object,
     * - angle difficulty,
     * - sharp velocity increases,
     * - and slider difficulty.
     *
     * @param current The current object.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current, withSliders) {
        const last = current.previous(0);
        if (current.object instanceof osuBase.Spinner ||
            current.index <= 1 ||
            (last === null || last === void 0 ? void 0 : last.object) instanceof osuBase.Spinner) {
            return 0;
        }
        const lastLast = current.previous(1);
        const radius = OsuDifficultyHitObject.normalizedRadius;
        const diameter = OsuDifficultyHitObject.normalizedDiameter;
        // Calculate the velocity to the current hitobject, which starts with a base distance / time assuming the last object is a hitcircle.
        let currentVelocity = current.lazyJumpDistance / current.strainTime;
        // But if the last object is a slider, then we extend the travel velocity through the slider into the current object.
        if (last.object instanceof osuBase.Slider && withSliders) {
            // Calculate the slider velocity from slider head to slider end.
            const travelVelocity = last.travelDistance / last.travelTime;
            // Calculate the movement velocity from slider end to current object.
            const movementVelocity = current.minimumJumpDistance / current.minimumJumpTime;
            // Take the larger total combined velocity.
            currentVelocity = Math.max(currentVelocity, movementVelocity + travelVelocity);
        }
        // As above, do the same for the previous hitobject.
        let prevVelocity = last.lazyJumpDistance / last.strainTime;
        if (lastLast.object instanceof osuBase.Slider && withSliders) {
            const travelVelocity = lastLast.travelDistance / lastLast.travelTime;
            const movementVelocity = last.minimumJumpDistance / last.minimumJumpTime;
            prevVelocity = Math.max(prevVelocity, movementVelocity + travelVelocity);
        }
        let wideAngleBonus = 0;
        let acuteAngleBonus = 0;
        let sliderBonus = 0;
        let velocityChangeBonus = 0;
        let wiggleBonus = 0;
        // Start strain with regular velocity.
        let strain = currentVelocity;
        if (
        // If rhythms are the same.
        Math.max(current.strainTime, last.strainTime) <
            1.25 * Math.min(current.strainTime, last.strainTime) &&
            current.angle !== null &&
            last.angle !== null) {
            const currentAngle = current.angle;
            const lastAngle = last.angle;
            // Rewarding angles, take the smaller velocity as base.
            const angleBonus = Math.min(currentVelocity, prevVelocity);
            wideAngleBonus = this.calculateWideAngleBonus(current.angle);
            acuteAngleBonus = this.calculateAcuteAngleBonus(current.angle);
            // Penalize angle repetition.
            wideAngleBonus *=
                1 -
                    Math.min(wideAngleBonus, Math.pow(this.calculateWideAngleBonus(lastAngle), 3));
            acuteAngleBonus *=
                0.08 +
                    0.92 *
                        (1 -
                            Math.min(acuteAngleBonus, Math.pow(this.calculateAcuteAngleBonus(lastAngle), 3)));
            // Apply full wide angle bonus for distance more than one diameter
            wideAngleBonus *=
                angleBonus *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, 0, diameter);
            // Apply acute angle bonus for BPM above 300 1/2 and distance more than one diameter
            acuteAngleBonus *=
                angleBonus *
                    osuBase.MathUtils.smootherstep(osuBase.MathUtils.millisecondsToBPM(current.strainTime, 2), 300, 400) *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, diameter, diameter * 2);
            // Apply wiggle bonus for jumps that are [radius, 3*diameter] in distance, with < 110 angle
            // https://www.desmos.com/calculator/dp0v0nvowc
            wiggleBonus =
                angleBonus *
                    osuBase.MathUtils.smootherstep(current.lazyJumpDistance, radius, diameter) *
                    Math.pow(osuBase.MathUtils.reverseLerp(current.lazyJumpDistance, diameter * 3, diameter), 1.8) *
                    osuBase.MathUtils.smootherstep(currentAngle, osuBase.MathUtils.degreesToRadians(110), osuBase.MathUtils.degreesToRadians(60)) *
                    osuBase.MathUtils.smootherstep(last.lazyJumpDistance, radius, diameter) *
                    Math.pow(osuBase.MathUtils.reverseLerp(last.lazyJumpDistance, diameter * 3, diameter), 1.8) *
                    osuBase.MathUtils.smootherstep(lastAngle, osuBase.MathUtils.degreesToRadians(110), osuBase.MathUtils.degreesToRadians(60));
        }
        if (Math.max(prevVelocity, currentVelocity)) {
            // We want to use the average velocity over the whole object when awarding differences, not the individual jump and slider path velocities.
            prevVelocity =
                (last.lazyJumpDistance + lastLast.travelDistance) /
                    last.strainTime;
            currentVelocity =
                (current.lazyJumpDistance + last.travelDistance) /
                    current.strainTime;
            // Scale with ratio of difference compared to half the max distance.
            const distanceRatio = Math.pow(Math.sin(((Math.PI / 2) * Math.abs(prevVelocity - currentVelocity)) /
                Math.max(prevVelocity, currentVelocity)), 2);
            // Reward for % distance up to 125 / strainTime for overlaps where velocity is still changing.
            const overlapVelocityBuff = Math.min(125 / Math.min(current.strainTime, last.strainTime), Math.abs(prevVelocity - currentVelocity));
            velocityChangeBonus = overlapVelocityBuff * distanceRatio;
            // Penalize for rhythm changes.
            velocityChangeBonus *= Math.pow(Math.min(current.strainTime, last.strainTime) /
                Math.max(current.strainTime, last.strainTime), 2);
        }
        if (last.travelTime) {
            // Reward sliders based on velocity.
            sliderBonus = last.travelDistance / last.travelTime;
        }
        strain += wiggleBonus * this.wiggleMultiplier;
        // Add in acute angle bonus or wide angle bonus + velocity change bonus, whichever is larger.
        strain += Math.max(acuteAngleBonus * this.acuteAngleMultiplier, wideAngleBonus * this.wideAngleMultiplier +
            velocityChangeBonus * this.velocityChangeMultiplier);
        // Add in additional slider velocity bonus.
        if (withSliders) {
            strain += sliderBonus * this.sliderMultiplier;
        }
        return strain;
    }
    static calculateWideAngleBonus(angle) {
        return osuBase.MathUtils.smoothstep(angle, osuBase.MathUtils.degreesToRadians(40), osuBase.MathUtils.degreesToRadians(140));
    }
    static calculateAcuteAngleBonus(angle) {
        return osuBase.MathUtils.smoothstep(angle, osuBase.MathUtils.degreesToRadians(140), osuBase.MathUtils.degreesToRadians(40));
    }
}
OsuAimEvaluator.wideAngleMultiplier = 1.5;
OsuAimEvaluator.acuteAngleMultiplier = 2.6;
OsuAimEvaluator.sliderMultiplier = 1.35;
OsuAimEvaluator.velocityChangeMultiplier = 0.75;
OsuAimEvaluator.wiggleMultiplier = 1.02;

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
class OsuSkill extends StrainSkill {
    difficultyValue() {
        const strains = this.strainPeaks.slice().sort((a, b) => b - a);
        if (this.reducedSectionCount > 0) {
            // We are reducing the highest strains first to account for extreme difficulty spikes.
            for (let i = 0; i < Math.min(strains.length, this.reducedSectionCount); ++i) {
                const scale = Math.log10(osuBase.Interpolation.lerp(1, 10, osuBase.MathUtils.clamp(i / this.reducedSectionCount, 0, 1)));
                strains[i] *= osuBase.Interpolation.lerp(this.reducedSectionBaseline, 1, scale);
            }
            strains.sort((a, b) => b - a);
        }
        // Difficulty is the weighted sum of the highest strains from every section.
        // We're sorting from highest to lowest strain.
        this.difficulty = 0;
        let weight = 1;
        for (const strain of strains) {
            const addition = strain * weight;
            if (this.difficulty + addition === this.difficulty) {
                break;
            }
            this.difficulty += addition;
            weight *= this.decayWeight;
        }
        return this.difficulty;
    }
}

/**
 * Represents the skill required to correctly aim at every object in the map with a uniform CircleSize and normalized distances.
 */
class OsuAim extends OsuSkill {
    constructor(mods, withSliders) {
        super(mods);
        this.strainDecayBase = 0.15;
        this.reducedSectionCount = 10;
        this.reducedSectionBaseline = 0.75;
        this.decayWeight = 0.9;
        this.currentAimStrain = 0;
        this.skillMultiplier = 25.6;
        this.sliderStrains = [];
        this.withSliders = withSliders;
    }
    /**
     * Obtains the amount of sliders that are considered difficult in terms of relative strain.
     */
    countDifficultSliders() {
        if (this.sliderStrains.length === 0) {
            return 0;
        }
        const maxSliderStrain = osuBase.MathUtils.max(this.sliderStrains);
        if (maxSliderStrain === 0) {
            return 0;
        }
        return this.sliderStrains.reduce((total, strain) => total +
            1 / (1 + Math.exp(-((strain / maxSliderStrain) * 12 - 6))), 0);
    }
    strainValueAt(current) {
        this.currentAimStrain *= this.strainDecay(current.deltaTime);
        this.currentAimStrain +=
            OsuAimEvaluator.evaluateDifficultyOf(current, this.withSliders) *
                this.skillMultiplier;
        this._objectStrains.push(this.currentAimStrain);
        if (current.object instanceof osuBase.Slider) {
            this.sliderStrains.push(this.currentAimStrain);
        }
        return this.currentAimStrain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentAimStrain *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    /**
     * @param current The hitobject to save to.
     */
    saveToHitObject(current) {
        if (this.withSliders) {
            current.aimStrainWithSliders = this.currentAimStrain;
        }
        else {
            current.aimStrainWithoutSliders = this.currentAimStrain;
        }
    }
}

/**
 * Holds data that can be used to calculate osu!standard performance points.
 */
class OsuDifficultyAttributes extends DifficultyAttributes {
    constructor(cacheableAttributes) {
        super(cacheableAttributes);
        this.approachRate = 0;
        this.speedDifficulty = 0;
        this.speedDifficultStrainCount = 0;
        if (!cacheableAttributes) {
            return;
        }
        this.approachRate = cacheableAttributes.approachRate;
        this.speedDifficulty = cacheableAttributes.speedDifficulty;
        this.speedDifficultStrainCount =
            cacheableAttributes.speedDifficultStrainCount;
    }
    toString() {
        return (super.toString() +
            ` (${this.aimDifficulty.toFixed(2)} aim, ` +
            `${this.speedDifficulty.toFixed(2)} speed, ` +
            `${this.flashlightDifficulty.toFixed(2)} flashlight)`);
    }
}

/**
 * An evaluator for calculating osu!standard Flashlight skill.
 */
class OsuFlashlightEvaluator {
    /**
     * Evaluates the difficulty of memorizing and hitting the current object, based on:
     *
     * - distance between a number of previous objects and the current object,
     * - the visual opacity of the current object,
     * - the angle made by the current object,
     * - length and speed of the current object (for sliders),
     * - and whether Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     */
    static evaluateDifficultyOf(current, mods) {
        if (current.object instanceof osuBase.Spinner) {
            return 0;
        }
        const scalingFactor = 52 / current.object.radius;
        let smallDistNerf = 1;
        let cumulativeStrainTime = 0;
        let result = 0;
        let last = current;
        let angleRepeatCount = 0;
        for (let i = 0; i < Math.min(current.index, 10); ++i) {
            const currentObject = current.previous(i);
            cumulativeStrainTime += last.strainTime;
            if (!(currentObject.object instanceof osuBase.Spinner)) {
                const jumpDistance = current.object
                    .getStackedPosition(osuBase.Modes.osu)
                    .subtract(currentObject.object.getStackedEndPosition(osuBase.Modes.osu)).length;
                // We want to nerf objects that can be easily seen within the Flashlight circle radius.
                if (i === 0) {
                    smallDistNerf = Math.min(1, jumpDistance / 75);
                }
                // We also want to nerf stacks so that only the first object of the stack is accounted for.
                const stackNerf = Math.min(1, currentObject.lazyJumpDistance / scalingFactor / 25);
                // Bonus based on how visible the object is.
                const opacityBonus = 1 +
                    this.maxOpacityBonus *
                        (1 -
                            current.opacityAt(currentObject.object.startTime, mods));
                result +=
                    (stackNerf * opacityBonus * scalingFactor * jumpDistance) /
                        cumulativeStrainTime;
                if (currentObject.angle !== null && current.angle !== null) {
                    // Objects further back in time should count less for the nerf.
                    if (Math.abs(currentObject.angle - current.angle) < 0.02) {
                        angleRepeatCount += Math.max(0, 1 - 0.1 * i);
                    }
                }
            }
            last = currentObject;
        }
        result = Math.pow(smallDistNerf * result, 2);
        // Additional bonus for Hidden due to there being no approach circles.
        if (mods.has(osuBase.ModHidden)) {
            result *= 1 + this.hiddenBonus;
        }
        // Nerf patterns with repeated angles.
        result *=
            this.minAngleMultiplier +
                (1 - this.minAngleMultiplier) / (angleRepeatCount + 1);
        let sliderBonus = 0;
        if (current.object instanceof osuBase.Slider) {
            // Invert the scaling factor to determine the true travel distance independent of circle size.
            const pixelTravelDistance = current.object.lazyTravelDistance / scalingFactor;
            // Reward sliders based on velocity.
            sliderBonus = Math.pow(Math.max(0, pixelTravelDistance / current.travelTime - this.minVelocity), 0.5);
            // Longer sliders require more memorization.
            sliderBonus *= pixelTravelDistance;
            // Nerf sliders with repeats, as less memorization is required.
            if (current.object.repeatCount > 0)
                sliderBonus /= current.object.repeatCount + 1;
        }
        result += sliderBonus * this.sliderMultiplier;
        return result;
    }
}
OsuFlashlightEvaluator.maxOpacityBonus = 0.4;
OsuFlashlightEvaluator.hiddenBonus = 0.2;
OsuFlashlightEvaluator.minVelocity = 0.5;
OsuFlashlightEvaluator.sliderMultiplier = 1.3;
OsuFlashlightEvaluator.minAngleMultiplier = 0.2;

/**
 * Represents the skill required to memorize and hit every object in a beatmap with the Flashlight mod enabled.
 */
class OsuFlashlight extends OsuSkill {
    constructor() {
        super(...arguments);
        this.strainDecayBase = 0.15;
        this.reducedSectionCount = 0;
        this.reducedSectionBaseline = 1;
        this.decayWeight = 1;
        this.currentFlashlightStrain = 0;
        this.skillMultiplier = 0.05512;
    }
    difficultyValue() {
        return this.strainPeaks.reduce((a, b) => a + b, 0);
    }
    strainValueAt(current) {
        this.currentFlashlightStrain *= this.strainDecay(current.deltaTime);
        this.currentFlashlightStrain +=
            OsuFlashlightEvaluator.evaluateDifficultyOf(current, this.mods) *
                this.skillMultiplier;
        return this.currentFlashlightStrain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentFlashlightStrain *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    saveToHitObject(current) {
        current.flashlightStrain = this.currentFlashlightStrain;
    }
}

/**
 * An evaluator for calculating osu!standard Rhythm skill.
 */
class OsuRhythmEvaluator {
    /**
     * Calculates a rhythm multiplier for the difficulty of the tap associated
     * with historic data of the current object.
     *
     * @param current The current object.
     */
    static evaluateDifficultyOf(current) {
        if (current.object instanceof osuBase.Spinner) {
            return 0;
        }
        const deltaDifferenceEpsilon = current.fullGreatWindow * 0.3;
        let rhythmComplexitySum = 0;
        let island = new Island(deltaDifferenceEpsilon);
        let previousIsland = new Island(deltaDifferenceEpsilon);
        const islandCounts = new Map();
        // Store the ratio of the current start of an island to buff for tighter rhythms.
        let startRatio = 0;
        let firstDeltaSwitch = false;
        let rhythmStart = 0;
        const historicalNoteCount = Math.min(current.index, this.historyObjectsMax);
        while (rhythmStart < historicalNoteCount - 2 &&
            current.startTime - current.previous(rhythmStart).startTime <
                this.historyTimeMax) {
            ++rhythmStart;
        }
        for (let i = rhythmStart; i > 0; --i) {
            const currentObject = current.previous(i - 1);
            const prevObject = current.previous(i);
            const lastObject = current.previous(i + 1);
            // Scale note 0 to 1 from history to now.
            const timeDecay = (this.historyTimeMax -
                (current.startTime - currentObject.startTime)) /
                this.historyTimeMax;
            const noteDecay = (historicalNoteCount - i) / historicalNoteCount;
            // Either we're limited by time or limited by object count.
            const currentHistoricalDecay = Math.min(timeDecay, noteDecay);
            const currentDelta = currentObject.strainTime;
            const prevDelta = prevObject.strainTime;
            const lastDelta = lastObject.strainTime;
            // Calculate how much current delta difference deserves a rhythm bonus
            // This function is meant to reduce rhythm bonus for deltas that are multiples of each other (i.e. 100 and 200)
            const deltaDifferenceRatio = Math.min(prevDelta, currentDelta) /
                Math.max(prevDelta, currentDelta);
            const currentRatio = 1 +
                this.rhythmRatioMultiplier *
                    Math.min(0.5, Math.pow(Math.sin(Math.PI / deltaDifferenceRatio), 2));
            // Reduce ratio bonus if delta difference is too big
            const fraction = Math.max(prevDelta / currentDelta, currentDelta / prevDelta);
            const fractionMultiplier = osuBase.MathUtils.clamp(2 - fraction / 8, 0, 1);
            const windowPenalty = Math.min(1, Math.max(0, Math.abs(prevDelta - currentDelta) - deltaDifferenceEpsilon) / deltaDifferenceEpsilon);
            let effectiveRatio = windowPenalty * currentRatio * fractionMultiplier;
            if (firstDeltaSwitch) {
                if (Math.abs(prevDelta - currentDelta) < deltaDifferenceEpsilon) {
                    // Island is still progressing, count size.
                    island.addDelta(currentDelta);
                }
                else {
                    // BPM change is into slider, this is easy acc window.
                    if (currentObject.object instanceof osuBase.Slider) {
                        effectiveRatio /= 8;
                    }
                    // BPM change was from a slider, this is easier typically than circle -> circle.
                    // Unintentional side effect is that bursts with kicksliders at the ends might have lower difficulty
                    // than bursts without sliders.
                    if (prevObject.object instanceof osuBase.Slider) {
                        effectiveRatio *= 0.3;
                    }
                    // Repeated island polarity (2 -> 4, 3 -> 5).
                    if (island.isSimilarPolarity(previousIsland)) {
                        effectiveRatio /= 2;
                    }
                    // Previous increase happened a note ago.
                    // Albeit this is a 1/1 -> 1/2-1/4 type of transition, we don't want to buff this.
                    if (lastDelta > prevDelta + deltaDifferenceEpsilon &&
                        prevDelta > currentDelta + deltaDifferenceEpsilon) {
                        effectiveRatio /= 8;
                    }
                    // Repeated island size (ex: triplet -> triplet).
                    // TODO: remove this nerf since its staying here only for balancing purposes because of the flawed ratio calculation
                    if (previousIsland.deltaCount == island.deltaCount) {
                        effectiveRatio /= 2;
                    }
                    let islandFound = false;
                    for (const [currentIsland, count] of islandCounts) {
                        if (!island.equals(currentIsland)) {
                            continue;
                        }
                        islandFound = true;
                        let islandCount = count;
                        if (previousIsland.equals(island)) {
                            // Only add island to island counts if they're going one after another.
                            ++islandCount;
                            islandCounts.set(currentIsland, islandCount);
                        }
                        // Repeated island (ex: triplet -> triplet).
                        // Graph: https://www.desmos.com/calculator/pj7an56zwf
                        effectiveRatio *= Math.min(3 / islandCount, Math.pow(1 / islandCount, osuBase.MathUtils.offsetLogistic(island.delta, 58.33, 0.24, 2.75)));
                        break;
                    }
                    if (!islandFound) {
                        islandCounts.set(island, 1);
                    }
                    // Scale down the difficulty if the object is doubletappable.
                    effectiveRatio *= 1 - prevObject.doubletapness * 0.75;
                    rhythmComplexitySum +=
                        Math.sqrt(effectiveRatio * startRatio) *
                            currentHistoricalDecay;
                    startRatio = effectiveRatio;
                    previousIsland = island;
                    if (prevDelta + deltaDifferenceEpsilon < currentDelta) {
                        // We're slowing down, stop counting.
                        // If we're speeding up, this stays as is and we keep counting island size.
                        firstDeltaSwitch = false;
                    }
                    island = new Island(currentDelta, deltaDifferenceEpsilon);
                }
            }
            else if (prevDelta > currentDelta + deltaDifferenceEpsilon) {
                // We are speeding up.
                // Begin counting island until we change speed again.
                firstDeltaSwitch = true;
                // BPM change is into slider, this is easy acc window.
                if (currentObject.object instanceof osuBase.Slider) {
                    effectiveRatio *= 0.6;
                }
                // BPM change was from a slider, this is easier typically than circle -> circle
                // Unintentional side effect is that bursts with kicksliders at the ends might have lower difficulty
                // than bursts without sliders
                if (prevObject.object instanceof osuBase.Slider) {
                    effectiveRatio *= 0.6;
                }
                startRatio = effectiveRatio;
                island = new Island(currentDelta, deltaDifferenceEpsilon);
            }
        }
        return (Math.sqrt(4 + rhythmComplexitySum * this.rhythmOverallMultiplier) /
            2);
    }
}
OsuRhythmEvaluator.historyTimeMax = 5000; // 5 seconds of calculateRhythmBonus max.
OsuRhythmEvaluator.historyObjectsMax = 32;
OsuRhythmEvaluator.rhythmOverallMultiplier = 0.95;
OsuRhythmEvaluator.rhythmRatioMultiplier = 12;

/**
 * An evaluator for calculating osu!standard speed skill.
 */
class OsuSpeedEvaluator {
    /**
     * Evaluates the difficulty of tapping the current object, based on:
     *
     * - time between pressing the previous and current object,
     * - distance between those objects,
     * - and how easily they can be cheesed.
     *
     * @param current The current object.
     * @param mods The mods applied.
     */
    static evaluateDifficultyOf(current, mods) {
        var _a;
        if (current.object instanceof osuBase.Spinner) {
            return 0;
        }
        const prev = current.previous(0);
        let strainTime = current.strainTime;
        // Nerf doubletappable doubles.
        const doubletapness = 1 - current.doubletapness;
        // Cap deltatime to the OD 300 hitwindow.
        // 0.93 is derived from making sure 260 BPM 1/4 OD8 streams aren't nerfed harshly, whilst 0.92 limits the effect of the cap.
        strainTime /= osuBase.MathUtils.clamp(strainTime / current.fullGreatWindow / 0.93, 0.92, 1);
        // speedBonus will be 0.0 for BPM < 200
        let speedBonus = 0;
        // Add additional scaling bonus for streams/bursts higher than 200bpm
        if (strainTime < this.minSpeedBonus) {
            speedBonus =
                0.75 * Math.pow((this.minSpeedBonus - strainTime) / 40, 2);
        }
        const travelDistance = (_a = prev === null || prev === void 0 ? void 0 : prev.travelDistance) !== null && _a !== void 0 ? _a : 0;
        // Cap distance at spacing threshold
        const distance = Math.min(this.SINGLE_SPACING_THRESHOLD, travelDistance + current.minimumJumpDistance);
        // Max distance bonus is 1 * `distance_multiplier` at single_spacing_threshold
        let distanceBonus = Math.pow(distance / this.SINGLE_SPACING_THRESHOLD, 3.95) *
            this.DISTANCE_MULTIPLIER;
        if (mods.has(osuBase.ModAutopilot)) {
            distanceBonus = 0;
        }
        // Base difficulty with all bonuses
        const difficulty = ((1 + speedBonus + distanceBonus) * 1000) / strainTime;
        // Apply penalty if there's doubletappable doubles
        return difficulty * doubletapness;
    }
}
/**
 * Spacing threshold for a single hitobject spacing.
 *
 * About 1.25 circles distance between hitobject centers.
 */
OsuSpeedEvaluator.SINGLE_SPACING_THRESHOLD = 125;
// ~200 1/4 BPM streams
OsuSpeedEvaluator.minSpeedBonus = 75;
OsuSpeedEvaluator.DISTANCE_MULTIPLIER = 0.9;

/**
 * Represents the skill required to press keys or tap with regards to keeping up with the speed at which objects need to be hit.
 */
class OsuSpeed extends OsuSkill {
    constructor() {
        super(...arguments);
        this.strainDecayBase = 0.3;
        this.reducedSectionCount = 5;
        this.reducedSectionBaseline = 0.75;
        this.decayWeight = 0.9;
        this.currentSpeedStrain = 0;
        this.currentRhythm = 0;
        this.skillMultiplier = 1.46;
    }
    /**
     * The amount of notes that are relevant to the difficulty.
     */
    relevantNoteCount() {
        if (this._objectStrains.length === 0) {
            return 0;
        }
        const maxStrain = osuBase.MathUtils.max(this._objectStrains);
        if (maxStrain === 0) {
            return 0;
        }
        return this._objectStrains.reduce((total, next) => total + 1 / (1 + Math.exp(-((next / maxStrain) * 12 - 6))), 0);
    }
    /**
     * @param current The hitobject to calculate.
     */
    strainValueAt(current) {
        this.currentSpeedStrain *= this.strainDecay(current.strainTime);
        this.currentSpeedStrain +=
            OsuSpeedEvaluator.evaluateDifficultyOf(current, this.mods) *
                this.skillMultiplier;
        this.currentRhythm = OsuRhythmEvaluator.evaluateDifficultyOf(current);
        const strain = this.currentSpeedStrain * this.currentRhythm;
        this._objectStrains.push(strain);
        return strain;
    }
    calculateInitialStrain(time, current) {
        var _a, _b;
        return (this.currentSpeedStrain *
            this.currentRhythm *
            this.strainDecay(time - ((_b = (_a = current.previous(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : 0)));
    }
    /**
     * @param current The hitobject to save to.
     */
    saveToHitObject(current) {
        current.speedStrain = this.currentSpeedStrain * this.currentRhythm;
        current.rhythmMultiplier = this.currentRhythm;
    }
}

/**
 * A difficulty calculator for osu!standard gamemode.
 */
class OsuDifficultyCalculator extends DifficultyCalculator {
    constructor() {
        super();
        this.difficultyMultiplier = 0.0675;
        this.difficultyAdjustmentMods.add(osuBase.ModTouchDevice);
    }
    retainDifficultyAdjustmentMods(mods) {
        return mods.filter((mod) => mod.isApplicableToOsu() &&
            this.difficultyAdjustmentMods.has(mod.constructor) &&
            mod.isOsuRelevant);
    }
    createDifficultyAttributes(beatmap, skills) {
        const attributes = new OsuDifficultyAttributes();
        attributes.mods = beatmap.mods;
        attributes.maxCombo = beatmap.maxCombo;
        attributes.clockRate = beatmap.speedMultiplier;
        attributes.hitCircleCount = beatmap.hitObjects.circles;
        attributes.sliderCount = beatmap.hitObjects.sliders;
        attributes.spinnerCount = beatmap.hitObjects.spinners;
        this.populateAimAttributes(attributes, skills);
        this.populateSpeedAttributes(attributes, skills);
        this.populateFlashlightAttributes(attributes, skills);
        if (attributes.mods.has(osuBase.ModRelax)) {
            attributes.aimDifficulty *= 0.9;
            attributes.speedDifficulty = 0;
            attributes.flashlightDifficulty *= 0.7;
        }
        else if (attributes.mods.has(osuBase.ModAutopilot)) {
            attributes.aimDifficulty = 0;
            attributes.speedDifficulty *= 0.5;
            attributes.flashlightDifficulty *= 0.4;
        }
        const aimPerformanceValue = this.basePerformanceValue(attributes.aimDifficulty);
        const speedPerformanceValue = this.basePerformanceValue(attributes.speedDifficulty);
        const flashlightPerformanceValue = Math.pow(attributes.flashlightDifficulty, 2) * 25;
        const basePerformanceValue = Math.pow(Math.pow(aimPerformanceValue, 1.1) +
            Math.pow(speedPerformanceValue, 1.1) +
            Math.pow(flashlightPerformanceValue, 1.1), 1 / 1.1);
        if (basePerformanceValue > 1e-5) {
            // Document for formula derivation:
            // https://docs.google.com/document/d/10DZGYYSsT_yjz2Mtp6yIJld0Rqx4E-vVHupCqiM4TNI/edit
            attributes.starRating =
                Math.cbrt(1.15) *
                    0.027 *
                    (Math.cbrt((100000 / Math.pow(2, 1 / 1.1)) * basePerformanceValue) +
                        4);
        }
        else {
            attributes.starRating = 0;
        }
        const preempt = osuBase.BeatmapDifficulty.difficultyRange(beatmap.difficulty.ar, osuBase.HitObject.preemptMax, osuBase.HitObject.preemptMid, osuBase.HitObject.preemptMin) / attributes.clockRate;
        attributes.approachRate = osuBase.BeatmapDifficulty.inverseDifficultyRange(preempt, osuBase.HitObject.preemptMax, osuBase.HitObject.preemptMid, osuBase.HitObject.preemptMin);
        const { greatWindow } = new osuBase.OsuHitWindow(beatmap.difficulty.od);
        attributes.overallDifficulty = osuBase.OsuHitWindow.greatWindowToOD(greatWindow / attributes.clockRate);
        return attributes;
    }
    createPlayableBeatmap(beatmap, mods) {
        return beatmap.createOsuPlayableBeatmap(mods);
    }
    createDifficultyHitObjects(beatmap) {
        var _a;
        const clockRate = beatmap.speedMultiplier;
        const difficultyObjects = [];
        const { objects } = beatmap.hitObjects;
        for (let i = 1; i < objects.length; ++i) {
            const difficultyObject = new OsuDifficultyHitObject(objects[i], objects[i - 1], (_a = objects[i - 2]) !== null && _a !== void 0 ? _a : null, difficultyObjects, clockRate, i - 1);
            difficultyObject.computeProperties(clockRate, objects);
            difficultyObjects.push(difficultyObject);
        }
        return difficultyObjects;
    }
    createSkills(beatmap) {
        const { mods } = beatmap;
        const skills = [];
        if (!mods.has(osuBase.ModAutopilot)) {
            skills.push(new OsuAim(mods, true));
            skills.push(new OsuAim(mods, false));
        }
        if (!mods.has(osuBase.ModRelax)) {
            skills.push(new OsuSpeed(mods));
        }
        if (mods.has(osuBase.ModFlashlight)) {
            skills.push(new OsuFlashlight(mods));
        }
        return skills;
    }
    createStrainPeakSkills(beatmap) {
        const { mods } = beatmap;
        return [
            new OsuAim(mods, true),
            new OsuAim(mods, false),
            new OsuSpeed(mods),
            new OsuFlashlight(mods),
        ];
    }
    populateAimAttributes(attributes, skills) {
        const aim = skills.find((s) => s instanceof OsuAim && s.withSliders);
        const aimNoSlider = skills.find((s) => s instanceof OsuAim && !s.withSliders);
        if (!aim || !aimNoSlider) {
            return;
        }
        attributes.aimDifficulty = this.calculateRating(aim);
        attributes.aimDifficultSliderCount = aim.countDifficultSliders();
        attributes.aimDifficultStrainCount = aim.countDifficultStrains();
        if (attributes.aimDifficulty > 0) {
            attributes.sliderFactor =
                this.calculateRating(aimNoSlider) / attributes.aimDifficulty;
        }
        else {
            attributes.sliderFactor = 1;
        }
    }
    populateSpeedAttributes(attributes, skills) {
        const speed = skills.find((s) => s instanceof OsuSpeed);
        if (!speed) {
            return;
        }
        attributes.speedDifficulty = this.calculateRating(speed);
        attributes.speedNoteCount = speed.relevantNoteCount();
        attributes.speedDifficultStrainCount = speed.countDifficultStrains();
    }
    populateFlashlightAttributes(attributes, skills) {
        const flashlight = skills.find((s) => s instanceof OsuFlashlight);
        if (!flashlight) {
            return;
        }
        attributes.flashlightDifficulty = this.calculateRating(flashlight);
    }
}

/**
 * A performance points calculator that calculates performance points for osu!standard gamemode.
 */
class OsuPerformanceCalculator extends PerformanceCalculator {
    constructor() {
        super(...arguments);
        /**
         * The aim performance value.
         */
        this.aim = 0;
        /**
         * The speed performance value.
         */
        this.speed = 0;
        /**
         * The accuracy performance value.
         */
        this.accuracy = 0;
        /**
         * The flashlight performance value.
         */
        this.flashlight = 0;
        this.finalMultiplier = 1.15;
        this.mode = osuBase.Modes.osu;
        this.comboPenalty = 1;
        this.speedDeviation = 0;
    }
    calculateValues() {
        this.speedDeviation = this.calculateSpeedDeviation();
        this.aim = this.calculateAimValue();
        this.speed = this.calculateSpeedValue();
        this.accuracy = this.calculateAccuracyValue();
        this.flashlight = this.calculateFlashlightValue();
    }
    calculateTotalValue() {
        return (Math.pow(Math.pow(this.aim, 1.1) +
            Math.pow(this.speed, 1.1) +
            Math.pow(this.accuracy, 1.1) +
            Math.pow(this.flashlight, 1.1), 1 / 1.1) * this.finalMultiplier);
    }
    handleOptions(options) {
        var _a;
        super.handleOptions(options);
        const maxCombo = this.difficultyAttributes.maxCombo;
        const miss = this.computedAccuracy.nmiss;
        const combo = (_a = options === null || options === void 0 ? void 0 : options.combo) !== null && _a !== void 0 ? _a : maxCombo - miss;
        this.comboPenalty = Math.min(Math.pow(combo / maxCombo, 0.8), 1);
    }
    /**
     * Calculates the aim performance value of the beatmap.
     */
    calculateAimValue() {
        if (this.mods.has(osuBase.ModAutopilot)) {
            return 0;
        }
        let aimValue = this.baseValue(this.difficultyAttributes.aimDifficulty);
        // Longer maps are worth more
        let lengthBonus = 0.95 + 0.4 * Math.min(1, this.totalHits / 2000);
        if (this.totalHits > 2000) {
            lengthBonus += Math.log10(this.totalHits / 2000) * 0.5;
        }
        aimValue *= lengthBonus;
        if (this.effectiveMissCount > 0) {
            // Penalize misses by assessing # of misses relative to the total # of objects.
            // Default a 3% reduction for any # of misses.
            aimValue *=
                0.97 *
                    Math.pow(1 -
                        Math.pow(this.effectiveMissCount / this.totalHits, 0.775), this.effectiveMissCount);
        }
        aimValue *= this.calculateStrainBasedMissPenalty(this.difficultyAttributes.aimDifficultStrainCount);
        const calculatedAR = this.difficultyAttributes.approachRate;
        if (!this.mods.has(osuBase.ModRelax)) {
            // AR scaling
            let arFactor = 0;
            if (calculatedAR > 10.33) {
                arFactor += 0.3 * (calculatedAR - 10.33);
            }
            else if (calculatedAR < 8) {
                arFactor += 0.05 * (8 - calculatedAR);
            }
            // Buff for longer maps with high AR.
            aimValue *= 1 + arFactor * lengthBonus;
        }
        // We want to give more reward for lower AR when it comes to aim and HD. This nerfs high AR and buffs lower AR.
        if (this.mods.has(osuBase.ModHidden) || this.mods.has(osuBase.ModTraceable)) {
            aimValue *= 1 + 0.04 * (12 - calculatedAR);
        }
        // Scale the aim value with slider factor to nerf very likely dropped sliderends.
        aimValue *= this.sliderNerfFactor;
        // Scale the aim value with accuracy.
        aimValue *= this.computedAccuracy.value();
        // It is also important to consider accuracy difficulty when doing that.
        const odScaling = Math.pow(this.difficultyAttributes.overallDifficulty, 2) / 2500;
        aimValue *= 0.98 + odScaling;
        return aimValue;
    }
    /**
     * Calculates the speed performance value of the beatmap.
     */
    calculateSpeedValue() {
        if (this.mods.has(osuBase.ModRelax) ||
            this.speedDeviation === Number.POSITIVE_INFINITY) {
            return 0;
        }
        let speedValue = this.baseValue(this.difficultyAttributes.speedDifficulty);
        // Longer maps are worth more
        let lengthBonus = 0.95 + 0.4 * Math.min(1, this.totalHits / 2000);
        if (this.totalHits > 2000) {
            lengthBonus += Math.log10(this.totalHits / 2000) * 0.5;
        }
        speedValue *= lengthBonus;
        speedValue *= this.calculateStrainBasedMissPenalty(this.difficultyAttributes.speedDifficultStrainCount);
        // AR scaling
        const calculatedAR = this.difficultyAttributes.approachRate;
        if (calculatedAR > 10.33 && !this.mods.has(osuBase.ModAutopilot)) {
            // Buff for longer maps with high AR.
            speedValue *= 1 + 0.3 * (calculatedAR - 10.33) * lengthBonus;
        }
        if (this.mods.has(osuBase.ModHidden) || this.mods.has(osuBase.ModTraceable)) {
            speedValue *= 1 + 0.04 * (12 - calculatedAR);
        }
        // Calculate accuracy assuming the worst case scenario.
        const countGreat = this.computedAccuracy.n300;
        const countOk = this.computedAccuracy.n100;
        const countMeh = this.computedAccuracy.n50;
        const relevantTotalDiff = this.totalHits - this.difficultyAttributes.speedNoteCount;
        const relevantAccuracy = new osuBase.Accuracy(this.difficultyAttributes.speedNoteCount > 0
            ? {
                n300: Math.max(0, countGreat - relevantTotalDiff),
                n100: Math.max(0, countOk - Math.max(0, relevantTotalDiff - countGreat)),
                n50: Math.max(0, countMeh -
                    Math.max(0, relevantTotalDiff - countGreat - countOk)),
            }
            : // Set accuracy to 0.
                { n300: 0, nobjects: 1 });
        speedValue *= this.calculateSpeedHighDeviationNerf();
        // Scale the speed value with accuracy and OD.
        speedValue *=
            (0.95 +
                Math.pow(Math.max(0, this.difficultyAttributes.overallDifficulty), 2) /
                    750) *
                Math.pow((this.computedAccuracy.value() +
                    relevantAccuracy.value(this.difficultyAttributes.speedNoteCount)) /
                    2, (14.5 - this.difficultyAttributes.overallDifficulty) / 2);
        return speedValue;
    }
    /**
     * Calculates the accuracy performance value of the beatmap.
     */
    calculateAccuracyValue() {
        if (this.mods.has(osuBase.ModRelax)) {
            return 0;
        }
        const ncircles = this.mods.has(osuBase.ModScoreV2)
            ? this.totalHits - this.difficultyAttributes.spinnerCount
            : this.difficultyAttributes.hitCircleCount;
        if (ncircles === 0) {
            return 0;
        }
        const realAccuracy = new osuBase.Accuracy(Object.assign(Object.assign({}, this.computedAccuracy), { n300: this.computedAccuracy.n300 - (this.totalHits - ncircles) }));
        // Lots of arbitrary values from testing.
        // Considering to use derivation from perfect accuracy in a probabilistic manner - assume normal distribution
        let accuracyValue = Math.pow(1.52163, this.difficultyAttributes.overallDifficulty) *
            // It is possible to reach a negative accuracy with this formula. Cap it at zero - zero points.
            Math.pow(realAccuracy.n300 < 0 ? 0 : realAccuracy.value(), 24) *
            2.83;
        // Bonus for many hitcircles - it's harder to keep good accuracy up for longer
        accuracyValue *= Math.min(1.15, Math.pow(ncircles / 1000, 0.3));
        if (this.mods.has(osuBase.ModHidden) || this.mods.has(osuBase.ModTraceable)) {
            accuracyValue *= 1.08;
        }
        if (this.mods.has(osuBase.ModFlashlight)) {
            accuracyValue *= 1.02;
        }
        return accuracyValue;
    }
    /**
     * Calculates the flashlight performance value of the beatmap.
     */
    calculateFlashlightValue() {
        if (!this.mods.has(osuBase.ModFlashlight)) {
            return 0;
        }
        let flashlightValue = Math.pow(this.difficultyAttributes.flashlightDifficulty, 2) * 25;
        // Combo scaling
        flashlightValue *= this.comboPenalty;
        if (this.effectiveMissCount > 0) {
            // Penalize misses by assessing # of misses relative to the total # of objects. Default a 3% reduction for any # of misses.
            flashlightValue *=
                0.97 *
                    Math.pow(1 -
                        Math.pow(this.effectiveMissCount / this.totalHits, 0.775), Math.pow(this.effectiveMissCount, 0.875));
        }
        // Account for shorter maps having a higher ratio of 0 combo/100 combo flashlight radius.
        flashlightValue *=
            0.7 +
                0.1 * Math.min(1, this.totalHits / 200) +
                (this.totalHits > 200
                    ? 0.2 * Math.min(1, (this.totalHits - 200) / 200)
                    : 0);
        // Scale the flashlight value with accuracy slightly.
        flashlightValue *= 0.5 + this.computedAccuracy.value() / 2;
        // It is also important to consider accuracy difficulty when doing that.
        const odScaling = Math.pow(this.difficultyAttributes.overallDifficulty, 2) / 2500;
        flashlightValue *= 0.98 + odScaling;
        return flashlightValue;
    }
    /**
     * Estimates a player's deviation on speed notes using {@link calculateDeviation}, assuming worst-case.
     *
     * Treats all speed notes as hit circles.
     */
    calculateSpeedDeviation() {
        if (this.totalSuccessfulHits === 0) {
            return Number.POSITIVE_INFINITY;
        }
        // Calculate accuracy assuming the worst case scenario
        const speedNoteCount = this.difficultyAttributes.speedNoteCount +
            (this.totalHits - this.difficultyAttributes.speedNoteCount) * 0.1;
        // Assume worst case: all mistakes were on speed notes
        const relevantCountMiss = Math.min(this.computedAccuracy.nmiss, speedNoteCount);
        const relevantCountMeh = Math.min(this.computedAccuracy.n50, speedNoteCount - relevantCountMiss);
        const relevantCountOk = Math.min(this.computedAccuracy.n100, speedNoteCount - relevantCountMiss - relevantCountMeh);
        const relevantCountGreat = Math.max(0, speedNoteCount -
            relevantCountMiss -
            relevantCountMeh -
            relevantCountOk);
        return this.calculateDeviation(relevantCountGreat, relevantCountOk, relevantCountMeh, relevantCountMiss);
    }
    /**
     * Estimates the player's tap deviation based on the OD, given number of greats, oks, mehs and misses,
     * assuming the player's mean hit error is 0. The estimation is consistent in that two SS scores on the
     * same map with the same settings will always return the same deviation.
     *
     * Misses are ignored because they are usually due to misaiming.
     *
     * Greats and oks are assumed to follow a normal distribution, whereas mehs are assumed to follow a uniform distribution.
     */
    calculateDeviation(relevantCountGreat, relevantCountOk, relevantCountMeh, relevantCountMiss) {
        if (relevantCountGreat + relevantCountOk + relevantCountMeh <= 0) {
            return Number.POSITIVE_INFINITY;
        }
        const objectCount = relevantCountGreat +
            relevantCountOk +
            relevantCountMeh +
            relevantCountMiss;
        // Obtain the great, ok, and meh windows.
        const hitWindow = new osuBase.OsuHitWindow(osuBase.OsuHitWindow.greatWindowToOD(
        // Convert current OD to non clock rate-adjusted OD.
        new osuBase.OsuHitWindow(this.difficultyAttributes.overallDifficulty)
            .greatWindow * this.difficultyAttributes.clockRate));
        const { greatWindow, okWindow, mehWindow } = hitWindow;
        // The probability that a player hits a circle is unknown, but we can estimate it to be
        // the number of greats on circles divided by the number of circles, and then add one
        // to the number of circles as a bias correction.
        const n = Math.max(1, objectCount - relevantCountMiss - relevantCountMeh);
        // 99% critical value for the normal distribution (one-tailed).
        const z = 2.32634787404;
        // Proportion of greats hit on circles, ignoring misses and 50s.
        const p = relevantCountGreat / n;
        // We can be 99% confident that p is at least this value.
        const pLowerBound = (n * p + (z * z) / 2) / (n + z * z) -
            (z / (n + z * z)) * Math.sqrt(n * p * (1 - p) + (z * z) / 4);
        // Compute the deviation assuming greats and oks are normally distributed, and mehs are uniformly distributed.
        // Begin with greats and oks first. Ignoring mehs, we can be 99% confident that the deviation is not higher than:
        let deviation = greatWindow / (Math.SQRT2 * osuBase.ErrorFunction.erfInv(pLowerBound));
        const randomValue = (Math.sqrt(2 / Math.PI) *
            okWindow *
            Math.pow(Math.exp(-0.5 * (okWindow / deviation)), 2)) /
            (deviation *
                osuBase.ErrorFunction.erf(okWindow / (Math.SQRT2 * deviation)));
        deviation *= Math.sqrt(1 - randomValue);
        // Value deviation approach as greatCount approaches 0
        const limitValue = okWindow / Math.sqrt(3);
        // If precision is not enough to compute true deviation - use limit value
        if (pLowerBound == 0.0 || randomValue >= 1 || deviation > limitValue) {
            deviation = limitValue;
        }
        // Then compute the variance for mehs.
        const mehVariance = (Math.pow(mehWindow, 2) +
            okWindow * mehWindow +
            Math.pow(okWindow, 2)) /
            3;
        // Find the total deviation.
        deviation = Math.sqrt(((relevantCountGreat + relevantCountOk) * Math.pow(deviation, 2) +
            relevantCountMeh * mehVariance) /
            (relevantCountGreat + relevantCountOk + relevantCountMeh));
        return deviation;
    }
    /**
     * Calculates multiplier for speed to account for improper tapping based on the deviation and speed difficulty.
     *
     * [Graph](https://www.desmos.com/calculator/dmogdhzofn)
     */
    calculateSpeedHighDeviationNerf() {
        if (this.speedDeviation == Number.POSITIVE_INFINITY) {
            return 0;
        }
        const speedValue = this.baseValue(this.difficultyAttributes.speedDifficulty);
        // Decide a point where the PP value achieved compared to the speed deviation is assumed to be tapped
        // improperly. Any PP above this point is considered "excess" speed difficulty. This is used to cause
        // PP above the cutoff to scale logarithmically towards the original speed value thus nerfing the value.
        const excessSpeedDifficultyCutoff = 100 + 220 * Math.pow(22 / this.speedDeviation, 6.5);
        if (speedValue <= excessSpeedDifficultyCutoff) {
            return 1;
        }
        const scale = 50;
        const adjustedSpeedValue = scale *
            (Math.log((speedValue - excessSpeedDifficultyCutoff) / scale + 1) +
                excessSpeedDifficultyCutoff / scale);
        // 220 UR and less are considered tapped correctly to ensure that normal scores will be punished as little as possible
        const t = 1 - osuBase.Interpolation.reverseLerp(this.speedDeviation, 22, 27);
        return (osuBase.Interpolation.lerp(adjustedSpeedValue, speedValue, t) / speedValue);
    }
    toString() {
        return (this.total.toFixed(2) +
            " pp (" +
            this.aim.toFixed(2) +
            " aim, " +
            this.speed.toFixed(2) +
            " speed, " +
            this.accuracy.toFixed(2) +
            " acc, " +
            this.flashlight.toFixed(2) +
            " flashlight)");
    }
}

exports.DifficultyAttributes = DifficultyAttributes;
exports.DifficultyCalculator = DifficultyCalculator;
exports.DifficultyHitObject = DifficultyHitObject;
exports.DroidAim = DroidAim;
exports.DroidAimEvaluator = DroidAimEvaluator;
exports.DroidDifficultyAttributes = DroidDifficultyAttributes;
exports.DroidDifficultyCalculator = DroidDifficultyCalculator;
exports.DroidDifficultyHitObject = DroidDifficultyHitObject;
exports.DroidFlashlight = DroidFlashlight;
exports.DroidFlashlightEvaluator = DroidFlashlightEvaluator;
exports.DroidPerformanceCalculator = DroidPerformanceCalculator;
exports.DroidRhythm = DroidRhythm;
exports.DroidRhythmEvaluator = DroidRhythmEvaluator;
exports.DroidTap = DroidTap;
exports.DroidTapEvaluator = DroidTapEvaluator;
exports.DroidVisual = DroidVisual;
exports.DroidVisualEvaluator = DroidVisualEvaluator;
exports.ExtendedDroidDifficultyAttributes = ExtendedDroidDifficultyAttributes;
exports.OsuAim = OsuAim;
exports.OsuAimEvaluator = OsuAimEvaluator;
exports.OsuDifficultyAttributes = OsuDifficultyAttributes;
exports.OsuDifficultyCalculator = OsuDifficultyCalculator;
exports.OsuDifficultyHitObject = OsuDifficultyHitObject;
exports.OsuFlashlight = OsuFlashlight;
exports.OsuFlashlightEvaluator = OsuFlashlightEvaluator;
exports.OsuPerformanceCalculator = OsuPerformanceCalculator;
exports.OsuRhythmEvaluator = OsuRhythmEvaluator;
exports.OsuSpeed = OsuSpeed;
exports.OsuSpeedEvaluator = OsuSpeedEvaluator;
exports.PerformanceCalculator = PerformanceCalculator;
//# sourceMappingURL=index.js.map
