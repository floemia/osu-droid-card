import { ModMap, SerializedMod, PlaceableHitObject, Modes, PlayableBeatmap, Mod, Beatmap, DroidPlayableBeatmap, Accuracy, OsuPlayableBeatmap } from '@rian8337/osu-base';

/**
 * Holds data that can be used to calculate performance points.
 */
interface IDifficultyAttributes {
    /**
     * The mods which were applied to the beatmap.
     */
    mods: ModMap;
    /**
     * The combined star rating of all skills.
     */
    starRating: number;
    /**
     * The maximum achievable combo.
     */
    maxCombo: number;
    /**
     * The difficulty corresponding to the aim skill.
     */
    aimDifficulty: number;
    /**
     * The difficulty corresponding to the flashlight skill.
     */
    flashlightDifficulty: number;
    /**
     * The number of clickable objects weighted by difficulty.
     *
     * Related to speed/tap difficulty.
     */
    speedNoteCount: number;
    /**
     * Describes how much of aim difficulty is contributed to by hitcircles or sliders.
     *
     * A value closer to 1 indicates most of aim difficulty is contributed by hitcircles.
     *
     * A value closer to 0 indicates most of aim difficulty is contributed by sliders.
     */
    sliderFactor: number;
    /**
     * The overall clock rate that was applied to the beatmap.
     */
    clockRate: number;
    /**
     * The perceived overall difficulty inclusive of rate-adjusting mods (DT/HT/etc), based on osu!standard judgement.
     *
     * Rate-adjusting mods don't directly affect the overall difficulty value, but have a perceived effect as a result of adjusting audio timing.
     */
    overallDifficulty: number;
    /**
     * The number of hitcircles in the beatmap.
     */
    hitCircleCount: number;
    /**
     * The number of sliders in the beatmap.
     */
    sliderCount: number;
    /**
     * The number of spinners in the beatmap.
     */
    spinnerCount: number;
    /**
     * The number of sliders weighted by difficulty.
     */
    aimDifficultSliderCount: number;
    /**
     * The amount of strains that are considered difficult with respect to the aim skill.
     */
    aimDifficultStrainCount: number;
}

/**
 * Represents difficulty attributes that can be cached.
 */
type CacheableDifficultyAttributes<T extends IDifficultyAttributes> = Omit<T, "mods" | "toCacheableAttributes"> & {
    /**
     * The mods which were applied to the beatmap.
     */
    mods: SerializedMod[];
};

/**
 * Holds data that can be used to calculate performance points.
 */
declare abstract class DifficultyAttributes implements IDifficultyAttributes {
    mods: ModMap;
    starRating: number;
    maxCombo: number;
    aimDifficulty: number;
    flashlightDifficulty: number;
    speedNoteCount: number;
    sliderFactor: number;
    clockRate: number;
    overallDifficulty: number;
    hitCircleCount: number;
    sliderCount: number;
    spinnerCount: number;
    aimDifficultSliderCount: number;
    aimDifficultStrainCount: number;
    constructor(cacheableAttributes?: CacheableDifficultyAttributes<IDifficultyAttributes>);
    /**
     * Converts this `DifficultyAttributes` instance to an attribute structure that can be cached.
     *
     * @returns The cacheable attributes.
     */
    toCacheableAttributes(): CacheableDifficultyAttributes<this>;
    /**
     * Returns a string representation of the difficulty attributes.
     */
    toString(): string;
}

/**
 * Represents a hit object with difficulty calculation values.
 */
declare abstract class DifficultyHitObject {
    /**
     * The underlying hitobject.
     */
    readonly object: PlaceableHitObject;
    /**
     * The index of this hitobject in the list of all hitobjects.
     *
     * This is one less than the actual index of the hitobject in the beatmap.
     */
    readonly index: number;
    /**
     * The aim strain generated by the hitobject if sliders are considered.
     */
    aimStrainWithSliders: number;
    /**
     * The aim strain generated by the hitobject if sliders are not considered.
     */
    aimStrainWithoutSliders: number;
    /**
     * The rhythm multiplier generated by the hitobject. This is used to alter tap strain.
     */
    rhythmMultiplier: number;
    /**
     * The normalized distance from the "lazy" end position of the previous hitobject to the start position of this hitobject.
     *
     * The "lazy" end position is the position at which the cursor ends up if the previous hitobject is followed with as minimal movement as possible (i.e. on the edge of slider follow circles).
     */
    lazyJumpDistance: number;
    /**
     * The normalized shortest distance to consider for a jump between the previous hitobject and this hitobject.
     *
     * This is bounded from above by `lazyJumpDistance`, and is smaller than the former if a more natural path is able to be taken through the previous hitobject.
     *
     * Suppose a linear slider - circle pattern. Following the slider lazily (see: `lazyJumpDistance`) will result in underestimating the true end position of the slider as being closer towards the start position.
     * As a result, `lazyJumpDistance` overestimates the jump distance because the player is able to take a more natural path by following through the slider to its end,
     * such that the jump is felt as only starting from the slider's true end position.
     *
     * Now consider a slider - circle pattern where the circle is stacked along the path inside the slider.
     * In this case, the lazy end position correctly estimates the true end position of the slider and provides the more natural movement path.
     */
    minimumJumpDistance: number;
    /**
     * The time taken to travel through `minimumJumpDistance`, with a minimum value of 25ms.
     */
    minimumJumpTime: number;
    /**
     * The normalized distance between the start and end position of this hitobject.
     */
    travelDistance: number;
    /**
     * The time taken to travel through `travelDistance`, with a minimum value of 25ms for sliders.
     */
    travelTime: number;
    /**
     * Angle the player has to take to hit this hitobject.
     *
     * Calculated as the angle between the circles (current-2, current-1, current).
     */
    angle: number | null;
    /**
     * The amount of milliseconds elapsed between this hitobject and the last hitobject.
     */
    readonly deltaTime: number;
    /**
     * The amount of milliseconds elapsed since the start time of the previous hitobject, with a minimum of 25ms.
     */
    readonly strainTime: number;
    /**
     * Adjusted start time of the hitobject, taking speed multiplier into account.
     */
    readonly startTime: number;
    /**
     * Adjusted end time of the hitobject, taking speed multiplier into account.
     */
    readonly endTime: number;
    /**
     * The full great window of the hitobject.
     */
    readonly fullGreatWindow: number;
    /**
     * Other hitobjects in the beatmap, including this hitobject.
     */
    protected readonly hitObjects: readonly DifficultyHitObject[];
    /**
     * The normalized radius of the hitobject.
     */
    static readonly normalizedRadius: number;
    /**
     * The normalized diameter of the hitobject.
     */
    static get normalizedDiameter(): number;
    protected abstract readonly mode: Modes;
    protected readonly maximumSliderRadius: number;
    protected readonly assumedSliderRadius: number;
    /**
     * The lowest possible delta time value.
     */
    static readonly minDeltaTime = 25;
    private readonly lastObject;
    private readonly lastLastObject;
    /**
     * Note: You **must** call `computeProperties` at some point due to how TypeScript handles
     * overridden properties (see [this](https://github.com/microsoft/TypeScript/issues/1617) GitHub issue).
     *
     * @param object The underlying hitobject.
     * @param lastObject The hitobject before this hitobject.
     * @param lastLastObject The hitobject before the last hitobject.
     * @param difficultyHitObjects All difficulty hitobjects in the processed beatmap.
     * @param clockRate The clock rate of the beatmap.
     */
    constructor(object: PlaceableHitObject, lastObject: PlaceableHitObject | null, lastLastObject: PlaceableHitObject | null, difficultyHitObjects: readonly DifficultyHitObject[], clockRate: number, index: number);
    /**
     * Computes the properties of this hitobject.
     *
     * @param clockRate The clock rate of the beatmap.
     * @param hitObjects The hitobjects in the beatmap.
     */
    computeProperties(clockRate: number, hitObjects: readonly PlaceableHitObject[]): void;
    /**
     * Gets the difficulty hitobject at a specific index with respect to the current
     * difficulty hitobject's index.
     *
     * Will return `null` if the index is out of range.
     *
     * @param backwardsIndex The index to move backwards for.
     * @returns The difficulty hitobject at the index with respect to the current
     * difficulty hitobject's index, `null` if the index is out of range.
     */
    previous(backwardsIndex: number): this | null;
    /**
     * Gets the difficulty hitobject at a specific index with respect to the current
     * difficulty hitobject's index.
     *
     * Will return `null` if the index is out of range.
     *
     * @param forwardsIndex The index to move forwards for.
     * @returns The difficulty hitobject at the index with respect to the current
     * difficulty hitobject's index, `null` if the index is out of range.
     */
    next(forwardsIndex: number): this | null;
    /**
     * Calculates the opacity of the hitobject at a given time.
     *
     * @param time The time to calculate the hitobject's opacity at.
     * @param mods The mods used.
     * @returns The opacity of the hitobject at the given time.
     */
    opacityAt(time: number, mods: ModMap): number;
    /**
     * How possible is it to doubletap this object together with the next one and get perfect
     * judgement in range from 0 to 1.
     *
     * A value closer to 1 indicates a higher possibility.
     */
    get doubletapness(): number;
    protected abstract get scalingFactor(): number;
    protected setDistances(clockRate: number): void;
    private calculateSliderCursorPosition;
    private getEndCursorPosition;
}

/**
 * A bare minimal abstract skill for fully custom skill implementations.
 *
 * This class should be considered a "processing" class and not persisted.
 */
declare abstract class Skill {
    /**
     * The mods that this skill processes.
     */
    protected readonly mods: ModMap;
    constructor(mods: ModMap);
    /**
     * Processes a hitobject.
     *
     * @param current The hitobject to process.
     */
    abstract process(current: DifficultyHitObject): void;
    /**
     * Returns the calculated difficulty value representing all hitobjects that have been processed up to this point.
     */
    abstract difficultyValue(): number;
}

/**
 * Represents the strain peaks of various calculated difficulties.
 */
interface StrainPeaks {
    /**
     * The strain peaks of aim difficulty if sliders are considered.
     */
    aimWithSliders: number[];
    /**
     * The strain peaks of aim difficulty if sliders are not considered.
     */
    aimWithoutSliders: number[];
    /**
     * The strain peaks of speed difficulty.
     */
    speed: number[];
    /**
     * The strain peaks of flashlight difficulty.
     */
    flashlight: number[];
}

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
declare abstract class StrainSkill extends Skill {
    /**
     * Strain peaks are stored here.
     */
    readonly strainPeaks: number[];
    /**
     * The number of sections with the highest strains, which the peak strain reductions will apply to.
     * This is done in order to decrease their impact on the overall difficulty of the map for this skill.
     */
    protected abstract readonly reducedSectionCount: number;
    /**
     * The baseline multiplier applied to the section with the biggest strain.
     */
    protected abstract readonly reducedSectionBaseline: number;
    /**
     * Determines how quickly strain decays for the given skill.
     *
     * For example, a value of 0.15 indicates that strain decays to 15% of its original value in one second.
     */
    protected abstract readonly strainDecayBase: number;
    protected readonly _objectStrains: number[];
    protected difficulty: number;
    /**
     * The strains of hitobjects.
     */
    get objectStrains(): readonly number[];
    private readonly sectionLength;
    private currentStrain;
    private currentSectionPeak;
    private currentSectionEnd;
    process(current: DifficultyHitObject): void;
    /**
     * Saves the current peak strain level to the list of strain peaks, which will be used to calculate an overall difficulty.
     */
    saveCurrentPeak(): void;
    /**
     * Returns the number of strains weighed against the top strain.
     *
     * The result is scaled by clock rate as it affects the total number of strains.
     */
    countDifficultStrains(): number;
    /**
     * Calculates strain decay for a specified time frame.
     *
     * @param ms The time frame to calculate.
     */
    protected strainDecay(ms: number): number;
    /**
     * Calculates the starting time of a strain section at an object.
     *
     * @param current The object at which the strain section starts.
     * @returns The start time of the strain section.
     */
    protected calculateCurrentSectionStart(current: DifficultyHitObject): number;
    /**
     * Calculates the strain value at a hitobject.
     *
     * @param current The hitobject to calculate.
     */
    protected abstract strainValueAt(current: DifficultyHitObject): number;
    /**
     * Saves the current strain to a hitobject.
     */
    protected abstract saveToHitObject(current: DifficultyHitObject): void;
    /**
     * Retrieves the peak strain at a point in time.
     *
     * @param time The time to retrieve the peak strain at.
     * @param current The current hit object.
     * @returns The peak strain.
     */
    protected abstract calculateInitialStrain(time: number, current: DifficultyHitObject): number;
    /**
     * Sets the initial strain level for a new section.
     *
     * @param time The beginning of the new section in milliseconds.
     * @param current The current hitobject.
     */
    private startNewSectionFrom;
}

/**
 * The base of a difficulty calculator.
 */
declare abstract class DifficultyCalculator<TBeatmap extends PlayableBeatmap, THitObject extends DifficultyHitObject, TAttributes extends DifficultyAttributes> {
    protected abstract readonly difficultyMultiplier: number;
    /**
     * `Mod`s that adjust the difficulty of a beatmap.
     */
    protected readonly difficultyAdjustmentMods: Set<typeof Mod>;
    /**
     * Retains `Mod`s that adjust a beatmap's difficulty from the specified mods.
     *
     * @param mods The mods to retain the difficulty adjustment mods from.
     * @returns The retained difficulty adjustment mods.
     */
    abstract retainDifficultyAdjustmentMods(mods: Mod[]): Mod[];
    /**
     * Calculates the difficulty of a `PlayableBeatmap`.
     *
     * @param beatmap The `PlayableBeatmap` whose difficulty is to be calculated.
     * @returns A `DifficultyAttributes` object describing the difficulty of the `Beatmap`.
     */
    calculate(beatmap: TBeatmap): TAttributes;
    /**
     * Calculates the difficulty of a `Beatmap` with specific `Mod`s.
     *
     * @param beatmap The `Beatmap` whose difficulty is to be calculated.
     * @param mods The `Mod`s to apply to the beatmap. Defaults to No Mod.
     * @returns A `DifficultyAttributes` object describing the difficulty of the `Beatmap`.
     */
    calculate(beatmap: Beatmap, mods?: ModMap): TAttributes;
    /**
     * Obtains the strain peaks of a `PlayableBeatmap`.
     *
     * @param beatmap The `PlayableBeatmap` whose strain peaks are to be calculated.
     * @returns The strain peaks of the `PlayableBeatmap`.
     */
    calculateStrainPeaks(beatmap: TBeatmap): StrainPeaks;
    /**
     * Obtains the strain peaks of a `Beatmap` with specific `Mod`s.
     *
     * @param beatmap The `Beatmap` whose strain peaks are to be calculated.
     * @param mods The `Mod`s to apply to the beatmap. Defaults to No Mod.
     * @returns The strain peaks of the `Beatmap`.
     */
    calculateStrainPeaks(beatmap: Beatmap, mods?: ModMap): StrainPeaks;
    /**
     * Creates the `Skill`s to calculate the difficulty of a `PlayableBeatmap`.
     *
     * @param beatmap The `PlayableBeatmap` whose difficulty will be calculated.
     * @return The `Skill`s.
     */
    protected abstract createSkills(beatmap: TBeatmap): Skill[];
    /**
     * Creates the `Skill`s to obtain the strain peaks of a `PlayableBeatmap`.
     *
     * @param beatmap
     */
    protected abstract createStrainPeakSkills(beatmap: TBeatmap): StrainSkill[];
    /**
     * Creates difficulty hitobjects for this calculator.
     *
     * @param beatmap The beatmap to generate difficulty hitobjects from.
     * @returns The generated difficulty hitobjects.
     */
    protected abstract createDifficultyHitObjects(beatmap: TBeatmap): THitObject[];
    /**
     * Creates a `DifficultyAttributes` object to describe a `PlayableBeatmap`'s difficulty.
     *
     * @param beatmap The `PlayableBeatmap` whose difficulty was calculated.
     * @param skills The `Skill`s which processed the `PlayableBeatmap`.
     * @param objects The `DifficultyHitObject`s which were processed.
     * @returns The `DifficultyAttributes` object.
     */
    protected abstract createDifficultyAttributes(beatmap: TBeatmap, skills: Skill[], objects: THitObject[]): TAttributes;
    /**
     * Constructs a `PlayableBeatmap` from a `Beatmap` with specific `Mod`s.
     *
     * @param beatmap The `Beatmap` to create a `PlayableBeatmap` from.
     * @param mods The `Mod`s to apply to the `Beatmap`.
     * @returns The `PlayableBeatmap`.
     */
    protected abstract createPlayableBeatmap(beatmap: Beatmap, mods?: ModMap): TBeatmap;
    /**
     * Calculates the base rating of a `Skill`.
     *
     * @param skill The `Skill` to calculate the rating of.
     * @returns The rating of the `Skill`.
     */
    protected calculateRating(skill: Skill): number;
    /**
     * Calculates the base performance value of a difficulty rating.
     *
     * @param rating The difficulty rating.
     */
    protected basePerformanceValue(rating: number): number;
}

/**
 * Represents a slider that is considered difficult.
 *
 * This structure is a part of difficulty attributes and can be cached.
 */
interface DifficultSlider {
    /**
     * The index of the slider in the beatmap.
     */
    readonly index: number;
    /**
     * The difficulty rating of this slider compared to other sliders, based on the velocity of the slider.
     *
     * A value closer to 1 indicates that this slider is more difficult compared to most sliders.
     *
     * A value closer to 0 indicates that this slider is easier compared to most sliders.
     */
    readonly difficultyRating: number;
}

/**
 * Represents an osu!droid hit object with difficulty calculation values.
 */
declare class DroidDifficultyHitObject extends DifficultyHitObject {
    /**
     * The tap strain generated by the hitobject.
     */
    tapStrain: number;
    /**
     * The tap strain generated by the hitobject if `strainTime` isn't modified by
     * OD. This is used in three-finger detection.
     */
    originalTapStrain: number;
    /**
     * The rhythm strain generated by the hitobject.
     */
    rhythmStrain: number;
    /**
     * The flashlight strain generated by the hitobject if sliders are considered.
     */
    flashlightStrainWithSliders: number;
    /**
     * The flashlight strain generated by the hitobject if sliders are not considered.
     */
    flashlightStrainWithoutSliders: number;
    /**
     * The visual strain generated by the hitobject if sliders are considered.
     */
    visualStrainWithSliders: number;
    /**
     * The visual strain generated by the hitobject if sliders are not considered.
     */
    visualStrainWithoutSliders: number;
    /**
     * The note density of the hitobject.
     */
    noteDensity: number;
    /**
     * The overlapping factor of the hitobject.
     *
     * This is used to scale visual skill.
     */
    overlappingFactor: number;
    /**
     * Adjusted preempt time of the hitobject, taking speed multiplier into account.
     */
    readonly timePreempt: number;
    private readonly radiusBuffThreshold;
    protected readonly mode = Modes.droid;
    protected readonly maximumSliderRadius: number;
    protected get scalingFactor(): number;
    /**
     * Note: You **must** call `computeProperties` at some point due to how TypeScript handles
     * overridden properties (see [this](https://github.com/microsoft/TypeScript/issues/1617) GitHub issue).
     *
     * @param object The underlying hitobject.
     * @param lastObject The hitobject before this hitobject.
     * @param lastLastObject The hitobject before the last hitobject.
     * @param difficultyHitObjects All difficulty hitobjects in the processed beatmap.
     * @param clockRate The clock rate of the beatmap.
     */
    constructor(object: PlaceableHitObject, lastObject: PlaceableHitObject | null, lastLastObject: PlaceableHitObject | null, difficultyHitObjects: readonly DifficultyHitObject[], clockRate: number, index: number);
    computeProperties(clockRate: number, hitObjects: readonly PlaceableHitObject[]): void;
    opacityAt(time: number, mods: ModMap): number;
    previous(backwardsIndex: number): this | null;
    next(forwardsIndex: number): this | null;
    /**
     * Determines whether this hitobject is considered overlapping with the hitobject before it.
     *
     * Keep in mind that "overlapping" in this case is overlapping to the point where both hitobjects
     * can be hit with just a single tap in osu!droid.
     *
     * In the case of sliders, it is considered overlapping if all nested hitobjects can be hit with
     * one aim motion.
     *
     * @param considerDistance Whether to consider the distance between both hitobjects.
     * @returns Whether the hitobject is considered overlapping.
     */
    isOverlapping(considerDistance: boolean): boolean;
    private setVisuals;
    private applyToOverlappingFactor;
}

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
declare abstract class DroidSkill extends StrainSkill {
    /**
     * The bonus multiplier that is given for a sequence of notes of equal difficulty.
     */
    protected abstract readonly starsPerDouble: number;
    process(current: DifficultyHitObject): void;
    difficultyValue(): number;
    /**
     * Gets the strain of a hitobject.
     *
     * @param current The hitobject to get the strain from.
     * @returns The strain of the hitobject.
     */
    protected abstract getObjectStrain(current: DifficultyHitObject): number;
    protected calculateCurrentSectionStart(current: DifficultyHitObject): number;
}

/**
 * Represents the skill required to correctly aim at every object in the map with a uniform CircleSize and normalized distances.
 */
declare class DroidAim extends DroidSkill {
    protected readonly strainDecayBase = 0.15;
    protected readonly reducedSectionCount = 10;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly starsPerDouble = 1.05;
    private readonly skillMultiplier;
    private currentAimStrain;
    private readonly sliderStrains;
    readonly withSliders: boolean;
    constructor(mods: ModMap, withSliders: boolean);
    /**
     * Obtains the amount of sliders that are considered difficult in terms of relative strain.
     */
    countDifficultSliders(): number;
    protected strainValueAt(current: DroidDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: DroidDifficultyHitObject): number;
    protected getObjectStrain(): number;
    /**
     * @param current The hitobject to save to.
     */
    protected saveToHitObject(current: DroidDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!droid Aim skill.
 */
declare abstract class DroidAimEvaluator {
    private static readonly wideAngleMultiplier;
    private static readonly acuteAngleMultiplier;
    private static readonly sliderMultiplier;
    private static readonly velocityChangeMultiplier;
    private static readonly wiggleMultiplier;
    private static readonly singleSpacingThreshold;
    private static readonly minSpeedBonus;
    /**
     * Evaluates the difficulty of aiming the current object, based on:
     *
     * - cursor velocity to the current object,
     * - angle difficulty,
     * - sharp velocity increases,
     * - and slider difficulty.
     *
     * @param current The current object.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current: DroidDifficultyHitObject, withSliders: boolean): number;
    /**
     * Calculates the snap aim strain of a hitobject.
     */
    private static snapAimStrainOf;
    /**
     * Calculates the flow aim strain of a hitobject.
     */
    private static flowAimStrainOf;
    private static calculateWideAngleBonus;
    private static calculateAcuteAngleBonus;
}

/**
 * Holds data that can be used to calculate osu!droid performance points.
 */
interface IDroidDifficultyAttributes extends IDifficultyAttributes {
    /**
     * The difficulty corresponding to the tap skill.
     */
    tapDifficulty: number;
    /**
     * The difficulty corresponding to the rhythm skill.
     */
    rhythmDifficulty: number;
    /**
     * The difficulty corresponding to the visual skill.
     */
    visualDifficulty: number;
    /**
     * The amount of strains that are considered difficult with respect to the tap skill.
     */
    tapDifficultStrainCount: number;
    /**
     * The amount of strains that are considered difficult with respect to the flashlight skill.
     */
    flashlightDifficultStrainCount: number;
    /**
     * The amount of strains that are considered difficult with respect to the visual skill.
     */
    visualDifficultStrainCount: number;
    /**
     * The average delta time of speed objects.
     */
    averageSpeedDeltaTime: number;
    /**
     * Describes how much of tap difficulty is contributed by notes that are "vibroable".
     *
     * A value closer to 1 indicates most of tap difficulty is contributed by notes that are not "vibroable".
     *
     * A value closer to 0 indicates most of tap difficulty is contributed by notes that are "vibroable".
     */
    vibroFactor: number;
}

/**
 * Holds data that can be used to calculate osu!droid performance points.
 */
declare class DroidDifficultyAttributes extends DifficultyAttributes implements IDroidDifficultyAttributes {
    tapDifficulty: number;
    rhythmDifficulty: number;
    visualDifficulty: number;
    tapDifficultStrainCount: number;
    flashlightDifficultStrainCount: number;
    visualDifficultStrainCount: number;
    averageSpeedDeltaTime: number;
    vibroFactor: number;
    constructor(cacheableAttributes?: CacheableDifficultyAttributes<IDroidDifficultyAttributes>);
    toString(): string;
}

/**
 * Represents a beatmap section at which the strains of objects are considerably high.
 */
interface HighStrainSection {
    /**
     * The index of the first object in this section with respect to the full beatmap.
     */
    readonly firstObjectIndex: number;
    /**
     * The index of the last object in this section with respect to the full beatmap.
     */
    readonly lastObjectIndex: number;
    /**
     * The summed strain of this section.
     */
    readonly sumStrain: number;
}

/**
 * Holds data that can be used to calculate osu!droid performance points as well
 * as doing some analysis using the replay of a score.
 */
interface IExtendedDroidDifficultyAttributes extends IDroidDifficultyAttributes {
    /**
     * The mode of the difficulty calculation.
     */
    mode: "live";
    /**
     * Possible sections at which the player can use three fingers on.
     */
    possibleThreeFingeredSections: HighStrainSection[];
    /**
     * Sliders that are considered difficult.
     */
    difficultSliders: DifficultSlider[];
    /**
     * The number of clickable objects weighted by difficulty.
     *
     * Related to aim difficulty.
     */
    aimNoteCount: number;
    /**
     * Describes how much of flashlight difficulty is contributed to by hitcircles or sliders.
     *
     * A value closer to 1 indicates most of flashlight difficulty is contributed by hitcircles.
     *
     * A value closer to 0 indicates most of flashlight difficulty is contributed by sliders.
     */
    flashlightSliderFactor: number;
    /**
     * Describes how much of visual difficulty is contributed to by hitcircles or sliders.
     *
     * A value closer to 1 indicates most of visual difficulty is contributed by hitcircles.
     *
     * A value closer to 0 indicates most of visual difficulty is contributed by sliders.
     */
    visualSliderFactor: number;
}

/**
 * Holds data that can be used to calculate osu!droid performance points as well
 * as doing some analysis using the replay of a score.
 */
declare class ExtendedDroidDifficultyAttributes extends DroidDifficultyAttributes implements IExtendedDroidDifficultyAttributes {
    mode: "live";
    possibleThreeFingeredSections: HighStrainSection[];
    difficultSliders: DifficultSlider[];
    aimNoteCount: number;
    flashlightSliderFactor: number;
    visualSliderFactor: number;
    constructor(cacheableAttributes?: CacheableDifficultyAttributes<IExtendedDroidDifficultyAttributes>);
}

/**
 * A difficulty calculator for osu!droid gamemode.
 */
declare class DroidDifficultyCalculator extends DifficultyCalculator<DroidPlayableBeatmap, DroidDifficultyHitObject, ExtendedDroidDifficultyAttributes> {
    /**
     * The strain threshold to start detecting for possible three-fingered section.
     *
     * Increasing this number will result in less sections being flagged.
     */
    static readonly threeFingerStrainThreshold = 175;
    protected readonly difficultyMultiplier = 0.18;
    constructor();
    retainDifficultyAdjustmentMods(mods: Mod[]): Mod[];
    protected createDifficultyAttributes(beatmap: DroidPlayableBeatmap, skills: Skill[], objects: DroidDifficultyHitObject[]): ExtendedDroidDifficultyAttributes;
    protected createPlayableBeatmap(beatmap: Beatmap, mods?: ModMap): DroidPlayableBeatmap;
    protected createDifficultyHitObjects(beatmap: DroidPlayableBeatmap): DroidDifficultyHitObject[];
    protected createSkills(beatmap: DroidPlayableBeatmap): DroidSkill[];
    protected createStrainPeakSkills(beatmap: DroidPlayableBeatmap): StrainSkill[];
    private populateAimAttributes;
    private populateTapAttributes;
    private populateRhythmAttributes;
    private populateFlashlightAttributes;
    private populateVisualAttributes;
}

/**
 * Represents the skill required to memorize and hit every object in a beatmap with the Flashlight mod enabled.
 */
declare class DroidFlashlight extends DroidSkill {
    protected readonly strainDecayBase = 0.15;
    protected readonly reducedSectionCount = 0;
    protected readonly reducedSectionBaseline = 1;
    protected readonly starsPerDouble = 1.06;
    private readonly skillMultiplier;
    private currentFlashlightStrain;
    readonly withSliders: boolean;
    constructor(mods: ModMap, withSliders: boolean);
    protected strainValueAt(current: DroidDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: DifficultyHitObject): number;
    protected getObjectStrain(): number;
    protected saveToHitObject(current: DroidDifficultyHitObject): void;
    difficultyValue(): number;
}

/**
 * An evaluator for calculating osu!droid Flashlight skill.
 */
declare abstract class DroidFlashlightEvaluator {
    private static readonly maxOpacityBonus;
    private static readonly hiddenBonus;
    private static readonly traceableCircleBonus;
    private static readonly traceableObjectBonus;
    private static readonly minVelocity;
    private static readonly sliderMultiplier;
    private static readonly minAngleMultiplier;
    /**
     * Evaluates the difficulty of memorizing and hitting the current object, based on:
     *
     * - distance between a number of previous objects and the current object,
     * - the visual opacity of the current object,
     * - the angle made by the current object,
     * - length and speed of the current object (for sliders),
     * - and whether Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current: DroidDifficultyHitObject, mods: ModMap, withSliders: boolean): number;
}

/**
 * Represents options for performance calculation.
 */
interface PerformanceCalculationOptions {
    /**
     * The maximum combo achieved in the score.
     */
    combo?: number;
    /**
     * The accuracy achieved in the score.
     */
    accPercent?: Accuracy | number;
    /**
     * The amount of misses achieved in the score.
     */
    miss?: number;
    /**
     * The tap penalty to apply for penalized scores. Only used when using `DroidPerformanceCalculator`.
     */
    tapPenalty?: number;
    /**
     * The aim slider cheese penalty to apply for penalized scores. Only used when using `DroidPerformanceCalculator`.
     */
    aimSliderCheesePenalty?: number;
    /**
     * The flashlight slider cheese penalty to apply for penalized scores. Only used when using `DroidPerformanceCalculator`.
     */
    flashlightSliderCheesePenalty?: number;
    /**
     * The visual slider cheese penalty to apply for penalized scores. Only used when using `DroidPerformanceCalculator`.
     */
    visualSliderCheesePenalty?: number;
}

/**
 * The base class of performance calculators.
 */
declare abstract class PerformanceCalculator<T extends IDifficultyAttributes> {
    /**
     * The overall performance value.
     */
    total: number;
    /**
     * The calculated accuracy.
     */
    computedAccuracy: Accuracy;
    /**
     * The difficulty attributes that is being calculated.
     */
    readonly difficultyAttributes: T | CacheableDifficultyAttributes<T>;
    /**
     * The mods that were used.
     */
    protected readonly mods: ModMap;
    /**
     * The global multiplier to be applied to the final performance value.
     *
     * This is being adjusted to keep the final value scaled around what it used to be when changing things.
     */
    protected abstract finalMultiplier: number;
    /**
     * The gamemode to calculate for.
     */
    protected abstract readonly mode: Modes;
    /**
     * The amount of misses that are filtered out from sliderbreaks.
     */
    protected effectiveMissCount: number;
    /**
     * Nerf factor used for nerfing beatmaps with very likely dropped sliderends.
     */
    protected sliderNerfFactor: number;
    /**
     * @param difficultyAttributes The difficulty attributes to calculate.
     */
    constructor(difficultyAttributes: T | CacheableDifficultyAttributes<T>);
    /**
     * Calculates the performance points of the beatmap.
     *
     * @param options Options for performance calculation.
     * @returns The current instance.
     */
    calculate(options?: PerformanceCalculationOptions): this;
    /**
     * Returns a string representative of the class.
     */
    abstract toString(): string;
    /**
     * Calculates all values that will be used for calculating the total
     * performance value of the beatmap and stores them in this instance.
     */
    protected abstract calculateValues(): void;
    /**
     * Calculates the total performance value of the beatmap and stores it in this instance.
     */
    protected abstract calculateTotalValue(): number;
    /**
     * The total hits that can be done in the beatmap.
     */
    protected get totalHits(): number;
    /**
     * The total hits that were successfully done.
     */
    protected get totalSuccessfulHits(): number;
    /**
     * The total of imperfect hits (100s, 50s, misses).
     */
    protected get totalImperfectHits(): number;
    /**
     * Calculates the base performance value of a star rating.
     */
    protected baseValue(stars: number): number;
    /**
     * Processes given options for usage in performance calculation.
     *
     * @param options Options for performance calculation.
     */
    protected handleOptions(options?: PerformanceCalculationOptions): void;
    /**
     * Calculates a strain-based miss penalty.
     *
     * Strain-based miss penalty assumes that a player will miss on the hardest parts of a map,
     * so we use the amount of relatively difficult sections to adjust miss penalty
     * to make it more punishing on maps with lower amount of hard sections.
     */
    protected calculateStrainBasedMissPenalty(difficultStrainCount: number): number;
    /**
     * Calculates the amount of misses + sliderbreaks from combo.
     */
    private calculateEffectiveMissCount;
    /**
     * Determines whether an attribute is a cacheable attribute.
     *
     * @param attributes The attributes to check.
     * @returns Whether the attributes are cacheable.
     */
    private isCacheableAttribute;
}

/**
 * A performance points calculator that calculates performance points for osu!droid gamemode.
 */
declare class DroidPerformanceCalculator extends PerformanceCalculator<IDroidDifficultyAttributes> {
    /**
     * The aim performance value.
     */
    aim: number;
    /**
     * The tap performance value.
     */
    tap: number;
    /**
     * The accuracy performance value.
     */
    accuracy: number;
    /**
     * The flashlight performance value.
     */
    flashlight: number;
    /**
     * The visual performance value.
     */
    visual: number;
    /**
     * The penalty used to penalize the tap performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get tapPenalty(): number;
    /**
     * The estimated deviation of the score.
     */
    get deviation(): number;
    /**
     * The estimated tap deviation of the score.
     */
    get tapDeviation(): number;
    /**
     * The penalty used to penalize the aim performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get aimSliderCheesePenalty(): number;
    /**
     * The penalty used to penalize the flashlight performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get flashlightSliderCheesePenalty(): number;
    /**
     * The penalty used to penalize the visual performance value.
     *
     * Can be properly obtained by analyzing the replay associated with the score.
     */
    get visualSliderCheesePenalty(): number;
    protected finalMultiplier: number;
    protected readonly mode = Modes.droid;
    private _aimSliderCheesePenalty;
    private _flashlightSliderCheesePenalty;
    private _visualSliderCheesePenalty;
    private _tapPenalty;
    private _deviation;
    private _tapDeviation;
    /**
     * Applies a tap penalty value to this calculator.
     *
     * The tap and total performance value will be recalculated afterwards.
     *
     * @param value The tap penalty value. Must be greater than or equal to 1.
     */
    applyTapPenalty(value: number): void;
    /**
     * Applies an aim slider cheese penalty value to this calculator.
     *
     * The aim and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between than 0 and 1.
     */
    applyAimSliderCheesePenalty(value: number): void;
    /**
     * Applies a flashlight slider cheese penalty value to this calculator.
     *
     * The flashlight and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between 0 and 1.
     */
    applyFlashlightSliderCheesePenalty(value: number): void;
    /**
     * Applies a visual slider cheese penalty value to this calculator.
     *
     * The visual and total performance value will be recalculated afterwards.
     *
     * @param value The slider cheese penalty value. Must be between 0 and 1.
     */
    applyVisualSliderCheesePenalty(value: number): void;
    protected calculateValues(): void;
    protected calculateTotalValue(): number;
    protected handleOptions(options?: PerformanceCalculationOptions): void;
    /**
     * Calculates the aim performance value of the beatmap.
     */
    private calculateAimValue;
    /**
     * Calculates the tap performance value of the beatmap.
     */
    private calculateTapValue;
    /**
     * Calculates the accuracy performance value of the beatmap.
     */
    private calculateAccuracyValue;
    /**
     * Calculates the flashlight performance value of the beatmap.
     */
    private calculateFlashlightValue;
    /**
     * Calculates the visual performance value of the beatmap.
     */
    private calculateVisualValue;
    /**
     * The object-based proportional miss penalty.
     */
    private get proportionalMissPenalty();
    /**
     * Calculates the object-based length scaling based on the deviation of a player for a full
     * combo in this beatmap, taking retries into account.
     *
     * @param objectCount The amount of objects to be considered. Defaults to the amount of
     * objects in this beatmap.
     * @param punishForMemorization Whether to punish the deviation for memorization. Defaults to `false`.
     */
    private calculateDeviationBasedLengthScaling;
    /**
     * Estimates the player's tap deviation based on the OD, number of circles and sliders,
     * and number of 300s, 100s, 50s, and misses, assuming the player's mean hit error is 0.
     *
     * The estimation is consistent in that two SS scores on the same map
     * with the same settings will always return the same deviation.
     *
     * Sliders are treated as circles with a 50 hit window.
     *
     * Misses are ignored because they are usually due to misaiming, and 50s
     * are grouped with 100s since they are usually due to misreading.
     *
     * Inaccuracies are capped to the number of circles in the map.
     */
    private calculateDeviation;
    /**
     * Does the same as {@link calculateDeviation}, but only for notes and inaccuracies that are relevant to tap difficulty.
     *
     * Treats all difficult speed notes as circles, so this method can sometimes return a lower deviation than {@link calculateDeviation}.
     * This is fine though, since this method is only used to scale tap pp.
     */
    private calculateTapDeviation;
    private getConvertedHitWindow;
    toString(): string;
}

/**
 * Represents the skill required to properly follow a beatmap's rhythm.
 */
declare class DroidRhythm extends DroidSkill {
    protected readonly reducedSectionCount = 5;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly strainDecayBase = 0.3;
    protected readonly starsPerDouble = 1.75;
    private readonly useSliderAccuracy;
    private currentRhythmStrain;
    private currentRhythmMultiplier;
    constructor(mods: ModMap);
    protected strainValueAt(current: DroidDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: DroidDifficultyHitObject): number;
    protected getObjectStrain(): number;
    protected saveToHitObject(current: DroidDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!droid Rhythm skill.
 */
declare abstract class DroidRhythmEvaluator {
    private static readonly historyTimeMax;
    private static readonly historyObjectsMax;
    private static readonly rhythmOverallMultiplier;
    private static readonly rhythmRatioMultiplier;
    /**
     * Calculates a rhythm multiplier for the difficulty of the tap associated
     * with historic data of the current object.
     *
     * @param current The current object.
     * @param useSliderAccuracy Whether to use slider accuracy.
     */
    static evaluateDifficultyOf(current: DroidDifficultyHitObject, useSliderAccuracy: boolean): number;
}

/**
 * Represents the skill required to press keys or tap with regards to keeping up with the speed at which objects need to be hit.
 */
declare class DroidTap extends DroidSkill {
    protected readonly reducedSectionCount = 10;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly strainDecayBase = 0.3;
    protected readonly starsPerDouble = 1.1;
    private currentTapStrain;
    private currentRhythmMultiplier;
    private readonly skillMultiplier;
    private readonly _objectDeltaTimes;
    /**
     * The delta time of hitobjects.
     */
    get objectDeltaTimes(): readonly number[];
    readonly considerCheesability: boolean;
    private readonly strainTimeCap?;
    constructor(mods: ModMap, considerCheesability: boolean, strainTimeCap?: number);
    /**
     * The amount of notes that are relevant to the difficulty.
     */
    relevantNoteCount(): number;
    /**
     * The delta time relevant to the difficulty.
     */
    relevantDeltaTime(): number;
    protected strainValueAt(current: DroidDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: DroidDifficultyHitObject): number;
    protected getObjectStrain(): number;
    /**
     * @param current The hitobject to save to.
     */
    protected saveToHitObject(current: DroidDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!droid tap skill.
 */
declare abstract class DroidTapEvaluator {
    private static readonly minSpeedBonus;
    /**
     * Evaluates the difficulty of tapping the current object, based on:
     *
     * - time between pressing the previous and current object,
     * - distance between those objects,
     * - how easily they can be cheesed,
     * - and the strain time cap.
     *
     * @param current The current object.
     * @param greatWindow The great hit window of the current object.
     * @param considerCheesability Whether to consider cheesability.
     * @param strainTimeCap The strain time to cap the object's strain time to.
     */
    static evaluateDifficultyOf(current: DroidDifficultyHitObject, considerCheesability: boolean, strainTimeCap?: number): number;
}

/**
 * Represents the skill required to read every object in the map.
 */
declare class DroidVisual extends DroidSkill {
    protected readonly starsPerDouble = 1.025;
    protected readonly reducedSectionCount = 10;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly strainDecayBase = 0.1;
    private currentVisualStrain;
    private currentRhythmMultiplier;
    private readonly skillMultiplier;
    readonly withSliders: boolean;
    constructor(mods: ModMap, withSliders: boolean);
    protected strainValueAt(current: DroidDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: DroidDifficultyHitObject): number;
    protected getObjectStrain(): number;
    protected saveToHitObject(current: DroidDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!droid visual skill.
 */
declare abstract class DroidVisualEvaluator {
    /**
     * Evaluates the difficulty of reading the current object, based on:
     *
     * - note density of the current object,
     * - overlapping factor of the current object,
     * - the preempt time of the current object,
     * - the visual opacity of the current object,
     * - the velocity of the current object if it's a slider,
     * - past objects' velocity if they are sliders,
     * - and whether the Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current: DroidDifficultyHitObject, mods: ModMap, withSliders: boolean): number;
}

/**
 * Holds data that can be used to calculate osu!standard performance points.
 */
interface IOsuDifficultyAttributes extends IDifficultyAttributes {
    /**
     * The perceived approach rate inclusive of rate-adjusting mods (DT/HT/etc).
     *
     * Rate-adjusting mods don't directly affect the approach rate difficulty value, but have a perceived effect as a result of adjusting audio timing.
     */
    approachRate: number;
    /**
     * The difficulty corresponding to the speed skill.
     */
    speedDifficulty: number;
    /**
     * The amount of strains that are considered difficult with respect to the speed skill.
     */
    speedDifficultStrainCount: number;
}

/**
 * Represents an osu!standard hit object with difficulty calculation values.
 */
declare class OsuDifficultyHitObject extends DifficultyHitObject {
    /**
     * The speed strain generated by the hitobject.
     */
    speedStrain: number;
    /**
     * The flashlight strain generated by this hitobject.
     */
    flashlightStrain: number;
    private readonly radiusBuffThreshold;
    protected readonly mode = Modes.osu;
    protected get scalingFactor(): number;
}

/**
 * Used to processes strain values of difficulty hitobjects, keep track of strain levels caused by the processed objects
 * and to calculate a final difficulty value representing the difficulty of hitting all the processed objects.
 */
declare abstract class OsuSkill extends StrainSkill {
    /**
     * The weight by which each strain value decays.
     */
    protected abstract readonly decayWeight: number;
    difficultyValue(): number;
}

/**
 * Represents the skill required to correctly aim at every object in the map with a uniform CircleSize and normalized distances.
 */
declare class OsuAim extends OsuSkill {
    protected readonly strainDecayBase = 0.15;
    protected readonly reducedSectionCount = 10;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly decayWeight = 0.9;
    private currentAimStrain;
    private readonly skillMultiplier;
    private readonly sliderStrains;
    readonly withSliders: boolean;
    constructor(mods: ModMap, withSliders: boolean);
    /**
     * Obtains the amount of sliders that are considered difficult in terms of relative strain.
     */
    countDifficultSliders(): number;
    protected strainValueAt(current: OsuDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: OsuDifficultyHitObject): number;
    /**
     * @param current The hitobject to save to.
     */
    protected saveToHitObject(current: OsuDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!standard Aim skill.
 */
declare abstract class OsuAimEvaluator {
    private static readonly wideAngleMultiplier;
    private static readonly acuteAngleMultiplier;
    private static readonly sliderMultiplier;
    private static readonly velocityChangeMultiplier;
    private static readonly wiggleMultiplier;
    /**
     * Evaluates the difficulty of aiming the current object, based on:
     *
     * - cursor velocity to the current object,
     * - angle difficulty,
     * - sharp velocity increases,
     * - and slider difficulty.
     *
     * @param current The current object.
     * @param withSliders Whether to take slider difficulty into account.
     */
    static evaluateDifficultyOf(current: OsuDifficultyHitObject, withSliders: boolean): number;
    private static calculateWideAngleBonus;
    private static calculateAcuteAngleBonus;
}

/**
 * Holds data that can be used to calculate osu!standard performance points.
 */
declare class OsuDifficultyAttributes extends DifficultyAttributes implements IOsuDifficultyAttributes {
    approachRate: number;
    speedDifficulty: number;
    speedDifficultStrainCount: number;
    constructor(cacheableAttributes?: CacheableDifficultyAttributes<IOsuDifficultyAttributes>);
    toString(): string;
}

/**
 * A difficulty calculator for osu!standard gamemode.
 */
declare class OsuDifficultyCalculator extends DifficultyCalculator<OsuPlayableBeatmap, OsuDifficultyHitObject, OsuDifficultyAttributes> {
    protected readonly difficultyMultiplier = 0.0675;
    constructor();
    retainDifficultyAdjustmentMods(mods: Mod[]): Mod[];
    protected createDifficultyAttributes(beatmap: OsuPlayableBeatmap, skills: Skill[]): OsuDifficultyAttributes;
    protected createPlayableBeatmap(beatmap: Beatmap, mods?: ModMap): OsuPlayableBeatmap;
    protected createDifficultyHitObjects(beatmap: OsuPlayableBeatmap): OsuDifficultyHitObject[];
    protected createSkills(beatmap: OsuPlayableBeatmap): OsuSkill[];
    protected createStrainPeakSkills(beatmap: OsuPlayableBeatmap): StrainSkill[];
    private populateAimAttributes;
    private populateSpeedAttributes;
    private populateFlashlightAttributes;
}

/**
 * Represents the skill required to memorize and hit every object in a beatmap with the Flashlight mod enabled.
 */
declare class OsuFlashlight extends OsuSkill {
    protected readonly strainDecayBase = 0.15;
    protected readonly reducedSectionCount = 0;
    protected readonly reducedSectionBaseline = 1;
    protected readonly decayWeight = 1;
    private currentFlashlightStrain;
    private readonly skillMultiplier;
    difficultyValue(): number;
    protected strainValueAt(current: OsuDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: OsuDifficultyHitObject): number;
    protected saveToHitObject(current: OsuDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!standard Flashlight skill.
 */
declare abstract class OsuFlashlightEvaluator {
    private static readonly maxOpacityBonus;
    private static readonly hiddenBonus;
    private static readonly minVelocity;
    private static readonly sliderMultiplier;
    private static readonly minAngleMultiplier;
    /**
     * Evaluates the difficulty of memorizing and hitting the current object, based on:
     *
     * - distance between a number of previous objects and the current object,
     * - the visual opacity of the current object,
     * - the angle made by the current object,
     * - length and speed of the current object (for sliders),
     * - and whether Hidden mod is enabled.
     *
     * @param current The current object.
     * @param mods The mods used.
     */
    static evaluateDifficultyOf(current: OsuDifficultyHitObject, mods: ModMap): number;
}

/**
 * A performance points calculator that calculates performance points for osu!standard gamemode.
 */
declare class OsuPerformanceCalculator extends PerformanceCalculator<IOsuDifficultyAttributes> {
    /**
     * The aim performance value.
     */
    aim: number;
    /**
     * The speed performance value.
     */
    speed: number;
    /**
     * The accuracy performance value.
     */
    accuracy: number;
    /**
     * The flashlight performance value.
     */
    flashlight: number;
    protected finalMultiplier: number;
    protected readonly mode = Modes.osu;
    private comboPenalty;
    private speedDeviation;
    protected calculateValues(): void;
    protected calculateTotalValue(): number;
    protected handleOptions(options?: PerformanceCalculationOptions): void;
    /**
     * Calculates the aim performance value of the beatmap.
     */
    private calculateAimValue;
    /**
     * Calculates the speed performance value of the beatmap.
     */
    private calculateSpeedValue;
    /**
     * Calculates the accuracy performance value of the beatmap.
     */
    private calculateAccuracyValue;
    /**
     * Calculates the flashlight performance value of the beatmap.
     */
    private calculateFlashlightValue;
    /**
     * Estimates a player's deviation on speed notes using {@link calculateDeviation}, assuming worst-case.
     *
     * Treats all speed notes as hit circles.
     */
    private calculateSpeedDeviation;
    /**
     * Estimates the player's tap deviation based on the OD, given number of greats, oks, mehs and misses,
     * assuming the player's mean hit error is 0. The estimation is consistent in that two SS scores on the
     * same map with the same settings will always return the same deviation.
     *
     * Misses are ignored because they are usually due to misaiming.
     *
     * Greats and oks are assumed to follow a normal distribution, whereas mehs are assumed to follow a uniform distribution.
     */
    private calculateDeviation;
    /**
     * Calculates multiplier for speed to account for improper tapping based on the deviation and speed difficulty.
     *
     * [Graph](https://www.desmos.com/calculator/dmogdhzofn)
     */
    private calculateSpeedHighDeviationNerf;
    toString(): string;
}

/**
 * An evaluator for calculating osu!standard Rhythm skill.
 */
declare abstract class OsuRhythmEvaluator {
    private static readonly historyTimeMax;
    private static readonly historyObjectsMax;
    private static readonly rhythmOverallMultiplier;
    private static readonly rhythmRatioMultiplier;
    /**
     * Calculates a rhythm multiplier for the difficulty of the tap associated
     * with historic data of the current object.
     *
     * @param current The current object.
     */
    static evaluateDifficultyOf(current: OsuDifficultyHitObject): number;
}

/**
 * Represents the skill required to press keys or tap with regards to keeping up with the speed at which objects need to be hit.
 */
declare class OsuSpeed extends OsuSkill {
    protected readonly strainDecayBase = 0.3;
    protected readonly reducedSectionCount = 5;
    protected readonly reducedSectionBaseline = 0.75;
    protected readonly decayWeight = 0.9;
    private currentSpeedStrain;
    private currentRhythm;
    private readonly skillMultiplier;
    /**
     * The amount of notes that are relevant to the difficulty.
     */
    relevantNoteCount(): number;
    /**
     * @param current The hitobject to calculate.
     */
    protected strainValueAt(current: OsuDifficultyHitObject): number;
    protected calculateInitialStrain(time: number, current: OsuDifficultyHitObject): number;
    /**
     * @param current The hitobject to save to.
     */
    protected saveToHitObject(current: OsuDifficultyHitObject): void;
}

/**
 * An evaluator for calculating osu!standard speed skill.
 */
declare abstract class OsuSpeedEvaluator {
    /**
     * Spacing threshold for a single hitobject spacing.
     *
     * About 1.25 circles distance between hitobject centers.
     */
    private static readonly SINGLE_SPACING_THRESHOLD;
    private static readonly minSpeedBonus;
    private static readonly DISTANCE_MULTIPLIER;
    /**
     * Evaluates the difficulty of tapping the current object, based on:
     *
     * - time between pressing the previous and current object,
     * - distance between those objects,
     * - and how easily they can be cheesed.
     *
     * @param current The current object.
     * @param mods The mods applied.
     */
    static evaluateDifficultyOf(current: OsuDifficultyHitObject, mods: ModMap): number;
}

export { type CacheableDifficultyAttributes, type DifficultSlider, DifficultyAttributes, DifficultyCalculator, DifficultyHitObject, DroidAim, DroidAimEvaluator, DroidDifficultyAttributes, DroidDifficultyCalculator, DroidDifficultyHitObject, DroidFlashlight, DroidFlashlightEvaluator, DroidPerformanceCalculator, DroidRhythm, DroidRhythmEvaluator, DroidTap, DroidTapEvaluator, DroidVisual, DroidVisualEvaluator, ExtendedDroidDifficultyAttributes, type HighStrainSection, type IDifficultyAttributes, type IDroidDifficultyAttributes, type IExtendedDroidDifficultyAttributes, type IOsuDifficultyAttributes, OsuAim, OsuAimEvaluator, OsuDifficultyAttributes, OsuDifficultyCalculator, OsuDifficultyHitObject, OsuFlashlight, OsuFlashlightEvaluator, OsuPerformanceCalculator, OsuRhythmEvaluator, OsuSpeed, OsuSpeedEvaluator, type PerformanceCalculationOptions, PerformanceCalculator, type StrainPeaks };
