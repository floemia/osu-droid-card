import { Vector2, Accuracy, ScoreRank, ModMap, DroidPlayableBeatmap, Beatmap } from '@rian8337/osu-base';
import { IExtendedDroidDifficultyAttributes as IExtendedDroidDifficultyAttributes$1 } from '@rian8337/osu-difficulty-calculator';
import { IExtendedDroidDifficultyAttributes } from '@rian8337/osu-rebalance-difficulty-calculator';

/**
 * Movement types of a cursor in an osu!droid replay.
 *
 * The cursor movement is represented as a player's action on the screen.
 */
declare enum MovementType {
    /**
     * The player places their finger on the screen.
     */
    down = 0,
    /**
     * The player drags their finger on the screen.
     */
    move = 1,
    /**
     * The player releases their finger from the screen.
     */
    up = 2
}

/**
 * Represents a cursor's occurrence.
 */
declare class CursorOccurrence {
    /**
     * The time of this occurrence.
     */
    readonly time: number;
    /**
     * The position of the occurrence.
     */
    readonly position: Vector2;
    /**
     * The movement ID of the occurrence.
     */
    readonly id: MovementType;
    constructor(time: number, x: number, y: number, id: MovementType);
    /**
     * Returns a string representation of this `CursorOccurrence`.
     */
    toString(): string;
}

/**
 * Represents a group of cursor occurrences representing a cursor instance's
 * movement when a player places their finger on the screen.
 */
declare class CursorOccurrenceGroup {
    /**
     * The cursor occurrence of movement type `movementType.DOWN`.
     */
    get down(): CursorOccurrence;
    /**
     * The cursor occurrence of movement type `movementType.DOWN`.
     */
    set down(value: CursorOccurrence);
    /**
     * The cursor occurrences of movement type `movementType.MOVE`.
     */
    get moves(): readonly CursorOccurrence[];
    /**
     * The cursor occurrence of movement type `movementType.UP`.
     *
     * May not exist, such as when the player holds their cursor until the end of a beatmap.
     */
    get up(): CursorOccurrence | undefined;
    /**
     * The cursor occurrence of movement type `movementType.UP`.
     *
     * May not exist, such as when the player holds their cursor until the end of a beatmap.
     */
    set up(value: CursorOccurrence | undefined);
    /**
     * The time at which this cursor occurrence group starts.
     */
    get startTime(): number;
    /**
     * The time at which this cursor occurrence group ends.
     */
    get endTime(): number;
    /**
     * The duration this cursor occurrence group is active for.
     */
    get duration(): number;
    /**
     * All cursor occurrences in this group.
     *
     * This iterates all occurrences and as such should be used sparingly or stored locally.
     */
    get allOccurrences(): CursorOccurrence[];
    /**
     * The cursor occurrence of movement type `movementType.DOWN`.
     */
    private _down;
    /**
     * The cursor occurrences of movement type `movementType.MOVE`.
     */
    private _moves;
    /**
     * The cursor occurrence of movement type `movementType.UP`.
     *
     * May not exist, such as when the player holds their cursor until the end of a beatmap.
     */
    private _up?;
    constructor(down: CursorOccurrence, moves: CursorOccurrence[], up?: CursorOccurrence);
    /**
     * Determines whether this cursor occurrence group is active at the specified time.
     *
     * @param time The time.
     * @returns Whether this cursor occurrence group is active at the specified time.
     */
    isActiveAt(time: number): boolean;
    /**
     * Finds the cursor occurrence that is active at a given time.
     *
     * @param time The time.
     * @returns The cursor occurrence at the given time, `null` if not found.
     */
    cursorAt(time: number): CursorOccurrence | null;
    /**
     * Returns a string representation of this `CursorOccurrenceGroup`.
     */
    toString(): string;
}

/**
 * Contains information about a cursor instance.
 */
interface CursorInformation {
    /**
     * The movement size of the cursor instance.
     */
    size: number;
    /**
     * The time during which this cursor instance is active in milliseconds.
     */
    time: number[];
    /**
     * The x coordinates of this cursor instance in osu!pixels.
     */
    x: number[];
    /**
     * The y coordinates of this cursor instance in osu!pixels.
     */
    y: number[];
    /**
     * The hit results of this cursor instance.
     */
    id: MovementType[];
}
/**
 * Represents a cursor instance in an osu!droid replay.
 *
 * Stores cursor movement data in the form of `CursorOccurrenceGroup`s.
 *
 * This is used when analyzing replays using replay analyzer.
 */
declare class CursorData {
    /**
     * The occurrence groups of this cursor instance.
     */
    readonly occurrenceGroups: CursorOccurrenceGroup[];
    /**
     * The time at which the first occurrence of this cursor instance occurs.
     *
     * Will return `null` if there are no occurrences.
     */
    get earliestOccurrenceTime(): number | null;
    /**
     * The time at which the latest occurrence of this cursor instance occurs.
     *
     * Will return `null` if there are no occurrences.
     */
    get latestOccurrenceTime(): number | null;
    /**
     * The amount of cursor occurrences of this cursor instance.
     */
    get totalOccurrences(): number;
    /**
     * All cursor occurrences of this cursor instnace.
     *
     * This iterates all occurrence groups and as such should be used sparingly or stored locally.
     */
    get allOccurrences(): CursorOccurrence[];
    constructor(values: CursorInformation);
}

/**
 * Represents a JSON object that is exported from in-game replay exporter.
 */
interface ExportedReplayJSON<TVersion extends number, TReplayJSON extends object> {
    /**
     * The version of the exported replay.
     */
    version: TVersion;
    /**
     * Data of the exported replay.
     */
    replaydata: TReplayJSON;
}

/**
 * The structure of the exported replay JSON data for version 1.
 */
interface ExportedReplayJSONDataV1 {
    /**
     * The path towards the beatmap's `.osu` file from the song directory of the game.
     */
    filename: string;
    /**
     * The name of the player.
     */
    playername: string;
    /**
     * The name of the replay file.
     */
    replayfile: string;
    /**
     * Droid modifications that are used in the replay.
     */
    mod: string;
    /**
     * The amount of total score achieved.
     */
    score: number;
    /**
     * The maximum combo achieved.
     */
    combo: number;
    /**
     * The rank achieved in the replay.
     */
    mark: string;
    /**
     * The amount of geki hits in the replay.
     */
    h300k: number;
    /**
     * The amount of great hits in the replay.
     */
    h300: number;
    /**
     * The amount of katu hits in the replay.
     */
    h100k: number;
    /**
     * The amount of good hits in the replay.
     */
    h100: number;
    /**
     * The amount of meh hits in the replay.
     */
    h50: number;
    /**
     * The amount of misses in the replay.
     */
    misses: number;
    /**
     * Accuracy gained in the replay.
     */
    accuracy: number;
    /**
     * The epoch date at which the score was set, in milliseconds.
     */
    time: number;
    /**
     * Whether the score is a full combo (1 is `true`, 0 is `false`).
     */
    perfect: number;
}

/**
 * The structure of the exported replay JSON data for version 2.
 */
interface ExportedReplayJSONDataV2 extends Omit<ExportedReplayJSONDataV1, "perfect"> {
    /**
     * The MD5 hash of the beatmap.
     */
    beatmapMD5: string;
}

/**
 * Represents an exported replay's JSON structure for version 1.
 */
type ExportedReplayJSONV1 = ExportedReplayJSON<1, ExportedReplayJSONDataV1>;

/**
 * Represents an exported replay's JSON structure for version 2.
 */
type ExportedReplayJSONV2 = ExportedReplayJSON<2, ExportedReplayJSONDataV2>;

/**
 * The result of a hit in an osu!droid replay.
 */
declare enum HitResult {
    /**
     * Miss (0).
     */
    miss = 1,
    /**
     * Meh (50).
     */
    meh = 2,
    /**
     * Good (100).
     */
    good = 3,
    /**
     * Great (300).
     */
    great = 4
}

/**
 * Represents a hitobject in an osu!droid replay.
 *
 * Stores information about hitobjects in an osu!droid replay such as hit offset, tickset, and hit result.
 *
 * This is used when analyzing replays using replay analyzer.
 */
declare class ReplayObjectData {
    /**
     * For circles, this is the offset at which the circle was hit. If the hit accuracy is 10000,
     * it means the circle was tapped too late and therefore the player missed ([game source code](https://github.com/osudroid/osu-droid/blob/ca0e4a2c06b9db18d094a15a4abf3f7ffcb05d7a/src/ru/nsu/ccfit/zuev/osu/game/GameplayHitCircle.java#L305)).
     *
     * For sliders, this is the offset at which the slider head was hit. For sliderbreaks, there are two scenarios:
     * - a value equal to `Math.floor(<hit window 50>ms) + 13ms` strictly for replays before version 1.7.2 ([game source code](https://github.com/osudroid/osu-droid/blob/6306c68e3ffaf671eac794bf45cc95c0f3313a82/src/ru/nsu/ccfit/zuev/osu/game/Slider.java#L821)), or
     * - a value that is more than the slider's span duration ([game source code](https://github.com/osudroid/osu-droid/blob/ca0e4a2c06b9db18d094a15a4abf3f7ffcb05d7a/src/ru/nsu/ccfit/zuev/osu/game/GameplaySlider.java#L701)).
     *
     * `tickset` and `result` can be used in conjunction with this value to derive whether the player sliderbroke in the slider.
     * If `result` is a 300, the player did not sliderbreak. Otherwise, if all slider ticks, repeats, and ends were hit, the
     * player sliderbroke. In other cases, it is almost impossible to derive this result.
     *
     * For spinners, this is the total amount at which the spinner was spinned:
     * ```js
     * const rotations = Math.floor(data.accuracy / 4);
     * ```
     * The remainder of the division denotes the hit result of the spinner:
     * - `HitResult.great`: 3
     * - `HitResult.good`: 2
     * - `HitResult.meh`: 1
     * - `HitResult.miss`: 0
     */
    accuracy: number;
    /**
     * The tickset of the hitobject.
     *
     * This is used to determine whether or not a slider event (tick, repeat, and end) is hit based on the order they appear.
     */
    tickset: boolean[];
    /**
     * The bitwise hit result of the hitobject.
     */
    result: HitResult;
    constructor(values: {
        /**
         * The offset of which the hitobject was hit in milliseconds.
         */
        accuracy: number;
        /**
         * The tickset of the hitobject.
         *
         * This is used to determine whether or not a slider event (tick/repeat/end) is hit based on the order they appear.
         */
        tickset: boolean[];
        /**
         * The bitwise hit result of the hitobject.
         */
        result: HitResult;
    });
}

/**
 * Contains information about a replay.
 */
interface ReplayInformation {
    /**
     * The version of the replay.
     */
    replayVersion: number;
    /**
     * The folder name containing the beatmap played.
     */
    folderName: string;
    /**
     * The file name of the beatmap played.
     */
    fileName: string;
    /**
     * The MD5 hash of the beatmap played.
     */
    hash: string;
    /**
     * The date of which the play was set.
     *
     * Only available in replay v3 or later.
     */
    time: Date;
    /**
     * The amount of geki and 300 katu achieved in the play. See {@link https://osu.ppy.sh/help/wiki/Score this} osu! wiki page for more information.
     *
     * Only available in replay v3 or later.
     *
     * If `map` is defined in analyzer (either in `Beatmap` or `DroidDifficultyCalculator` instance), this will be analyzed using beatmap hitobject information and replay hitobject data for replay v1 and v2.
     */
    hit300k: number;
    /**
     * The amount of 100 katu achieved in the play. See {@link https://osu.ppy.sh/help/wiki/Score this} osu! wiki page for more information.
     *
     * Only available in replay v3 or later.
     *
     * If `map` is defined in analyzer (either in `Beatmap` or `DroidDifficultyCalculator` instance), this will be analyzed using beatmap hitobject information and replay hitobject data for replay v1 and v2.
     */
    hit100k: number;
    /**
     * The total score achieved in the play.
     *
     * Only available in replay v3 or later.
     */
    score: number;
    /**
     * The maximum combo achieved in the play.
     *
     * Only available in replay v3 or later.
     */
    maxCombo: number;
    /**
     * The accuracy achieved in the play.
     */
    accuracy: Accuracy;
    /**
     * Whether or not the play achieved the beatmap's maximum combo.
     *
     * Only available in replay v3 or later.
     */
    isFullCombo: boolean;
    /**
     * The name of the player in the replay.
     *
     * Only available in replay v3 or later.
     */
    playerName: string;
    /**
     * The achieved rank in the play.
     */
    rank: ScoreRank;
    /**
     * Enabled modifications during the play that have been converted to their respective `Mod` instances.
     *
     * Only available in replay v3 or later.
     */
    convertedMods: ModMap;
    /**
     * The cursor movement data of the replay.
     */
    readonly cursorMovement: CursorData[];
    /**
     * The hit object data of the replay.
     */
    readonly hitObjectData: ReplayObjectData[];
}

/**
 * Represents a replay data for replay version 3.
 *
 * Stores generic information about an osu!droid replay.
 *
 * This is used when analyzing replays using replay analyzer.
 */
declare class ReplayV3Data extends ReplayData {
    /**
     * The date of which the play was set.
     */
    readonly time: Date;
    /**
     * The total score achieved in the play.
     */
    readonly score: number;
    /**
     * The maximum combo achieved in the play.
     */
    readonly maxCombo: number;
    /**
     * Whether or not the play achieved the beatmap's maximum combo.
     */
    readonly isFullCombo: boolean;
    /**
     * The name of the player in the replay.
     */
    readonly playerName: string;
    /**
     * Enabled modifications during the play that have been converted to their respective `Mod` instances.
     */
    readonly convertedMods: ModMap;
    constructor(values: ReplayInformation);
}

/**
 * Represents a replay data in an osu!droid replay version 1 and 2.
 *
 * Stores generic information about an osu!droid replay.
 *
 * This is used when analyzing replays using replay analyzer.
 */
declare class ReplayData {
    /**
     * The version of the replay.
     */
    readonly replayVersion: number;
    /**
     * The folder name containing the beatmap played.
     */
    readonly folderName: string;
    /**
     * The file name of the beatmap played.
     */
    readonly fileName: string;
    /**
     * The MD5 hash of the beatmap played.
     */
    readonly hash: string;
    /**
     * The accuracy achieved in the play.
     */
    readonly accuracy: Accuracy;
    /**
     * The achieved rank in the play.
     */
    readonly rank: ScoreRank;
    /**
     * The amount of geki and 300 katu achieved in the play. See {@link https://osu.ppy.sh/help/wiki/Score this}
     * osu! wiki page for more information.
     *
     * Only available in replay v3 or later, but if `map` was defined in when analyzing the replay,
     * this will be analyzed using beatmap hitobject information and replay hitobject data for replay v1
     * and v2. Otherwise, this will be 0.
     */
    readonly hit300k: number;
    /**
     * The amount of 100 katu achieved in the play. See {@link https://osu.ppy.sh/help/wiki/Score this}
     * osu! wiki page for more information.
     *
     * Only available in replay v3 or later, but if `map` was defined in when analyzing the replay,
     * this will be analyzed using beatmap hitobject information and replay hitobject data for replay v1
     * and v2. Otherwise, this will be 0.
     */
    readonly hit100k: number;
    /**
     * The cursor movement data of the replay.
     */
    readonly cursorMovement: CursorData[];
    /**
     * The hit object data of the replay.
     */
    readonly hitObjectData: ReplayObjectData[];
    constructor(values: ReplayInformation);
    /**
     * Whether the replay's version is 3 or later.
     */
    isReplayV3(): this is ReplayV3Data;
}

/**
 * Information about the result of a three-finger check.
 */
interface ThreeFingerInformation {
    /**
     * Whether the beatmap is three-fingered.
     */
    readonly is3Finger: boolean;
    /**
     * The final penalty. By default this is 1.
     */
    readonly penalty: number;
}

/**
 * Utility to check whether or not a beatmap is three-fingered for rebalance scores.
 */
declare class RebalanceThreeFingerChecker {
    /**
     * The beatmap that is being analyzed.
     */
    readonly beatmap: DroidPlayableBeatmap;
    /**
     * The data of the replay.
     */
    readonly data: ReplayData;
    /**
     * The difficulty attributes of the beatmap.
     */
    readonly difficultyAttributes: IExtendedDroidDifficultyAttributes;
    /**
     * Extended sections of the beatmap for drag detection.
     */
    private readonly beatmapSections;
    /**
     * The hit window of this beatmap. Keep in mind that speed-changing mods do not change hit window length in game logic.
     */
    private readonly hitWindow;
    /**
     * A reprocessed break points to match right on object time.
     *
     * This is used to increase detection accuracy since break points do not start right at the
     * start of the hitobject before it and do not end right at the first hitobject after it.
     */
    private readonly breakPointAccurateTimes;
    /**
     * A cursor occurrence nested array that only contains `movementType.DOWN` movement ID occurrences.
     *
     * Each index represents the cursor index.
     */
    private readonly downCursorInstances;
    /**
     * Nerf factors from all sections that were three-fingered.
     */
    private readonly nerfFactors;
    private readonly isHardRock;
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap: DroidPlayableBeatmap, data: ReplayData, difficultyAttributes: IExtendedDroidDifficultyAttributes);
    /**
     * Checks whether a beatmap is eligible to be detected for 3-finger.
     *
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    static isEligibleToDetect(difficultyAttributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes): boolean;
    /**
     * Checks if the given beatmap is 3-fingered and also returns the final penalty.
     *
     * The beatmap will be separated into sections and each section will be determined
     * whether or not it is dragged.
     *
     * After that, each section will be assigned a nerf factor based on whether or not
     * the section is 3-fingered. These nerf factors will be summed up into a final
     * nerf factor, taking beatmap difficulty into account.
     */
    check(): ThreeFingerInformation;
    /**
     * Generates a new set of "accurate break points".
     *
     * This is done to increase detection accuracy since break points do not start right at the
     * end of the hitobject before it and do not end right at the first hitobject after it.
     */
    private getAccurateBreakPoints;
    /**
     * Filters the original cursor instances, returning only those with `movementType.DOWN` movement ID.
     *
     * This also filters cursors that are in break period or happen before start/after end of the beatmap.
     */
    private filterCursorInstances;
    /**
     * Divides the beatmap into sections, which will be used to
     * detect dragged sections and improve detection speed.
     */
    private getBeatmapSections;
    /**
     * Obtains the index of the cursor that aimed the object at the nearest time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorInstanceIndices The cursor indices to start looking for the cursor instance from, to save computation time.
     * @param cursorGroupIndices The cursor indices to start looking for the cursor group from, to save computation time.
     * @param cursorIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    private getObjectAimIndex;
    /**
     * Obtains the index of the nearest cursor of which an object was pressed in terms of time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorLookupIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @param excludedIndices The cursor indices that should not be checked.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    private getObjectPressIndex;
    /**
     * Creates nerf factors by scanning through objects.
     */
    private calculateNerfFactors;
    /**
     * Calculates the final penalty.
     */
    private calculateFinalPenalty;
    private getCursorPosition;
}

/**
 * Information about the result of a slider cheese check.
 */
interface SliderCheeseInformation {
    /**
     * The value used to penalize the aim performance value, from 0 to 1.
     */
    aimPenalty: number;
    /**
     * The value used to penalize the flashlight performance value, from 0 to 1.
     */
    flashlightPenalty: number;
    /**
     * The value used to penalize the visual performance value, from 0 to 1.
     */
    visualPenalty: number;
}

interface HitErrorInformation {
    negativeAvg: number;
    positiveAvg: number;
    unstableRate: number;
}
/**
 * A replay analyzer that analyzes a replay from osu!droid.
 *
 * Created by reverse engineering the replay parser from the game itself, which can be found {@link https://github.com/osudroid/osu-droid/blob/master/src/ru/nsu/ccfit/zuev/osu/scoring/Replay.java here}.
 *
 * Once analyzed, the result can be accessed via the `data` property.
 */
declare class ReplayAnalyzer {
    /**
     * The score ID of the replay.
     */
    scoreID?: number;
    /**
     * The original odr file of the replay.
     */
    originalODR: Buffer | null;
    /**
     * The fixed odr file of the replay.
     */
    fixedODR: Buffer | null;
    /**
     * Whether or not the play is considered using >=3 finger abuse.
     */
    is3Finger?: boolean;
    /**
     * Whether or not the play is considered 2-handed.
     */
    is2Hand?: boolean;
    /**
     * The beatmap that is being analyzed. `DroidDifficultyCalculator` or `RebalanceDroidDifficultyCalculator` is required for three finger or two hand analyzing.
     */
    beatmap?: Beatmap | DroidPlayableBeatmap;
    /**
     * The difficulty attributes of the beatmap.
     */
    difficultyAttributes?: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes;
    /**
     * The results of the analyzer. `null` when initialized.
     */
    data: ReplayData | null;
    /**
     * Penalty value used to penalize dpp for 2-hand.
     */
    aimPenalty: number;
    /**
     * Penalty value used to penalize dpp for 3 finger abuse.
     */
    tapPenalty: number;
    /**
     * Penalty values used to penalize dpp for slider cheesing.
     */
    sliderCheesePenalty: SliderCheeseInformation;
    /**
     * Whether this replay has been checked against 3 finger usage.
     */
    hasBeenCheckedFor3Finger: boolean;
    /**
     * Whether this replay has been checked against 2 hand usage.
     */
    hasBeenCheckedFor2Hand: boolean;
    /**
     * Whether this replay has been checked against slider cheesing.
     */
    hasBeenCheckedForSliderCheesing: boolean;
    /**
     * The amount of two-handed objects.
     */
    twoHandedNoteCount: number;
    private playableBeatmap?;
    private bufferOffset;
    constructor(values?: {
        /**
         * The ID of the score.
         */
        scoreID?: number;
        /**
         * The beatmap to analyze.
         */
        map?: Beatmap | DroidPlayableBeatmap;
        /**
         * The difficulty attributes.
         */
        difficultyAttributes?: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes;
    });
    /**
     * Analyzes a replay.
     */
    analyze(): Promise<ReplayAnalyzer>;
    /**
     * Gets hit error information of the replay.
     *
     * `analyze()` must be called before calling this.
     */
    calculateHitError(): HitErrorInformation | null;
    /**
     * Checks if a play is using 3 fingers.
     *
     * Requires `analyze()` to be called first and `map` and `difficultyAttributes` to be defined.
     */
    checkFor3Finger(): void;
    /**
     * Checks if a play is using 2 hands.
     *
     * Requires `analyze()` to be called first as well as `beatmap` and `difficultyAttributes` to be defined.
     */
    checkFor2Hand(): void;
    /**
     * Checks if a play has cheesed sliders.
     *
     * Requires `analyze()` to be called first and `map` and `difficultyAttributes` to be defined.
     */
    checkForSliderCheesing(): void;
    /**
     * Downloads the given score ID's replay.
     */
    private downloadReplay;
    /**
     * Decompresses a replay.
     *
     * The decompressed replay is in a form of Java object. This will be converted to a buffer and deserialized to read data from the replay.
     */
    private decompress;
    /**
     * Parses a replay after being downloaded and converted to a buffer.
     */
    private parseReplay;
    /**
     * Converts replay mods to droid mod string.
     */
    private convertDroidMods;
    private parseMovementData;
    private parseHitObjectData;
    private parseOldReplayInformation;
    private calculateRank;
    private constructPlayableBeatmap;
    private readByte;
    private readShort;
    private readInt;
    private readFloat;
}

/**
 * Utility to check whether relevant sliders in a beatmap are cheesed.
 */
declare class SliderCheeseChecker {
    /**
     * The beatmap that is being analyzed.
     */
    readonly beatmap: DroidPlayableBeatmap;
    /**
     * The data of the replay.
     */
    readonly data: ReplayData;
    /**
     * The difficulty attributes of the beatmap.
     */
    readonly difficultyAttributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes;
    /**
     * The 50 osu!droid hit window of the analyzed beatmap.
     */
    private readonly hitWindow50;
    private readonly isHardRock;
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap: DroidPlayableBeatmap, data: ReplayData, difficultyAttributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes);
    /**
     * Checks if relevant sliders in the given beatmap was cheesed.
     */
    check(): SliderCheeseInformation;
    /**
     * Checks for sliders that were cheesed.
     */
    private checkSliderCheesing;
    /**
     * Calculates the slider cheese penalty.
     */
    private calculateSliderCheesePenalty;
    private getCursorPosition;
}

/**
 * Utility to check whether or not a beatmap is three-fingered for rebalance scores.
 */
declare class ThreeFingerChecker {
    /**
     * The beatmap that is being analyzed.
     */
    readonly beatmap: DroidPlayableBeatmap;
    /**
     * The data of the replay.
     */
    readonly data: ReplayData;
    /**
     * The difficulty attributes of the beatmap.
     */
    readonly difficultyAttributes: IExtendedDroidDifficultyAttributes$1;
    /**
     * Extended sections of the beatmap for drag detection.
     */
    private readonly beatmapSections;
    /**
     * The hit window of this beatmap. Keep in mind that speed-changing mods do not change hit window length in game logic.
     */
    private readonly hitWindow;
    /**
     * A reprocessed break points to match right on object time.
     *
     * This is used to increase detection accuracy since break points do not start right at the
     * start of the hitobject before it and do not end right at the first hitobject after it.
     */
    private readonly breakPointAccurateTimes;
    /**
     * A cursor occurrence nested array that only contains `movementType.DOWN` movement ID occurrences.
     *
     * Each index represents the cursor index.
     */
    private readonly downCursorInstances;
    /**
     * Nerf factors from all sections that were three-fingered.
     */
    private readonly nerfFactors;
    private readonly isHardRock;
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap: DroidPlayableBeatmap, data: ReplayData, difficultyAttributes: IExtendedDroidDifficultyAttributes$1);
    /**
     * Checks whether a beatmap is eligible to be detected for 3-finger.
     *
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    static isEligibleToDetect(difficultyAttributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes): boolean;
    /**
     * Checks if the given beatmap is 3-fingered and also returns the final penalty.
     *
     * The beatmap will be separated into sections and each section will be determined
     * whether or not it is dragged.
     *
     * After that, each section will be assigned a nerf factor based on whether or not
     * the section is 3-fingered. These nerf factors will be summed up into a final
     * nerf factor, taking beatmap difficulty into account.
     */
    check(): ThreeFingerInformation;
    /**
     * Generates a new set of "accurate break points".
     *
     * This is done to increase detection accuracy since break points do not start right at the
     * end of the hitobject before it and do not end right at the first hitobject after it.
     */
    private getAccurateBreakPoints;
    /**
     * Filters the original cursor instances, returning only those with `movementType.DOWN` movement ID.
     *
     * This also filters cursors that are in break period or happen before start/after end of the beatmap.
     */
    private filterCursorInstances;
    /**
     * Divides the beatmap into sections, which will be used to
     * detect dragged sections and improve detection speed.
     */
    private getBeatmapSections;
    /**
     * Obtains the index of the cursor that aimed the object at the nearest time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorInstanceIndices The cursor indices to start looking for the cursor instance from, to save computation time.
     * @param cursorGroupIndices The cursor indices to start looking for the cursor group from, to save computation time.
     * @param cursorIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    private getObjectAimIndex;
    /**
     * Obtains the index of the nearest cursor of which an object was pressed in terms of time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorLookupIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @param excludedIndices The cursor indices that should not be checked.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    private getObjectPressIndex;
    /**
     * Creates nerf factors by scanning through objects.
     */
    private calculateNerfFactors;
    /**
     * Calculates the final penalty.
     */
    private calculateFinalPenalty;
    private getCursorPosition;
}

/**
 * Information about the result of a check.
 */
interface TwoHandInformation {
    /**
     * Whether or not the beatmap is 2-handed.
     */
    readonly is2Hand: boolean;
    /**
     * The amount of two-handed objects.
     */
    readonly twoHandedNoteCount: number;
}
/**
 * Utility to check whether or not a beatmap is two-handed.
 */
declare class TwoHandChecker {
    /**
     * The beatmap to analyze.
     */
    readonly beatmap: DroidPlayableBeatmap;
    /**
     * The difficulty attributes that is being analyzed.
     */
    readonly attributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes;
    /**
     * The data of the replay.
     */
    readonly data: ReplayData;
    /**
     * The hitobjects of the beatmap that have been assigned with their respective cursor index.
     */
    private readonly indexedHitObjects;
    /**
     * The osu!droid hitwindow of the analyzed beatmap.
     */
    private readonly hitWindow;
    private readonly isHardRock;
    /**
     * @param beatmap The beatmap to analyze.
     * @param attributes The difficulty attributes to analyze.
     * @param data The data of the replay.
     */
    constructor(beatmap: DroidPlayableBeatmap, attributes: IExtendedDroidDifficultyAttributes$1 | IExtendedDroidDifficultyAttributes, data: ReplayData);
    /**
     * Checks if a beatmap is two-handed.
     */
    check(): TwoHandInformation;
    /**
     * Converts hitobjects into indexed hit objects.
     */
    private indexHitObjects;
    /**
     * Gets the cursor index that hits the given object.
     *
     * @param objectIndex The index of the object to check.
     * @returns The cursor index that hits the given object, -1 if the index is not found, the object is a spinner, or the object was missed.
     */
    private getIndexedHitObject;
    /**
     * Gets the position of the cursor that presses an object.
     *
     * @param objectIndex THe index of the object.
     * @returns The position of the cursor that presses the object.
     */
    private getCursorPositionForObjectStart;
    /**
     * Gets the position of the cursor that at an object's end position.
     *
     * @param objectIndex THe index of the object.
     * @returns The position of the cursor at the object's end position.
     */
    private getCursorPositionForObjectEnd;
    /**
     * Checks whether a slider was cheesed.
     *
     * This is done by checking if a cursor follows a slider all the way to its end position.
     *
     * @param indexedHitObject The indexed slider.
     * @param hitData The hit data of the slider.
     * @returns Whether the slider was cheesed.
     */
    private checkSliderCheesing;
    private getCursorPosition;
}

export { CursorData, type CursorInformation, CursorOccurrence, CursorOccurrenceGroup, type ExportedReplayJSON, type ExportedReplayJSONDataV1, type ExportedReplayJSONDataV2, type ExportedReplayJSONV1, type ExportedReplayJSONV2, type HitErrorInformation, HitResult, MovementType, RebalanceThreeFingerChecker, ReplayAnalyzer, ReplayData, ReplayObjectData, ReplayV3Data, SliderCheeseChecker, type SliderCheeseInformation, ThreeFingerChecker, type ThreeFingerInformation, TwoHandChecker, type TwoHandInformation };
