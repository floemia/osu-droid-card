'use strict';

var osuBase = require('@rian8337/osu-base');
var javaDeserialization = require('java-deserialization');
var node_stream = require('node:stream');
var unzipper = require('unzipper');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var javaDeserialization__namespace = /*#__PURE__*/_interopNamespaceDefault(javaDeserialization);

/**
 * Movement types of a cursor in an osu!droid replay.
 *
 * The cursor movement is represented as a player's action on the screen.
 */
exports.MovementType = void 0;
(function (MovementType) {
    /**
     * The player places their finger on the screen.
     */
    MovementType[MovementType["down"] = 0] = "down";
    /**
     * The player drags their finger on the screen.
     */
    MovementType[MovementType["move"] = 1] = "move";
    /**
     * The player releases their finger from the screen.
     */
    MovementType[MovementType["up"] = 2] = "up";
})(exports.MovementType || (exports.MovementType = {}));

/**
 * Represents a cursor's occurrence.
 */
class CursorOccurrence {
    constructor(time, x, y, id) {
        this.time = time;
        this.position = new osuBase.Vector2(x, y);
        this.id = id;
    }
    /**
     * Returns a string representation of this `CursorOccurrence`.
     */
    toString() {
        let str = `${this.time}ms `;
        switch (this.id) {
            case exports.MovementType.down:
                str += "Down";
                break;
            case exports.MovementType.up:
                str += "Up";
                break;
            case exports.MovementType.move:
                str += "Move";
                break;
        }
        if (this.id !== exports.MovementType.up) {
            str += ` (${this.position.x.toFixed(2)}, ${this.position.y.toFixed(2)})`;
        }
        return str;
    }
}

/**
 * Represents a group of cursor occurrences representing a cursor instance's
 * movement when a player places their finger on the screen.
 */
class CursorOccurrenceGroup {
    /**
     * The cursor occurrence of movement type `movementType.DOWN`.
     */
    get down() {
        return this._down;
    }
    /**
     * The cursor occurrence of movement type `movementType.DOWN`.
     */
    set down(value) {
        if (value.id !== exports.MovementType.down) {
            throw new TypeError("Attempting to set the down cursor occurrence to one with different movement type.");
        }
        this._down = value;
    }
    /**
     * The cursor occurrences of movement type `movementType.MOVE`.
     */
    get moves() {
        return this._moves;
    }
    /**
     * The cursor occurrence of movement type `movementType.UP`.
     *
     * May not exist, such as when the player holds their cursor until the end of a beatmap.
     */
    get up() {
        return this._up;
    }
    /**
     * The cursor occurrence of movement type `movementType.UP`.
     *
     * May not exist, such as when the player holds their cursor until the end of a beatmap.
     */
    set up(value) {
        if (value && value.id !== exports.MovementType.up) {
            throw new TypeError("Attempting to set the up cursor occurrence to one with different movement type.");
        }
        this._up = value;
    }
    /**
     * The time at which this cursor occurrence group starts.
     */
    get startTime() {
        return this._down.time;
    }
    /**
     * The time at which this cursor occurrence group ends.
     */
    get endTime() {
        var _a, _b, _c, _d;
        return (_d = (_b = (_a = this._up) === null || _a === void 0 ? void 0 : _a.time) !== null && _b !== void 0 ? _b : (_c = this._moves.at(-1)) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : this._down.time;
    }
    /**
     * The duration this cursor occurrence group is active for.
     */
    get duration() {
        return this.endTime - this.startTime;
    }
    /**
     * All cursor occurrences in this group.
     *
     * This iterates all occurrences and as such should be used sparingly or stored locally.
     */
    get allOccurrences() {
        const cursors = [this._down, ...this._moves];
        if (this._up) {
            cursors.push(this._up);
        }
        return cursors;
    }
    constructor(down, moves, up) {
        this._down = down;
        this._moves = moves;
        // Re-set down cursor occurrence for checking.
        this.down = down;
        this.up = up;
    }
    /**
     * Determines whether this cursor occurrence group is active at the specified time.
     *
     * @param time The time.
     * @returns Whether this cursor occurrence group is active at the specified time.
     */
    isActiveAt(time) {
        return time >= this.startTime && time <= this.endTime;
    }
    /**
     * Finds the cursor occurrence that is active at a given time.
     *
     * @param time The time.
     * @returns The cursor occurrence at the given time, `null` if not found.
     */
    cursorAt(time) {
        var _a;
        if (!this.isActiveAt(time)) {
            return null;
        }
        if (this._down.time === time) {
            return this._down;
        }
        if (((_a = this._up) === null || _a === void 0 ? void 0 : _a.time) === time) {
            return this._up;
        }
        let l = 0;
        let r = this._moves.length - 2;
        while (l <= r) {
            const pivot = l + ((r - l) >> 1);
            if (this._moves[pivot].time < time) {
                l = pivot + 1;
            }
            else if (this._moves[pivot].time > time) {
                r = pivot - 1;
            }
            else {
                return this._moves[pivot];
            }
        }
        // l will be the first cursor occurrence with time > this._moves[l].time, but we want the one before it
        return this._moves[l - 1];
    }
    /**
     * Returns a string representation of this `CursorOccurrenceGroup`.
     */
    toString() {
        return `Down: ${this.down.time}ms (${this.down.position.x.toFixed(2)}, ${this.down.position.y.toFixed(2)}) | Moves: ${this.moves.length} | Up: ${this.up ? `${this.up.time}ms` : "N/A"}`;
    }
}

/**
 * Represents a cursor instance in an osu!droid replay.
 *
 * Stores cursor movement data in the form of `CursorOccurrenceGroup`s.
 *
 * This is used when analyzing replays using replay analyzer.
 */
class CursorData {
    /**
     * The time at which the first occurrence of this cursor instance occurs.
     *
     * Will return `null` if there are no occurrences.
     */
    get earliestOccurrenceTime() {
        var _a, _b;
        return (_b = (_a = this.occurrenceGroups.at(0)) === null || _a === void 0 ? void 0 : _a.startTime) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * The time at which the latest occurrence of this cursor instance occurs.
     *
     * Will return `null` if there are no occurrences.
     */
    get latestOccurrenceTime() {
        var _a, _b;
        return (_b = (_a = this.occurrenceGroups.at(-1)) === null || _a === void 0 ? void 0 : _a.endTime) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * The amount of cursor occurrences of this cursor instance.
     */
    get totalOccurrences() {
        return this.occurrenceGroups.reduce((a, v) => {
            // Down cursor.
            ++a;
            // Move cursors.
            a += v.moves.length;
            if (v.up) {
                // Up cursor.
                ++a;
            }
            return a;
        }, 0);
    }
    /**
     * All cursor occurrences of this cursor instnace.
     *
     * This iterates all occurrence groups and as such should be used sparingly or stored locally.
     */
    get allOccurrences() {
        return this.occurrenceGroups.flatMap((v) => v.allOccurrences);
    }
    constructor(values) {
        /**
         * The occurrence groups of this cursor instance.
         */
        this.occurrenceGroups = [];
        let downOccurrence = null;
        let moveOccurrences = [];
        for (let i = 0; i < values.size; ++i) {
            const occurrence = new CursorOccurrence(values.time[i], values.x[i], values.y[i], values.id[i]);
            switch (occurrence.id) {
                case exports.MovementType.down:
                    downOccurrence = occurrence;
                    break;
                case exports.MovementType.move:
                    moveOccurrences.push(occurrence);
                    break;
                case exports.MovementType.up:
                    if (downOccurrence) {
                        this.occurrenceGroups.push(new CursorOccurrenceGroup(downOccurrence, moveOccurrences, occurrence));
                        downOccurrence = null;
                    }
                    moveOccurrences = [];
            }
        }
        // Add the final cursor occurrence group as the loop may not catch it for special cases.
        if (downOccurrence && moveOccurrences.length > 0) {
            this.occurrenceGroups.push(new CursorOccurrenceGroup(downOccurrence, moveOccurrences));
        }
    }
}

/**
 * The result of a hit in an osu!droid replay.
 */
exports.HitResult = void 0;
(function (HitResult) {
    /**
     * Miss (0).
     */
    HitResult[HitResult["miss"] = 1] = "miss";
    /**
     * Meh (50).
     */
    HitResult[HitResult["meh"] = 2] = "meh";
    /**
     * Good (100).
     */
    HitResult[HitResult["good"] = 3] = "good";
    /**
     * Great (300).
     */
    HitResult[HitResult["great"] = 4] = "great";
})(exports.HitResult || (exports.HitResult = {}));

/**
 * Utility to check whether or not a beatmap is three-fingered for rebalance scores.
 */
class RebalanceThreeFingerChecker {
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap, data, difficultyAttributes) {
        /**
         * Extended sections of the beatmap for drag detection.
         */
        this.beatmapSections = [];
        /**
         * A reprocessed break points to match right on object time.
         *
         * This is used to increase detection accuracy since break points do not start right at the
         * start of the hitobject before it and do not end right at the first hitobject after it.
         */
        this.breakPointAccurateTimes = [];
        /**
         * A cursor occurrence nested array that only contains `movementType.DOWN` movement ID occurrences.
         *
         * Each index represents the cursor index.
         */
        this.downCursorInstances = [];
        /**
         * Nerf factors from all sections that were three-fingered.
         */
        this.nerfFactors = [];
        this.beatmap = beatmap;
        this.data = data;
        this.difficultyAttributes = difficultyAttributes;
        this.isHardRock = difficultyAttributes.mods.has(osuBase.ModHardRock);
        this.hitWindow = difficultyAttributes.mods.has(osuBase.ModPrecise)
            ? new osuBase.PreciseDroidHitWindow(beatmap.difficulty.od)
            : new osuBase.DroidHitWindow(beatmap.difficulty.od);
    }
    /**
     * Checks whether a beatmap is eligible to be detected for 3-finger.
     *
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    static isEligibleToDetect(difficultyAttributes) {
        return difficultyAttributes.possibleThreeFingeredSections.length > 0;
    }
    /**
     * Checks if the given beatmap is 3-fingered and also returns the final penalty.
     *
     * The beatmap will be separated into sections and each section will be determined
     * whether or not it is dragged.
     *
     * After that, each section will be assigned a nerf factor based on whether or not
     * the section is 3-fingered. These nerf factors will be summed up into a final
     * nerf factor, taking beatmap difficulty into account.
     */
    check() {
        if (!RebalanceThreeFingerChecker.isEligibleToDetect(this.difficultyAttributes) ||
            this.data.cursorMovement.filter((v) => v.occurrenceGroups.length > 0).length <= 3) {
            return { is3Finger: false, penalty: 1 };
        }
        this.getAccurateBreakPoints();
        this.filterCursorInstances();
        if (this.downCursorInstances.filter((v) => v.length > 0).length <= 3) {
            return { is3Finger: false, penalty: 1 };
        }
        this.getBeatmapSections();
        this.calculateNerfFactors();
        const finalPenalty = this.calculateFinalPenalty();
        return { is3Finger: finalPenalty > 1, penalty: finalPenalty };
    }
    /**
     * Generates a new set of "accurate break points".
     *
     * This is done to increase detection accuracy since break points do not start right at the
     * end of the hitobject before it and do not end right at the first hitobject after it.
     */
    getAccurateBreakPoints() {
        const objects = this.beatmap.hitObjects.objects;
        const objectData = this.data.hitObjectData;
        for (const breakPoint of this.beatmap.events.breaks) {
            const beforeIndex = osuBase.MathUtils.clamp(objects.findIndex((o) => o.endTime >= breakPoint.startTime) - 1, 0, objects.length - 2);
            const objectBefore = objects[beforeIndex];
            const objectBeforeData = objectData[beforeIndex];
            let timeBefore = objectBefore.endTime;
            if (objectBefore instanceof osuBase.Circle) {
                if (objectBeforeData.result !== exports.HitResult.miss) {
                    timeBefore += objectBeforeData.accuracy;
                }
                else {
                    timeBefore += this.hitWindow.mehWindow;
                }
            }
            const afterIndex = beforeIndex + 1;
            const objectAfter = objects[afterIndex];
            const objectAfterData = objectData[afterIndex];
            let timeAfter = objectAfter.startTime;
            if (objectAfter instanceof osuBase.Circle &&
                objectAfterData.result !== exports.HitResult.miss) {
                timeAfter += objectAfterData.accuracy;
            }
            this.breakPointAccurateTimes.push(new osuBase.BreakPoint({
                startTime: timeBefore,
                endTime: timeAfter,
            }));
        }
    }
    /**
     * Filters the original cursor instances, returning only those with `movementType.DOWN` movement ID.
     *
     * This also filters cursors that are in break period or happen before start/after end of the beatmap.
     */
    filterCursorInstances() {
        const objects = this.beatmap.hitObjects.objects;
        const objectData = this.data.hitObjectData;
        const firstObjectResult = objectData[0].result;
        const lastObjectResult = objectData.at(-1).result;
        const firstObject = objects[0];
        const lastObject = objects.at(-1);
        // For sliders, automatically set hit window length to be as lenient as possible.
        let firstObjectHitWindow = this.hitWindow.mehWindow;
        if (firstObject instanceof osuBase.Circle) {
            switch (firstObjectResult) {
                case exports.HitResult.great:
                    firstObjectHitWindow = this.hitWindow.greatWindow;
                    break;
                case exports.HitResult.good:
                    firstObjectHitWindow = this.hitWindow.okWindow;
                    break;
                default:
                    firstObjectHitWindow = this.hitWindow.mehWindow;
            }
        }
        // For sliders, automatically set hit window length to be as lenient as possible.
        let lastObjectHitWindow = this.hitWindow.mehWindow;
        if (lastObject instanceof osuBase.Circle) {
            switch (lastObjectResult) {
                case exports.HitResult.great:
                    lastObjectHitWindow = this.hitWindow.greatWindow;
                    break;
                case exports.HitResult.good:
                    lastObjectHitWindow = this.hitWindow.okWindow;
                    break;
                default:
                    lastObjectHitWindow = this.hitWindow.mehWindow;
            }
        }
        else if (lastObject instanceof osuBase.Slider) {
            lastObjectHitWindow = Math.min(lastObject.spanDuration, lastObjectHitWindow);
        }
        // These hit time uses hit window length as threshold.
        // This is because cursors aren't recorded exactly at hit time,
        // probably due to the game's behavior.
        const firstObjectHitTime = firstObject.startTime - firstObjectHitWindow;
        const lastObjectHitTime = lastObject.startTime + lastObjectHitWindow;
        for (const cursorInstance of this.data.cursorMovement) {
            const validOccurrences = [];
            for (const group of cursorInstance.occurrenceGroups) {
                if (group.startTime < firstObjectHitTime) {
                    continue;
                }
                if (group.startTime > lastObjectHitTime) {
                    break;
                }
                if (this.breakPointAccurateTimes.some((v) => group.startTime >= v.startTime &&
                    group.endTime <= v.endTime)) {
                    continue;
                }
                validOccurrences.push(group.down);
            }
            this.downCursorInstances.push(validOccurrences);
        }
    }
    /**
     * Divides the beatmap into sections, which will be used to
     * detect dragged sections and improve detection speed.
     */
    getBeatmapSections() {
        const beatmapObjects = this.beatmap.hitObjects.objects;
        const aimCursorGroupLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 0);
        // This intentionally starts from 1 because we need to look at the previous cursor.
        const aimCursorLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 1);
        const pressCursorLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 0);
        for (const section of this.difficultyAttributes
            .possibleThreeFingeredSections) {
            const objects = [];
            for (let i = section.firstObjectIndex; i <= section.lastObjectIndex; ++i) {
                const object = beatmapObjects[i];
                const objectData = this.data.hitObjectData[i];
                objects.push({
                    object: object,
                    aimingCursorInstanceIndex: this.getObjectAimIndex(object, objectData, aimCursorGroupLookupIndices, aimCursorLookupIndices),
                    pressingCursorInstanceIndex: this.getObjectPressIndex(object, objectData, pressCursorLookupIndices),
                });
            }
            this.beatmapSections.push(Object.assign(Object.assign({}, section), { objects: objects }));
        }
    }
    /**
     * Obtains the index of the cursor that aimed the object at the nearest time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorInstanceIndices The cursor indices to start looking for the cursor instance from, to save computation time.
     * @param cursorGroupIndices The cursor indices to start looking for the cursor group from, to save computation time.
     * @param cursorIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    getObjectAimIndex(object, objectData, cursorGroupIndices, cursorIndices) {
        if (objectData.result === exports.HitResult.miss || object instanceof osuBase.Spinner) {
            return -1;
        }
        // Check for sliderbreaks and treat them as misses.
        if (object instanceof osuBase.Slider &&
            (-this.hitWindow.mehWindow > objectData.accuracy ||
                objectData.accuracy >
                    Math.min(this.hitWindow.mehWindow, object.duration))) {
            return -1;
        }
        const hitTime = object.startTime + objectData.accuracy;
        const objectPosition = object.getStackedPosition(osuBase.Modes.droid);
        // We are maintaining the closest distance to the object.
        // This is because the radius that is calculated is using an estimation.
        // As such, it does not reflect the actual object radius in gameplay.
        let closestDistance = Number.POSITIVE_INFINITY;
        let nearestCursorIndex = -1;
        // Observe the cursor position at the object's hit time.
        for (let i = 0; i < this.data.cursorMovement.length; ++i) {
            const cursorData = this.data.cursorMovement[i];
            for (let j = cursorGroupIndices[i]; j < cursorData.occurrenceGroups.length; cursorGroupIndices[i] = ++j) {
                const cursorGroup = cursorData.occurrenceGroups[j];
                if (cursorGroup.endTime < hitTime) {
                    // Reset cursor index pointer.
                    cursorIndices[i] = 1;
                    continue;
                }
                if (cursorGroup.startTime > hitTime) {
                    break;
                }
                const cursors = cursorGroup.allOccurrences;
                for (let k = cursorIndices[i]; k < cursors.length; cursorIndices[i] = ++k) {
                    const cursor = cursors[k];
                    const prevCursor = cursors[k - 1];
                    // Cursor is past the object's hit time.
                    if (prevCursor.time > hitTime) {
                        break;
                    }
                    // Cursor is before the object's hit time.
                    if (hitTime > cursor.time) {
                        continue;
                    }
                    let distance;
                    const currentPosition = this.getCursorPosition(cursor);
                    const prevPosition = this.getCursorPosition(prevCursor);
                    switch (cursor.id) {
                        case exports.MovementType.up:
                            distance = prevPosition.getDistance(objectPosition);
                            break;
                        case exports.MovementType.move: {
                            // Interpolate movement.
                            const t = (hitTime - prevCursor.time) /
                                (cursor.time - prevCursor.time);
                            const cursorPosition = osuBase.Interpolation.lerp(prevPosition, currentPosition, t);
                            distance =
                                objectPosition.getDistance(cursorPosition);
                            break;
                        }
                        case exports.MovementType.down:
                            continue;
                    }
                    if (closestDistance > distance) {
                        closestDistance = distance;
                        nearestCursorIndex = i;
                    }
                }
                // Reset cursor index pointer on end of group.
                if (cursorIndices[i] === cursors.length) {
                    cursorIndices[i] = 1;
                }
                break;
            }
            // The previous object may still be hit with the same cursor group or cursor index.
            cursorGroupIndices[i] = Math.max(0, cursorGroupIndices[i] - 1);
            cursorIndices[i] = Math.max(1, cursorIndices[i] - 1);
        }
        return nearestCursorIndex;
    }
    /**
     * Obtains the index of the nearest cursor of which an object was pressed in terms of time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorLookupIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @param excludedIndices The cursor indices that should not be checked.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    getObjectPressIndex(object, objectData, cursorLookupIndices) {
        if (objectData.result === exports.HitResult.miss || object instanceof osuBase.Spinner) {
            return -1;
        }
        // Check for sliderbreaks and treat them as misses.
        if (object instanceof osuBase.Slider &&
            (-this.hitWindow.mehWindow > objectData.accuracy ||
                objectData.accuracy >
                    Math.min(this.hitWindow.mehWindow, object.duration))) {
            return -1;
        }
        const hitTime = object.startTime + objectData.accuracy;
        let nearestCursorInstanceIndex = -1;
        let nearestTime = Number.POSITIVE_INFINITY;
        for (let i = 0; i < this.downCursorInstances.length; ++i) {
            const cursors = this.downCursorInstances[i];
            let cursorNearestTime = Number.POSITIVE_INFINITY;
            for (let j = cursorLookupIndices[i]; j < cursors.length; cursorLookupIndices[i] = ++j) {
                const cursor = cursors[j];
                if (cursor.time > hitTime) {
                    break;
                }
                cursorNearestTime = hitTime - cursor.time;
            }
            if (cursorNearestTime < nearestTime) {
                nearestCursorInstanceIndex = i;
                nearestTime = cursorNearestTime;
            }
        }
        return nearestCursorInstanceIndex;
    }
    /**
     * Creates nerf factors by scanning through objects.
     */
    calculateNerfFactors() {
        for (const beatmapSection of this.beatmapSections) {
            const threeFingerCursorCounts = osuBase.Utils.initializeArray(Math.max(0, this.downCursorInstances.length - 2), 0);
            for (const object of beatmapSection.objects) {
                if (object.pressingCursorInstanceIndex === -1) {
                    continue;
                }
                if (object.aimingCursorInstanceIndex < 3) {
                    // The aim cursor is in the first three cursors. They are counted as non-3 finger.
                    switch (object.pressingCursorInstanceIndex) {
                        case 0:
                        case 1:
                        case 2:
                            break;
                        default:
                            ++threeFingerCursorCounts[object.pressingCursorInstanceIndex - 3];
                            break;
                    }
                }
                else {
                    // The aim cursor is somewhere else. only count the first 2 cursors as non-3 finger.
                    switch (object.pressingCursorInstanceIndex) {
                        case 0:
                        case 1:
                            break;
                        default:
                            ++threeFingerCursorCounts[object.pressingCursorInstanceIndex - 2];
                            break;
                    }
                }
            }
            const threeFingerCursorCount = threeFingerCursorCounts.reduce((a, v) => a + v, 0);
            if (threeFingerCursorCount === 0) {
                continue;
            }
            const sectionObjectCount = beatmapSection.objects.length;
            const threeFingeredObjectRatio = threeFingerCursorCount / sectionObjectCount;
            const strainFactor = Math.max(1, beatmapSection.sumStrain * threeFingeredObjectRatio);
            // Finger factor applies more penalty if more fingers were used.
            const fingerFactor = threeFingerCursorCounts.reduce((acc, count, index) => acc +
                Math.pow(((index + 1) * count) / sectionObjectCount, 0.9), 1);
            // Length factor applies more penalty if there are more 3-fingered object.
            const lengthFactor = 1 + Math.pow(threeFingeredObjectRatio, 0.8);
            this.nerfFactors.push({
                strainFactor: strainFactor,
                fingerFactor: fingerFactor,
                lengthFactor: lengthFactor,
            });
        }
    }
    /**
     * Calculates the final penalty.
     */
    calculateFinalPenalty() {
        return this.nerfFactors.reduce((a, n) => a +
            0.015 *
                Math.pow(n.strainFactor * n.fingerFactor * n.lengthFactor, 1.05), 1);
    }
    getCursorPosition(cursor) {
        if (this.isHardRock) {
            return new osuBase.Vector2(cursor.position.x, osuBase.Playfield.baseSize.y - cursor.position.y);
        }
        return cursor.position;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Utility to check whether relevant sliders in a beatmap are cheesed.
 */
class SliderCheeseChecker {
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap, data, difficultyAttributes) {
        this.beatmap = beatmap;
        this.data = data;
        this.difficultyAttributes = difficultyAttributes;
        this.hitWindow50 = difficultyAttributes.mods.has(osuBase.ModPrecise)
            ? new osuBase.PreciseDroidHitWindow(beatmap.difficulty.od).mehWindow
            : new osuBase.DroidHitWindow(beatmap.difficulty.od).mehWindow;
        this.isHardRock = difficultyAttributes.mods.has(osuBase.ModHardRock);
    }
    /**
     * Checks if relevant sliders in the given beatmap was cheesed.
     */
    check() {
        if (this.difficultyAttributes.difficultSliders.length === 0 ||
            (this.difficultyAttributes.sliderFactor === 1 &&
                this.difficultyAttributes.flashlightSliderFactor === 1 &&
                this.difficultyAttributes.visualSliderFactor === 1)) {
            return {
                aimPenalty: 1,
                flashlightPenalty: 1,
                visualPenalty: 1,
            };
        }
        const cheesedDifficultyRatings = this.checkSliderCheesing();
        return this.calculateSliderCheesePenalty(cheesedDifficultyRatings);
    }
    /**
     * Checks for sliders that were cheesed.
     */
    checkSliderCheesing() {
        const { objects } = this.beatmap.hitObjects;
        const cheesedDifficultyRatings = [];
        // Current loop indices are stored for efficiency.
        const cursorLoopIndices = osuBase.Utils.initializeArray(this.data.cursorMovement.length, 0);
        const acceptableRadius = objects[0].radius * 2;
        // Sort difficult sliders by index so that cursor loop indices work properly.
        for (const difficultSlider of this.difficultyAttributes.difficultSliders
            .slice()
            .sort((a, b) => a.index - b.index)) {
            if (difficultSlider.index >= this.data.hitObjectData.length) {
                continue;
            }
            const object = objects[difficultSlider.index];
            const objectData = this.data.hitObjectData[difficultSlider.index];
            // If a miss or slider break occurs, we disregard the check for that slider.
            if (objectData.result === exports.HitResult.miss ||
                -this.hitWindow50 > objectData.accuracy ||
                objectData.accuracy >
                    Math.min(this.hitWindow50, object.duration)) {
                continue;
            }
            const objectStartPosition = object.getStackedPosition(osuBase.Modes.droid);
            // These time boundaries should consider the delta time between the previous and next
            // object as well as their hit accuracy. However, they are somewhat complicated to
            // compute and the accuracy gain is small. As such, let's settle with 50 hit window.
            const minTimeLimit = object.startTime - this.hitWindow50;
            const maxTimeLimit = object.startTime + this.hitWindow50;
            // Get the closest tap distance across all cursors.
            const closestDistances = [];
            const closestGroupIndices = [];
            for (let i = 0; i < this.data.cursorMovement.length; ++i) {
                const cursorGroups = this.data.cursorMovement[i].occurrenceGroups;
                let closestDistance = Number.POSITIVE_INFINITY;
                let closestIndex = cursorGroups.length;
                for (let j = cursorLoopIndices[i]; j < cursorGroups.length; j = ++cursorLoopIndices[i]) {
                    const group = cursorGroups[j];
                    if (group.endTime < minTimeLimit) {
                        continue;
                    }
                    if (group.startTime > maxTimeLimit) {
                        break;
                    }
                    if (group.startTime >= minTimeLimit) {
                        const position = this.getCursorPosition(group.down);
                        const distance = position.getDistance(objectStartPosition);
                        if (closestDistance > distance) {
                            closestDistance = distance;
                            closestIndex = j;
                        }
                        if (closestDistance <= acceptableRadius / 2) {
                            break;
                        }
                    }
                    // Normally, we check if there are cursor presses within the group's active time.
                    // However, some funky workarounds are used throughout the game for replays, so
                    // for the time being we only check for cursor distances across the group.
                    const { allOccurrences } = group;
                    for (let k = 1; k < allOccurrences.length; ++k) {
                        const cursor = allOccurrences[k];
                        const prevCursor = allOccurrences[k - 1];
                        let distance = Number.POSITIVE_INFINITY;
                        const currentPosition = this.getCursorPosition(cursor);
                        const prevPosition = this.getCursorPosition(prevCursor);
                        switch (cursor.id) {
                            case exports.MovementType.up:
                                distance =
                                    prevPosition.getDistance(objectStartPosition);
                                break;
                            case exports.MovementType.move:
                                for (let mSecPassed = Math.max(prevCursor.time, minTimeLimit); mSecPassed <=
                                    Math.min(cursor.time, maxTimeLimit); ++mSecPassed) {
                                    const t = (mSecPassed - prevCursor.time) /
                                        (cursor.time - prevCursor.time);
                                    const cursorPosition = osuBase.Interpolation.lerp(prevPosition, currentPosition, t);
                                    distance =
                                        cursorPosition.getDistance(objectStartPosition);
                                    if (closestDistance > distance) {
                                        closestDistance = distance;
                                        closestIndex = j;
                                    }
                                    if (closestDistance <=
                                        acceptableRadius / 2) {
                                        break;
                                    }
                                }
                        }
                        if (closestDistance > distance) {
                            closestDistance = distance;
                            closestIndex = j;
                        }
                        if (closestDistance <= acceptableRadius / 2) {
                            break;
                        }
                    }
                }
                closestDistances.push(closestDistance);
                closestGroupIndices.push(closestIndex);
                if (cursorLoopIndices[i] > 0) {
                    // Decrement the index. The previous group may also have a role on the next slider.
                    --cursorLoopIndices[i];
                }
            }
            const cursorIndex = closestDistances.indexOf(Math.min(...closestDistances));
            const closestDistance = closestDistances[cursorIndex];
            if (closestDistance > acceptableRadius / 2) {
                cheesedDifficultyRatings.push(difficultSlider.difficultyRating);
                continue;
            }
            const group = this.data.cursorMovement[cursorIndex].occurrenceGroups[closestGroupIndices[cursorIndex]];
            let isCheesed = false;
            // Track cursor movement to see if it lands on every tick.
            let occurrenceLoopIndex = 1;
            const { allOccurrences } = group;
            for (let i = 1; i < object.nestedHitObjects.length; ++i) {
                if (isCheesed) {
                    break;
                }
                const tickWasHit = objectData.tickset[i - 1];
                if (!tickWasHit) {
                    continue;
                }
                const nestedObject = object.nestedHitObjects[i];
                const nestedPosition = nestedObject.getStackedPosition(osuBase.Modes.droid);
                while (occurrenceLoopIndex < allOccurrences.length &&
                    allOccurrences[occurrenceLoopIndex].time <
                        nestedObject.startTime) {
                    ++occurrenceLoopIndex;
                }
                if (occurrenceLoopIndex === allOccurrences.length) {
                    continue;
                }
                const cursor = allOccurrences[occurrenceLoopIndex];
                const prevCursor = allOccurrences[occurrenceLoopIndex - 1];
                const currentPosition = this.getCursorPosition(cursor);
                const prevPosition = this.getCursorPosition(prevCursor);
                switch (cursor.id) {
                    case exports.MovementType.move: {
                        // Interpolate cursor position during nested object time.
                        const t = (nestedObject.startTime - prevCursor.time) /
                            (cursor.time - prevCursor.time);
                        const cursorPosition = osuBase.Interpolation.lerp(prevPosition, currentPosition, t);
                        const distance = cursorPosition.getDistance(nestedPosition);
                        isCheesed = distance > acceptableRadius;
                        break;
                    }
                    case exports.MovementType.up:
                        isCheesed =
                            prevPosition.getDistance(nestedPosition) >
                                acceptableRadius;
                }
            }
            if (isCheesed) {
                cheesedDifficultyRatings.push(difficultSlider.difficultyRating);
            }
        }
        return cheesedDifficultyRatings;
    }
    /**
     * Calculates the slider cheese penalty.
     */
    calculateSliderCheesePenalty(cheesedDifficultyRatings) {
        const summedDifficultyRating = Math.min(1, cheesedDifficultyRatings.reduce((a, v) => a + v, 0));
        return {
            aimPenalty: Math.max(this.difficultyAttributes.sliderFactor, Math.pow(1 -
                summedDifficultyRating *
                    this.difficultyAttributes.sliderFactor, 2)),
            flashlightPenalty: Math.max(this.difficultyAttributes.flashlightSliderFactor, Math.pow(1 -
                summedDifficultyRating *
                    this.difficultyAttributes.flashlightSliderFactor, 2)),
            visualPenalty: Math.max(this.difficultyAttributes.visualSliderFactor, Math.pow(1 -
                summedDifficultyRating *
                    this.difficultyAttributes.visualSliderFactor, 2)),
        };
    }
    getCursorPosition(cursor) {
        if (this.isHardRock) {
            return new osuBase.Vector2(cursor.position.x, osuBase.Playfield.baseSize.y - cursor.position.y);
        }
        return cursor.position;
    }
}

/**
 * Utility to check whether or not a beatmap is three-fingered for rebalance scores.
 */
class ThreeFingerChecker {
    /**
     * @param beatmap The beatmap to analyze.
     * @param data The data of the replay.
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    constructor(beatmap, data, difficultyAttributes) {
        /**
         * Extended sections of the beatmap for drag detection.
         */
        this.beatmapSections = [];
        /**
         * A reprocessed break points to match right on object time.
         *
         * This is used to increase detection accuracy since break points do not start right at the
         * start of the hitobject before it and do not end right at the first hitobject after it.
         */
        this.breakPointAccurateTimes = [];
        /**
         * A cursor occurrence nested array that only contains `movementType.DOWN` movement ID occurrences.
         *
         * Each index represents the cursor index.
         */
        this.downCursorInstances = [];
        /**
         * Nerf factors from all sections that were three-fingered.
         */
        this.nerfFactors = [];
        this.beatmap = beatmap;
        this.data = data;
        this.difficultyAttributes = difficultyAttributes;
        this.isHardRock = difficultyAttributes.mods.has(osuBase.ModHardRock);
        this.hitWindow = difficultyAttributes.mods.has(osuBase.ModPrecise)
            ? new osuBase.PreciseDroidHitWindow(beatmap.difficulty.od)
            : new osuBase.DroidHitWindow(beatmap.difficulty.od);
    }
    /**
     * Checks whether a beatmap is eligible to be detected for 3-finger.
     *
     * @param difficultyAttributes The difficulty attributes of the beatmap.
     */
    static isEligibleToDetect(difficultyAttributes) {
        return difficultyAttributes.possibleThreeFingeredSections.length > 0;
    }
    /**
     * Checks if the given beatmap is 3-fingered and also returns the final penalty.
     *
     * The beatmap will be separated into sections and each section will be determined
     * whether or not it is dragged.
     *
     * After that, each section will be assigned a nerf factor based on whether or not
     * the section is 3-fingered. These nerf factors will be summed up into a final
     * nerf factor, taking beatmap difficulty into account.
     */
    check() {
        if (!ThreeFingerChecker.isEligibleToDetect(this.difficultyAttributes) ||
            this.data.cursorMovement.filter((v) => v.occurrenceGroups.length > 0).length <= 3) {
            return { is3Finger: false, penalty: 1 };
        }
        this.getAccurateBreakPoints();
        this.filterCursorInstances();
        if (this.downCursorInstances.filter((v) => v.length > 0).length <= 3) {
            return { is3Finger: false, penalty: 1 };
        }
        this.getBeatmapSections();
        this.calculateNerfFactors();
        const finalPenalty = this.calculateFinalPenalty();
        return { is3Finger: finalPenalty > 1, penalty: finalPenalty };
    }
    /**
     * Generates a new set of "accurate break points".
     *
     * This is done to increase detection accuracy since break points do not start right at the
     * end of the hitobject before it and do not end right at the first hitobject after it.
     */
    getAccurateBreakPoints() {
        const objects = this.beatmap.hitObjects.objects;
        const objectData = this.data.hitObjectData;
        for (const breakPoint of this.beatmap.events.breaks) {
            const beforeIndex = osuBase.MathUtils.clamp(objects.findIndex((o) => o.endTime >= breakPoint.startTime) - 1, 0, objects.length - 2);
            const objectBefore = objects[beforeIndex];
            const objectBeforeData = objectData[beforeIndex];
            let timeBefore = objectBefore.endTime;
            if (objectBefore instanceof osuBase.Circle) {
                if (objectBeforeData.result !== exports.HitResult.miss) {
                    timeBefore += objectBeforeData.accuracy;
                }
                else {
                    timeBefore += this.hitWindow.mehWindow;
                }
            }
            const afterIndex = beforeIndex + 1;
            const objectAfter = objects[afterIndex];
            const objectAfterData = objectData[afterIndex];
            let timeAfter = objectAfter.startTime;
            if (objectAfter instanceof osuBase.Circle &&
                objectAfterData.result !== exports.HitResult.miss) {
                timeAfter += objectAfterData.accuracy;
            }
            this.breakPointAccurateTimes.push(new osuBase.BreakPoint({
                startTime: timeBefore,
                endTime: timeAfter,
            }));
        }
    }
    /**
     * Filters the original cursor instances, returning only those with `movementType.DOWN` movement ID.
     *
     * This also filters cursors that are in break period or happen before start/after end of the beatmap.
     */
    filterCursorInstances() {
        const objects = this.beatmap.hitObjects.objects;
        const objectData = this.data.hitObjectData;
        const firstObjectResult = objectData[0].result;
        const lastObjectResult = objectData.at(-1).result;
        const firstObject = objects[0];
        const lastObject = objects.at(-1);
        // For sliders, automatically set hit window length to be as lenient as possible.
        let firstObjectHitWindow = this.hitWindow.mehWindow;
        if (firstObject instanceof osuBase.Circle) {
            switch (firstObjectResult) {
                case exports.HitResult.great:
                    firstObjectHitWindow = this.hitWindow.greatWindow;
                    break;
                case exports.HitResult.good:
                    firstObjectHitWindow = this.hitWindow.okWindow;
                    break;
                default:
                    firstObjectHitWindow = this.hitWindow.mehWindow;
            }
        }
        // For sliders, automatically set hit window length to be as lenient as possible.
        let lastObjectHitWindow = this.hitWindow.mehWindow;
        if (lastObject instanceof osuBase.Circle) {
            switch (lastObjectResult) {
                case exports.HitResult.great:
                    lastObjectHitWindow = this.hitWindow.greatWindow;
                    break;
                case exports.HitResult.good:
                    lastObjectHitWindow = this.hitWindow.okWindow;
                    break;
                default:
                    lastObjectHitWindow = this.hitWindow.mehWindow;
            }
        }
        else if (lastObject instanceof osuBase.Slider) {
            lastObjectHitWindow = Math.min(lastObject.spanDuration, lastObjectHitWindow);
        }
        // These hit time uses hit window length as threshold.
        // This is because cursors aren't recorded exactly at hit time,
        // probably due to the game's behavior.
        const firstObjectHitTime = firstObject.startTime - firstObjectHitWindow;
        const lastObjectHitTime = lastObject.startTime + lastObjectHitWindow;
        for (const cursorInstance of this.data.cursorMovement) {
            const validOccurrences = [];
            for (const group of cursorInstance.occurrenceGroups) {
                if (group.startTime < firstObjectHitTime) {
                    continue;
                }
                if (group.startTime > lastObjectHitTime) {
                    break;
                }
                if (this.breakPointAccurateTimes.some((v) => group.startTime >= v.startTime &&
                    group.endTime <= v.endTime)) {
                    continue;
                }
                validOccurrences.push(group.down);
            }
            this.downCursorInstances.push(validOccurrences);
        }
    }
    /**
     * Divides the beatmap into sections, which will be used to
     * detect dragged sections and improve detection speed.
     */
    getBeatmapSections() {
        const beatmapObjects = this.beatmap.hitObjects.objects;
        const aimCursorGroupLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 0);
        // This intentionally starts from 1 because we need to look at the previous cursor.
        const aimCursorLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 1);
        const pressCursorLookupIndices = osuBase.Utils.initializeArray(this.downCursorInstances.length, 0);
        for (const section of this.difficultyAttributes
            .possibleThreeFingeredSections) {
            const objects = [];
            for (let i = section.firstObjectIndex; i <= section.lastObjectIndex; ++i) {
                const object = beatmapObjects[i];
                const objectData = this.data.hitObjectData[i];
                objects.push({
                    object: object,
                    aimingCursorInstanceIndex: this.getObjectAimIndex(object, objectData, aimCursorGroupLookupIndices, aimCursorLookupIndices),
                    pressingCursorInstanceIndex: this.getObjectPressIndex(object, objectData, pressCursorLookupIndices),
                });
            }
            this.beatmapSections.push(Object.assign(Object.assign({}, section), { objects: objects }));
        }
    }
    /**
     * Obtains the index of the cursor that aimed the object at the nearest time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorInstanceIndices The cursor indices to start looking for the cursor instance from, to save computation time.
     * @param cursorGroupIndices The cursor indices to start looking for the cursor group from, to save computation time.
     * @param cursorIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    getObjectAimIndex(object, objectData, cursorGroupIndices, cursorIndices) {
        if (objectData.result === exports.HitResult.miss || object instanceof osuBase.Spinner) {
            return -1;
        }
        // Check for sliderbreaks and treat them as misses.
        if (object instanceof osuBase.Slider &&
            (-this.hitWindow.mehWindow > objectData.accuracy ||
                objectData.accuracy >
                    Math.min(this.hitWindow.mehWindow, object.duration))) {
            return -1;
        }
        const hitTime = object.startTime + objectData.accuracy;
        const objectPosition = object.getStackedPosition(osuBase.Modes.droid);
        // We are maintaining the closest distance to the object.
        // This is because the radius that is calculated is using an estimation.
        // As such, it does not reflect the actual object radius in gameplay.
        let closestDistance = Number.POSITIVE_INFINITY;
        let nearestCursorIndex = -1;
        // Observe the cursor position at the object's hit time.
        for (let i = 0; i < this.data.cursorMovement.length; ++i) {
            const cursorData = this.data.cursorMovement[i];
            for (let j = cursorGroupIndices[i]; j < cursorData.occurrenceGroups.length; cursorGroupIndices[i] = ++j) {
                const cursorGroup = cursorData.occurrenceGroups[j];
                if (cursorGroup.endTime < hitTime) {
                    // Reset cursor index pointer.
                    cursorIndices[i] = 1;
                    continue;
                }
                if (cursorGroup.startTime > hitTime) {
                    break;
                }
                const cursors = cursorGroup.allOccurrences;
                for (let k = cursorIndices[i]; k < cursors.length; cursorIndices[i] = ++k) {
                    const cursor = cursors[k];
                    const prevCursor = cursors[k - 1];
                    // Cursor is past the object's hit time.
                    if (prevCursor.time > hitTime) {
                        break;
                    }
                    // Cursor is before the object's hit time.
                    if (hitTime > cursor.time) {
                        continue;
                    }
                    let distance;
                    const currentPosition = this.getCursorPosition(cursor);
                    const prevPosition = this.getCursorPosition(prevCursor);
                    switch (cursor.id) {
                        case exports.MovementType.up:
                            distance = prevPosition.getDistance(objectPosition);
                            break;
                        case exports.MovementType.move: {
                            // Interpolate movement.
                            const t = (hitTime - prevCursor.time) /
                                (cursor.time - prevCursor.time);
                            const cursorPosition = osuBase.Interpolation.lerp(prevPosition, currentPosition, t);
                            distance =
                                objectPosition.getDistance(cursorPosition);
                            break;
                        }
                        case exports.MovementType.down:
                            continue;
                    }
                    if (closestDistance > distance) {
                        closestDistance = distance;
                        nearestCursorIndex = i;
                    }
                }
                // Reset cursor index pointer on end of group.
                if (cursorIndices[i] === cursors.length) {
                    cursorIndices[i] = 1;
                }
                break;
            }
            // The previous object may still be hit with the same cursor group or cursor index.
            cursorGroupIndices[i] = Math.max(0, cursorGroupIndices[i] - 1);
            cursorIndices[i] = Math.max(1, cursorIndices[i] - 1);
        }
        return nearestCursorIndex;
    }
    /**
     * Obtains the index of the nearest cursor of which an object was pressed in terms of time.
     *
     * @param object The object to obtain the index for.
     * @param objectData The hit data of the object.
     * @param cursorLookupIndices The cursor indices to start looking for the cursor from, to save computation time.
     * @param excludedIndices The cursor indices that should not be checked.
     * @returns The index of the cursor, -1 if the object was missed or it's a spinner.
     */
    getObjectPressIndex(object, objectData, cursorLookupIndices) {
        if (objectData.result === exports.HitResult.miss || object instanceof osuBase.Spinner) {
            return -1;
        }
        // Check for sliderbreaks and treat them as misses.
        if (object instanceof osuBase.Slider &&
            (-this.hitWindow.mehWindow > objectData.accuracy ||
                objectData.accuracy >
                    Math.min(this.hitWindow.mehWindow, object.duration))) {
            return -1;
        }
        const hitTime = object.startTime + objectData.accuracy;
        let nearestCursorInstanceIndex = -1;
        let nearestTime = Number.POSITIVE_INFINITY;
        for (let i = 0; i < this.downCursorInstances.length; ++i) {
            const cursors = this.downCursorInstances[i];
            let cursorNearestTime = Number.POSITIVE_INFINITY;
            for (let j = cursorLookupIndices[i]; j < cursors.length; cursorLookupIndices[i] = ++j) {
                const cursor = cursors[j];
                if (cursor.time > hitTime) {
                    break;
                }
                cursorNearestTime = hitTime - cursor.time;
            }
            if (cursorNearestTime < nearestTime) {
                nearestCursorInstanceIndex = i;
                nearestTime = cursorNearestTime;
            }
        }
        return nearestCursorInstanceIndex;
    }
    /**
     * Creates nerf factors by scanning through objects.
     */
    calculateNerfFactors() {
        for (const beatmapSection of this.beatmapSections) {
            const threeFingerCursorCounts = osuBase.Utils.initializeArray(Math.max(0, this.downCursorInstances.length - 2), 0);
            for (const object of beatmapSection.objects) {
                if (object.pressingCursorInstanceIndex === -1) {
                    continue;
                }
                if (object.aimingCursorInstanceIndex < 3) {
                    // The aim cursor is in the first three cursors. They are counted as non-3 finger.
                    switch (object.pressingCursorInstanceIndex) {
                        case 0:
                        case 1:
                        case 2:
                            break;
                        default:
                            ++threeFingerCursorCounts[object.pressingCursorInstanceIndex - 3];
                            break;
                    }
                }
                else {
                    // The aim cursor is somewhere else. only count the first 2 cursors as non-3 finger.
                    switch (object.pressingCursorInstanceIndex) {
                        case 0:
                        case 1:
                            break;
                        default:
                            ++threeFingerCursorCounts[object.pressingCursorInstanceIndex - 2];
                            break;
                    }
                }
            }
            const threeFingerCursorCount = threeFingerCursorCounts.reduce((a, v) => a + v, 0);
            if (threeFingerCursorCount === 0) {
                continue;
            }
            const sectionObjectCount = beatmapSection.objects.length;
            const threeFingeredObjectRatio = threeFingerCursorCount / sectionObjectCount;
            const strainFactor = Math.max(1, beatmapSection.sumStrain * threeFingeredObjectRatio);
            // Finger factor applies more penalty if more fingers were used.
            const fingerFactor = threeFingerCursorCounts.reduce((acc, count, index) => acc +
                Math.pow(((index + 1) * count) / sectionObjectCount, 0.9), 1);
            // Length factor applies more penalty if there are more 3-fingered object.
            const lengthFactor = 1 + Math.pow(threeFingeredObjectRatio, 0.8);
            this.nerfFactors.push({
                strainFactor: strainFactor,
                fingerFactor: fingerFactor,
                lengthFactor: lengthFactor,
            });
        }
    }
    /**
     * Calculates the final penalty.
     */
    calculateFinalPenalty() {
        return this.nerfFactors.reduce((a, n) => a +
            0.015 *
                Math.pow(n.strainFactor * n.fingerFactor * n.lengthFactor, 1.05), 1);
    }
    getCursorPosition(cursor) {
        if (this.isHardRock) {
            return new osuBase.Vector2(cursor.position.x, osuBase.Playfield.baseSize.y - cursor.position.y);
        }
        return cursor.position;
    }
}

/**
 * Contains information about which cursor index hits a hitobject.
 */
class IndexedHitObject {
    /**
     * @param object The underlying hitobject.
     * @param cursorIndex The cursor index that moves towards the hitobject.
     * @param groupIndex The group index of the cursor within the cursor index that hits the hitobject.
     * @param occurrenceIndex The occurrence index within the group of the cursor within the cursor index that hits the hitobject.
     * @param angle The angle of the movement of the cursor that moves towards the hitobject.
     */
    constructor(object, cursorIndex, groupIndex, occurrenceIndex, angle, is2Handed) {
        /**
         * If this is a slider, whether the slider was cheesed.
         */
        this.sliderCheesed = false;
        this.object = object;
        this.cursorIndex = cursorIndex;
        this.groupIndex = groupIndex;
        this.occurrenceIndex = occurrenceIndex;
        this.angle = angle;
        this.is2Handed = is2Handed;
        this.endCursorPosition = this.object.getStackedEndPosition(osuBase.Modes.droid);
    }
}

// import { writeFileSync } from "fs";
/**
 * Utility to check whether or not a beatmap is two-handed.
 */
class TwoHandChecker {
    // private csvString: string;
    /**
     * @param beatmap The beatmap to analyze.
     * @param attributes The difficulty attributes to analyze.
     * @param data The data of the replay.
     */
    constructor(beatmap, attributes, data) {
        /**
         * The hitobjects of the beatmap that have been assigned with their respective cursor index.
         */
        this.indexedHitObjects = [];
        this.beatmap = beatmap;
        this.attributes = attributes;
        this.data = data;
        const greatWindow = new osuBase.OsuHitWindow(attributes.overallDifficulty).greatWindow *
            attributes.clockRate;
        this.hitWindow = attributes.mods.has(osuBase.ModPrecise)
            ? new osuBase.PreciseDroidHitWindow(osuBase.PreciseDroidHitWindow.greatWindowToOD(greatWindow))
            : new osuBase.DroidHitWindow(osuBase.DroidHitWindow.greatWindowToOD(greatWindow));
        this.isHardRock = attributes.mods.has(osuBase.ModHardRock);
        // this.csvString = `Mods,${
        //     data.convertedMods.reduce((a, m) => a + m.acronym, "") || "NM"
        // }\nCombo,${data.maxCombo}\nAccuracy,"${(
        //     data.accuracy.value() * 100
        // ).toFixed(2)}% [${data.accuracy.n300}/${data.accuracy.n100}/${
        //     data.accuracy.n50
        // }/${
        //     data.accuracy.nmiss
        // }]"\n\nIndex,Type,StartTime,EndTime,DeltaTime,CursorIndex,GroupIndex,CursorDuration\n`;
    }
    /**
     * Checks if a beatmap is two-handed.
     */
    check() {
        if (this.data.cursorMovement.filter((v) => v.occurrenceGroups.length > 0).length <= 1) {
            return { is2Hand: false, twoHandedNoteCount: 0 };
        }
        this.indexHitObjects();
        // this.applyPenalty();
        // for (let i = 0; i < this.calculator.objects.length; ++i) {
        //     const object: PlaceableHitObject =
        //         this.calculator.objects[i].object;
        //     if (object instanceof Spinner) {
        //         continue;
        //     }
        //     let deltaTime: number = 0;
        //     if (i > 0) {
        //         const prevObject: PlaceableHitObject =
        //             this.calculator.objects[i - 1].object;
        //         deltaTime = Math.max(
        //             object.startTime - prevObject.startTime,
        //             25
        //         );
        //         if (prevObject instanceof Slider) {
        //             deltaTime = Math.max(
        //                 deltaTime - prevObject.lazyTravelTime,
        //                 25
        //             );
        //         }
        //     }
        //     const objectInfo = this.getCursorPositionForObjectStart(i);
        //     this.csvString += `${i},${object.typeStr()},${object.startTime},${
        //         object instanceof Slider
        //             ? object.startTime + object.lazyTravelTime
        //             : object.endTime
        //     },${deltaTime},${objectInfo.cursorIndex},${objectInfo.groupIndex},${
        //         this.data.cursorMovement[objectInfo.cursorIndex]
        //             ?.occurrenceGroups[objectInfo.groupIndex]?.duration ??
        //         Number.POSITIVE_INFINITY
        //     }\n`;
        // }
        // writeFileSync(
        //     join(
        //         process.cwd(),
        //         "files",
        //         `${this.data.playerName} - ${this.calculator.beatmap.metadata.fullTitle}.csv`
        //     ),
        //     this.csvString
        // );
        // let twoHandedNoteCount = 0;
        // const maxStrain = Math.max(
        //     ...this.attributes.objects.map((v) => v.aimStrainWithSliders),
        // );
        // if (maxStrain) {
        //     twoHandedNoteCount = this.indexedHitObjects.reduce(
        //         (total, object) => {
        //             if (!object.is2Handed) {
        //                 return total;
        //             }
        //             return (
        //                 total +
        //                 1 /
        //                     (1 +
        //                         Math.exp(
        //                             -(
        //                                 (object.object.aimStrainWithSliders /
        //                                     maxStrain) *
        //                                     12 -
        //                                 6
        //                             ),
        //                         ))
        //             );
        //         },
        //         0,
        //     );
        // }
        return {
            is2Hand: 0 > this.attributes.aimNoteCount * 0.15,
            twoHandedNoteCount: 0,
        };
    }
    /**
     * Converts hitobjects into indexed hit objects.
     */
    indexHitObjects() {
        const indexes = [];
        for (let i = 0; i < this.data.hitObjectData.length; ++i) {
            const indexedHitObject = this.getIndexedHitObject(i);
            indexedHitObject.sliderCheesed = this.checkSliderCheesing(indexedHitObject, this.data.hitObjectData[i]);
            indexes.push(indexedHitObject.cursorIndex);
            this.indexedHitObjects.push(indexedHitObject);
        }
        // console.log("Aim note count:", this.calculator.attributes.aimNoteCount);
        // console.log(
        //     this.indexedHitObjects.filter((v) => v.cursorIndex !== -1).length +
        //         1,
        //     "indexes found,",
        //     this.indexedHitObjects.filter((v) => v.cursorIndex === -1).length -
        //         1,
        //     "not found,",
        //     this.indexedHitObjects.filter((v) => v.is2Handed).length,
        //     "2 handed,",
        //     this.indexedHitObjects.filter((v) => !v.is2Handed).length,
        //     "not 2 handed"
        // );
        // for (let i = 0; i < this.data.cursorMovement.length; ++i) {
        //     console.log(
        //         "Index",
        //         i,
        //         "count:",
        //         this.indexedHitObjects.filter((v) => v.cursorIndex === i).length
        //     );
        // }
        // TODO: solve -1 cursor indexes
        // console.table(
        //     this.indexedHitObjects
        //         .filter(
        //             (v) =>
        //                 // v.cursorIndex === -1 &&
        //                 // v.object.aimStrainWithSliders > 200 &&
        //                 v.object.deltaTime > 75 && v.is2Handed
        //         )
        //         .map((v) => {
        //             return {
        //                 startTime: v.object.object.startTime,
        //                 type: v.object.object.typeStr(),
        //                 strain: v.object.aimStrainWithSliders,
        //                 hitAngle:
        //                     v.angle !== null
        //                         ? MathUtils.radiansToDegrees(v.angle)
        //                         : null,
        //                 objectAngle:
        //                     v.object.angle !== null
        //                         ? MathUtils.radiansToDegrees(v.object.angle)
        //                         : null,
        //                 cursorIndex: v.cursorIndex,
        //             };
        //         })
        // );
    }
    /**
     * Gets the cursor index that hits the given object.
     *
     * @param objectIndex The index of the object to check.
     * @returns The cursor index that hits the given object, -1 if the index is not found, the object is a spinner, or the object was missed.
     */
    getIndexedHitObject(objectIndex) {
        const object = this.beatmap.hitObjects.objects[objectIndex];
        // We don't care about the first object and spinners.
        if (objectIndex === 0 || object instanceof osuBase.Spinner) {
            return new IndexedHitObject(object, -1, -1, -1, null, false);
        }
        // We don't care if the aim strain is too low.
        // if (diffObject.aimStrainWithSliders < 200) {
        //     return new IndexedHitObject(diffObject, -1, -1, -1, null, false);
        // }
        const prevObject = this.beatmap.hitObjects.objects[objectIndex - 1];
        const prevObjectData = this.data.hitObjectData[objectIndex - 1];
        if (prevObject instanceof osuBase.Spinner ||
            prevObjectData.result === exports.HitResult.miss) {
            return new IndexedHitObject(object, -1, -1, -1, null, false);
        }
        const objectStartPosition = object.getStackedPosition(osuBase.Modes.droid);
        let prevObjectEndPosition = prevObject.getStackedEndPosition(osuBase.Modes.droid);
        if (prevObject instanceof osuBase.Slider) {
            if (prevObject.lazyTravelDistance > 0) {
                const lazyEndMovement = objectStartPosition.subtract(prevObject.lazyEndPosition);
                const actualEndMovement = objectStartPosition.subtract(prevObjectEndPosition);
                if (lazyEndMovement.length < actualEndMovement.length) {
                    prevObjectEndPosition = prevObject.lazyEndPosition;
                }
            }
            else {
                prevObjectEndPosition = prevObject.getStackedPosition(osuBase.Modes.droid);
            }
        }
        const prevToCurrentMovement = object
            .getStackedPosition(osuBase.Modes.droid)
            .subtract(prevObjectEndPosition);
        // Don't consider objects that are too close to each other.
        if (prevToCurrentMovement.length <= object.radius) {
            return new IndexedHitObject(object, -1, -1, -1, null, false);
        }
        // The case for a one-handed object is that there will be a slight movement in the cursor towards
        // the next object in fast patterns. We should not be worried about slow patterns as they will only
        // make a minimal difference and aim strain threshold should filter them out.
        // In order to verify if the player does that, we check if the movement towards the current
        // object is sufficient enough to be two-handed. This is done by first gathering info about two cursor positions:
        // 1. The cursor position at the end of the previous object
        // 2. The cursor position that presses the current object
        // and then get the movement vector between both positions, then see if the cursor movement after the previous object
        // was pressed produces an angle that is acute enough with respect to the aforementioned movement vector.
        // If the angle isn't fulfilled, check for the "initial velocity", which is the movement velocity from the
        // previous object's end time to the current object's start time and the "air velocity", which is the
        // velocity from the previous object's cursor release time to the next object's cursor press time. If the velocity
        // during the held tap is significantly less than the estimated velocity, it's considered two hand.
        const objectInformation = this.getCursorPositionForObjectStart(objectIndex);
        const prevObjectInformation = this.getCursorPositionForObjectEnd(objectIndex - 1);
        this.indexedHitObjects[objectIndex - 1].endCursorPosition =
            prevObjectInformation.position;
        if (prevObjectInformation.position.x === Number.POSITIVE_INFINITY) {
            return new IndexedHitObject(object, -1, -1, -1, null, false);
        }
        if (prevObjectInformation.cursorIndex ===
            objectInformation.cursorIndex &&
            prevObjectInformation.groupIndex === objectInformation.groupIndex) {
            return new IndexedHitObject(object, objectInformation.cursorIndex, objectInformation.groupIndex, prevObjectInformation.occurrenceIndex, 0, false);
        }
        const cursorData = this.data.cursorMovement[prevObjectInformation.cursorIndex];
        // There can be multiple angles to which the cursor moves towards the next object.
        // For this, we take the smallest angle.
        let finalAngle = Number.POSITIVE_INFINITY;
        const cursorGroup = cursorData.occurrenceGroups[prevObjectInformation.groupIndex];
        const cursors = cursorGroup.allOccurrences;
        const prevToCurrentCursorMovement = objectInformation.position.subtract(prevObjectInformation.position);
        for (let i = prevObjectInformation.occurrenceIndex + 1; i < cursors.length; ++i) {
            const cursor = cursors[i];
            const prevCursor = cursors[i - 1];
            const currentPosition = this.getCursorPosition(cursor);
            const prevPosition = this.getCursorPosition(prevCursor);
            if (currentPosition.equals(prevPosition)) {
                continue;
            }
            if (cursor.id === exports.MovementType.up) {
                break;
            }
            const currentMovement = currentPosition.subtract(prevPosition);
            const dot = prevToCurrentCursorMovement.dot(currentMovement);
            const det = prevToCurrentCursorMovement.x * currentMovement.y -
                prevToCurrentCursorMovement.y * currentMovement.x;
            const movementAngle = Math.abs(Math.atan2(det, dot));
            finalAngle = Math.min(finalAngle, movementAngle);
        }
        const is2Handed = finalAngle >= Math.PI / 6;
        // if (is2Handed) {
        //     // If angle isn't fulfilled, check for cursor velocity.
        //     let deltaTime: number = Math.max(
        //         object.startTime - prevObject.startTime,
        //         25
        //     );
        //     if (prevObject instanceof Slider) {
        //         deltaTime = Math.max(deltaTime - prevObject.lazyTravelTime, 25);
        //     }
        //     // "Initial velocity" is the movement velocity from the previous object's end time to the current object's start time.
        //     const initialVelocity: number =
        //         objectStartPosition.getDistance(prevObjectEndPosition) /
        //         deltaTime;
        //     // const finalCursor: CursorOccurrence =
        //     //     cursorGroup.moves.at(-1) ?? cursorGroup.down;
        //     const currentCursorGroup: CursorOccurrenceGroup =
        //         this.data.cursorMovement[objectInformation.cursorIndex]
        //             .occurrenceGroups[objectInformation.groupIndex];
        //     // const cursorDistance: number = currentCursorGroup.down.position.getDistance(
        //     //     finalCursor.position
        //     // );
        //     const cursorDuration: number = Math.max(
        //         0,
        //         currentCursorGroup.startTime - cursorGroup.endTime
        //     );
        //     // "Air velocity" is the cursor velocity from the moment the previous cursor release action to the next cursor press action.
        //     // const airVelocity: number = cursorDistance / cursorDuration;
        //     is2Handed =
        //         // airVelocity / initialVelocity < 0.8 &&
        //         cursorDuration / deltaTime > 0.2;
        //     for (
        //         let i = prevObjectInformation.occurrenceIndex + 1;
        //         i < cursors.length && is2Handed;
        //         ++i
        //     ) {
        //         const cursor: CursorOccurrence = cursors[i];
        //         const prevCursor: CursorOccurrence = cursors[i - 1];
        //         if (
        //             cursor.position.equals(prevCursor.position) ||
        //             cursor.time === prevCursor.time
        //         ) {
        //             continue;
        //         }
        //         if (cursor.id === MovementType.up) {
        //             break;
        //         }
        //         // "Cursor velocity" is the velocity from the previous object's cursor release time to the current object's press time.
        //         const cursorVelocity: number =
        //             cursor.position.getDistance(prevCursor.position) /
        //             (cursor.time - prevCursor.time);
        //         is2Handed = cursorVelocity / initialVelocity < 0.8;
        //     }
        // }
        if (!Number.isFinite(finalAngle)) {
            return new IndexedHitObject(object, -1, -1, -1, null, false);
        }
        return new IndexedHitObject(object, prevObjectInformation.cursorIndex, prevObjectInformation.groupIndex, prevObjectInformation.occurrenceIndex, finalAngle, is2Handed);
    }
    /**
     * Gets the position of the cursor that presses an object.
     *
     * @param objectIndex THe index of the object.
     * @returns The position of the cursor that presses the object.
     */
    getCursorPositionForObjectStart(objectIndex) {
        const object = this.beatmap.hitObjects.objects[objectIndex];
        const data = this.data.hitObjectData[objectIndex];
        const objectPosition = object.getStackedPosition(osuBase.Modes.droid);
        if (object instanceof osuBase.Spinner) {
            return {
                position: objectPosition,
                cursorIndex: 0,
                groupIndex: Number.POSITIVE_INFINITY,
                occurrenceIndex: Number.POSITIVE_INFINITY,
                cursorTime: object.startTime,
            };
        }
        let hitWindow = this.hitWindow.mehWindow;
        // For sliders, set the hit window to as lenient as possible.
        if (object instanceof osuBase.Circle) {
            switch (data.result) {
                case exports.HitResult.great:
                    hitWindow = this.hitWindow.greatWindow;
                    break;
                case exports.HitResult.good:
                    hitWindow = this.hitWindow.okWindow;
                    break;
            }
        }
        // TODO: what to do for head sliderbreaks?
        let nearestPosition = new osuBase.Vector2(Number.POSITIVE_INFINITY);
        let nearestCursorIndex = 0;
        let nearestGroupIndex = 0;
        let nearestCursorGroupIndex = 0;
        let nearestCursorTime = 0;
        const minimumActiveTime = object.startTime - hitWindow;
        const maximumActiveTime = object.startTime + hitWindow;
        for (let i = 0; i < this.data.cursorMovement.length; ++i) {
            if (nearestPosition.getDistance(objectPosition) <= object.radius) {
                break;
            }
            const cursorData = this.data.cursorMovement[i];
            for (let j = 0; j < cursorData.occurrenceGroups.length; ++j) {
                if (nearestPosition.getDistance(objectPosition) <= object.radius) {
                    break;
                }
                const cursorGroup = cursorData.occurrenceGroups[j];
                if (cursorGroup.endTime < minimumActiveTime) {
                    continue;
                }
                if (cursorGroup.startTime > maximumActiveTime) {
                    break;
                }
                // Validate the down press first.
                const { down } = cursorGroup;
                const downPosition = this.getCursorPosition(down);
                if (downPosition.getDistance(objectPosition) <= object.radius &&
                    Math.abs(down.time - object.startTime) <= hitWindow) {
                    if (objectIndex > 0) {
                        const prevObject = this.beatmap.hitObjects.objects[objectIndex - 1];
                        if (down.time > prevObject.endTime) {
                            return {
                                position: downPosition,
                                cursorIndex: i,
                                groupIndex: j,
                                occurrenceIndex: 0,
                                cursorTime: down.time,
                            };
                        }
                    }
                    else {
                        return {
                            position: downPosition,
                            cursorIndex: i,
                            groupIndex: j,
                            occurrenceIndex: 0,
                            cursorTime: down.time,
                        };
                    }
                }
                const cursors = cursorGroup.allOccurrences;
                for (let k = 1; k < cursors.length; ++k) {
                    const cursor = cursors[k];
                    const prevCursor = cursors[k - 1];
                    if (cursor.time < minimumActiveTime) {
                        continue;
                    }
                    if (prevCursor.time > maximumActiveTime) {
                        break;
                    }
                    let cursorPosition;
                    if (cursor.id === exports.MovementType.up) {
                        cursorPosition = this.getCursorPosition(prevCursor);
                        const distance = cursorPosition.getDistance(objectPosition);
                        if (distance <
                            nearestPosition.getDistance(objectPosition)) {
                            nearestPosition = cursorPosition;
                            nearestCursorIndex = i;
                            nearestGroupIndex = j;
                            nearestCursorGroupIndex = k;
                            nearestCursorTime = prevCursor.time;
                        }
                    }
                    else {
                        // Check for cursor presses inbetween occurrences.
                        for (let k = 0; k < this.data.cursorMovement.length; ++k) {
                            // Skip the current cursor index.
                            if (k === i) {
                                continue;
                            }
                            const cursorGroup = this.data.cursorMovement[k].occurrenceGroups.find((v) => v.down.time >= prevCursor.time &&
                                v.down.time <= cursor.time);
                            if (!cursorGroup) {
                                continue;
                            }
                            const t = (cursorGroup.down.time - prevCursor.time) /
                                (cursor.time - prevCursor.time);
                            cursorPosition = osuBase.Interpolation.lerp(this.getCursorPosition(prevCursor), this.getCursorPosition(cursor), t);
                            const distance = cursorPosition.getDistance(objectPosition);
                            if (distance <
                                nearestPosition.getDistance(objectPosition)) {
                                nearestPosition = cursorPosition;
                                nearestCursorIndex = i;
                                nearestGroupIndex = j;
                                nearestCursorGroupIndex = k;
                                nearestCursorTime = cursorGroup.down.time;
                            }
                            if (distance <= object.radius) {
                                break;
                            }
                        }
                    }
                    if (nearestPosition.getDistance(objectPosition) <=
                        object.radius) {
                        break;
                    }
                }
            }
        }
        if (nearestPosition.getDistance(objectPosition) ===
            Number.POSITIVE_INFINITY) {
            return {
                position: nearestPosition,
                cursorIndex: Number.POSITIVE_INFINITY,
                groupIndex: Number.POSITIVE_INFINITY,
                occurrenceIndex: Number.POSITIVE_INFINITY,
                cursorTime: object.startTime,
            };
        }
        return {
            position: nearestPosition,
            cursorIndex: nearestCursorIndex,
            groupIndex: nearestGroupIndex,
            occurrenceIndex: nearestCursorGroupIndex,
            cursorTime: nearestCursorTime,
        };
    }
    /**
     * Gets the position of the cursor that at an object's end position.
     *
     * @param objectIndex THe index of the object.
     * @returns The position of the cursor at the object's end position.
     */
    getCursorPositionForObjectEnd(objectIndex) {
        const object = this.beatmap.hitObjects.objects[objectIndex];
        if (!(object instanceof osuBase.Slider)) {
            return this.getCursorPositionForObjectStart(objectIndex);
        }
        const nextObject = this.beatmap.hitObjects.objects[objectIndex - 1];
        let objectEndPosition = object.getStackedEndPosition(osuBase.Modes.droid);
        if (object.lazyTravelDistance > 0 && nextObject) {
            const nextStartPosition = nextObject.getStackedPosition(osuBase.Modes.droid);
            const lazyEndMovement = nextStartPosition.subtract(object.lazyEndPosition);
            const actualEndMovement = nextStartPosition.subtract(objectEndPosition);
            if (lazyEndMovement.length < actualEndMovement.length) {
                objectEndPosition = object.lazyEndPosition;
            }
        }
        else {
            objectEndPosition = object.getStackedPosition(osuBase.Modes.droid);
        }
        let nearestPosition = new osuBase.Vector2(Number.POSITIVE_INFINITY);
        let nearestCursorIndex = 0;
        let nearestGroupIndex = 0;
        let nearestCursorGroupIndex = 0;
        let nearestCursorTime = 0;
        for (let i = 0; i < this.data.cursorMovement.length; ++i) {
            const cursorData = this.data.cursorMovement[i];
            for (let j = 0; j < cursorData.occurrenceGroups.length; ++j) {
                const cursorGroup = cursorData.occurrenceGroups[j];
                if (cursorGroup.endTime < object.startTime) {
                    continue;
                }
                if (cursorGroup.startTime > object.endTime) {
                    break;
                }
                const cursors = cursorGroup.allOccurrences;
                for (let k = 0; k < cursors.length; ++k) {
                    const cursor = cursors[k];
                    let cursorPosition;
                    switch (cursor.id) {
                        case exports.MovementType.down:
                            cursorPosition = this.getCursorPosition(cursor);
                            break;
                        case exports.MovementType.up: {
                            const prevCursor = cursors[k - 1];
                            cursorPosition = this.getCursorPosition(prevCursor);
                            break;
                        }
                        case exports.MovementType.move: {
                            const prevCursor = cursors[k - 1];
                            const t = osuBase.MathUtils.clamp((object.endTime - prevCursor.time) /
                                (cursor.time - prevCursor.time), 0, 1);
                            cursorPosition = osuBase.Interpolation.lerp(this.getCursorPosition(prevCursor), this.getCursorPosition(cursor), t);
                            break;
                        }
                    }
                    if (cursorPosition.getDistance(objectEndPosition) <
                        nearestPosition.getDistance(objectEndPosition)) {
                        nearestPosition = cursorPosition;
                        nearestCursorIndex = i;
                        nearestGroupIndex = j;
                        switch (cursor.id) {
                            case exports.MovementType.down:
                                nearestCursorGroupIndex = k;
                                nearestCursorTime = cursor.time;
                                break;
                            case exports.MovementType.up:
                                nearestCursorGroupIndex = k - 1;
                                nearestCursorTime = cursors[k - 1].time;
                                break;
                            case exports.MovementType.move:
                                nearestCursorGroupIndex = k;
                                nearestCursorTime = object.endTime;
                                break;
                        }
                    }
                }
            }
        }
        if (nearestPosition.getDistance(objectEndPosition) ===
            Number.POSITIVE_INFINITY) {
            return {
                position: nearestPosition,
                cursorIndex: Number.POSITIVE_INFINITY,
                groupIndex: Number.POSITIVE_INFINITY,
                occurrenceIndex: Number.POSITIVE_INFINITY,
                cursorTime: object.endTime,
            };
        }
        return {
            position: nearestPosition,
            cursorIndex: nearestCursorIndex,
            groupIndex: nearestGroupIndex,
            occurrenceIndex: nearestCursorGroupIndex,
            cursorTime: nearestCursorTime,
        };
    }
    /**
     * Checks whether a slider was cheesed.
     *
     * This is done by checking if a cursor follows a slider all the way to its end position.
     *
     * @param indexedHitObject The indexed slider.
     * @param hitData The hit data of the slider.
     * @returns Whether the slider was cheesed.
     */
    checkSliderCheesing(indexedHitObject, hitData) {
        if (!(indexedHitObject.object instanceof osuBase.Slider) ||
            hitData.result === exports.HitResult.miss ||
            indexedHitObject.cursorIndex === -1) {
            return false;
        }
        return false;
    }
    getCursorPosition(cursor) {
        if (this.isHardRock) {
            return new osuBase.Vector2(cursor.position.x, osuBase.Playfield.baseSize.y - cursor.position.y);
        }
        return cursor.position;
    }
}

/**
 * Represents a replay data in an osu!droid replay version 1 and 2.
 *
 * Stores generic information about an osu!droid replay.
 *
 * This is used when analyzing replays using replay analyzer.
 */
class ReplayData {
    constructor(values) {
        this.replayVersion = values.replayVersion;
        this.folderName = values.folderName;
        this.fileName = values.fileName;
        this.hash = values.hash;
        this.accuracy = values.accuracy;
        this.rank = values.rank;
        this.hit300k = values.hit300k;
        this.hit100k = values.hit100k;
        this.cursorMovement = values.cursorMovement;
        this.hitObjectData = values.hitObjectData;
    }
    /**
     * Whether the replay's version is 3 or later.
     */
    isReplayV3() {
        return this.replayVersion >= 3;
    }
}

/**
 * Represents a replay data for replay version 3.
 *
 * Stores generic information about an osu!droid replay.
 *
 * This is used when analyzing replays using replay analyzer.
 */
class ReplayV3Data extends ReplayData {
    constructor(values) {
        super(values);
        this.time = values.time;
        this.score = values.score;
        this.maxCombo = values.maxCombo;
        this.isFullCombo = values.isFullCombo;
        this.playerName = values.playerName;
        this.convertedMods = values.convertedMods;
    }
}

/**
 * A replay analyzer that analyzes a replay from osu!droid.
 *
 * Created by reverse engineering the replay parser from the game itself, which can be found {@link https://github.com/osudroid/osu-droid/blob/master/src/ru/nsu/ccfit/zuev/osu/scoring/Replay.java here}.
 *
 * Once analyzed, the result can be accessed via the `data` property.
 */
class ReplayAnalyzer {
    constructor(values) {
        /**
         * The original odr file of the replay.
         */
        this.originalODR = null;
        /**
         * The fixed odr file of the replay.
         */
        this.fixedODR = null;
        /**
         * The results of the analyzer. `null` when initialized.
         */
        this.data = null;
        /**
         * Penalty value used to penalize dpp for 2-hand.
         */
        this.aimPenalty = 1;
        /**
         * Penalty value used to penalize dpp for 3 finger abuse.
         */
        this.tapPenalty = 1;
        /**
         * Penalty values used to penalize dpp for slider cheesing.
         */
        this.sliderCheesePenalty = {
            aimPenalty: 1,
            flashlightPenalty: 1,
            visualPenalty: 1,
        };
        /**
         * Whether this replay has been checked against 3 finger usage.
         */
        this.hasBeenCheckedFor3Finger = false;
        /**
         * Whether this replay has been checked against 2 hand usage.
         */
        this.hasBeenCheckedFor2Hand = false;
        /**
         * Whether this replay has been checked against slider cheesing.
         */
        this.hasBeenCheckedForSliderCheesing = false;
        /**
         * The amount of two-handed objects.
         */
        this.twoHandedNoteCount = 0;
        this.bufferOffset = 0;
        this.scoreID = values === null || values === void 0 ? void 0 : values.scoreID;
        this.beatmap = values === null || values === void 0 ? void 0 : values.map;
        this.difficultyAttributes = values === null || values === void 0 ? void 0 : values.difficultyAttributes;
        if (this.beatmap instanceof osuBase.DroidPlayableBeatmap) {
            this.playableBeatmap = this.beatmap;
        }
    }
    /**
     * Analyzes a replay.
     */
    analyze() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.originalODR && !this.fixedODR) {
                this.originalODR = yield this.downloadReplay();
            }
            if (!this.originalODR) {
                return this;
            }
            if (!this.fixedODR) {
                this.fixedODR = yield this.decompress().catch(() => null);
            }
            if (!this.fixedODR) {
                return this;
            }
            this.parseReplay();
            return this;
        });
    }
    /**
     * Gets hit error information of the replay.
     *
     * `analyze()` must be called before calling this.
     */
    calculateHitError() {
        var _a, _b;
        if (!this.data || !this.beatmap) {
            return null;
        }
        const hitObjectData = this.data.hitObjectData;
        let positiveCount = 0;
        let negativeCount = 0;
        let positiveTotal = 0;
        let negativeTotal = 0;
        const { objects } = this.beatmap.hitObjects;
        const mods = this.data.isReplayV3()
            ? this.data.convertedMods
            : (_b = (_a = this.difficultyAttributes) === null || _a === void 0 ? void 0 : _a.mods) !== null && _b !== void 0 ? _b : new osuBase.ModMap();
        const adjustedDifficulty = new osuBase.BeatmapDifficulty(this.beatmap.difficulty);
        osuBase.ModUtil.applyModsToBeatmapDifficulty(adjustedDifficulty, osuBase.Modes.droid, mods);
        const mehWindow = mods.has(osuBase.ModPrecise)
            ? new osuBase.PreciseDroidHitWindow(adjustedDifficulty.od).mehWindow
            : new osuBase.DroidHitWindow(adjustedDifficulty.od).mehWindow;
        const accuracies = [];
        for (let i = 0; i < hitObjectData.length; ++i) {
            const v = hitObjectData[i];
            const o = objects[i];
            if (o instanceof osuBase.Spinner || v.result === exports.HitResult.miss) {
                continue;
            }
            const { accuracy } = v;
            if (o instanceof osuBase.Slider &&
                // Do not include slider breaks.
                (-mehWindow > accuracy ||
                    accuracy > Math.min(mehWindow, o.duration))) {
                continue;
            }
            accuracies.push(accuracy);
            if (accuracy >= 0) {
                positiveTotal += accuracy;
                ++positiveCount;
            }
            else {
                negativeTotal += accuracy;
                ++negativeCount;
            }
        }
        return {
            positiveAvg: positiveTotal / positiveCount || 0,
            negativeAvg: negativeTotal / negativeCount || 0,
            unstableRate: osuBase.MathUtils.calculateStandardDeviation(accuracies) * 10,
        };
    }
    /**
     * Checks if a play is using 3 fingers.
     *
     * Requires `analyze()` to be called first and `map` and `difficultyAttributes` to be defined.
     */
    checkFor3Finger() {
        var _a;
        if (!this.beatmap || !this.data || !this.difficultyAttributes) {
            return;
        }
        (_a = this.playableBeatmap) !== null && _a !== void 0 ? _a : (this.playableBeatmap = this.constructPlayableBeatmap());
        const threeFingerChecker = this.difficultyAttributes.mode === "rebalance"
            ? new RebalanceThreeFingerChecker(this.playableBeatmap, this.data, this.difficultyAttributes)
            : new ThreeFingerChecker(this.playableBeatmap, this.data, this.difficultyAttributes);
        const result = threeFingerChecker.check();
        this.is3Finger = result.is3Finger;
        this.tapPenalty = result.penalty;
        this.hasBeenCheckedFor3Finger = true;
    }
    /**
     * Checks if a play is using 2 hands.
     *
     * Requires `analyze()` to be called first as well as `beatmap` and `difficultyAttributes` to be defined.
     */
    checkFor2Hand() {
        var _a;
        if (!this.beatmap || !this.difficultyAttributes || !this.data) {
            return;
        }
        (_a = this.playableBeatmap) !== null && _a !== void 0 ? _a : (this.playableBeatmap = this.constructPlayableBeatmap());
        const twoHandChecker = new TwoHandChecker(this.playableBeatmap, this.difficultyAttributes, this.data);
        const result = twoHandChecker.check();
        this.is2Hand = result.is2Hand;
        this.twoHandedNoteCount = result.twoHandedNoteCount;
        this.hasBeenCheckedFor2Hand = true;
    }
    /**
     * Checks if a play has cheesed sliders.
     *
     * Requires `analyze()` to be called first and `map` and `difficultyAttributes` to be defined.
     */
    checkForSliderCheesing() {
        var _a;
        if (!this.beatmap || !this.data || !this.difficultyAttributes) {
            return;
        }
        (_a = this.playableBeatmap) !== null && _a !== void 0 ? _a : (this.playableBeatmap = this.constructPlayableBeatmap());
        const sliderCheeseChecker = new SliderCheeseChecker(this.playableBeatmap, this.data, this.difficultyAttributes);
        this.sliderCheesePenalty = sliderCheeseChecker.check();
        this.hasBeenCheckedForSliderCheesing = true;
    }
    /**
     * Downloads the given score ID's replay.
     */
    downloadReplay() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.scoreID === undefined) {
                return null;
            }
            const apiRequestBuilder = new osuBase.DroidAPIRequestBuilder()
                .setRequireAPIkey(false)
                .setEndpoint("upload")
                .addParameter("", `${this.scoreID}.odr`);
            const result = yield apiRequestBuilder.sendRequest();
            if (result.statusCode !== 200) {
                return null;
            }
            return result.data;
        });
    }
    /**
     * Decompresses a replay.
     *
     * The decompressed replay is in a form of Java object. This will be converted to a buffer and deserialized to read data from the replay.
     */
    decompress() {
        return new Promise((resolve, reject) => {
            const stream = new node_stream.Readable();
            stream.push(this.originalODR);
            stream.push(null);
            stream
                .pipe(unzipper.Parse())
                .on("entry", (entry) => __awaiter(this, void 0, void 0, function* () {
                const fileName = entry.path;
                if (fileName === "data") {
                    return resolve(yield entry.buffer());
                }
                else {
                    entry.autodrain();
                }
            }))
                .on("error", (e) => {
                setTimeout(() => reject(e), 2000);
            });
        });
    }
    /**
     * Parses a replay after being downloaded and converted to a buffer.
     */
    parseReplay() {
        if (!this.fixedODR) {
            return;
        }
        // javaDeserialization can only somewhat parse some string field
        // the rest will be a buffer that we need to manually parse
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let rawObject;
        try {
            rawObject = javaDeserialization__namespace.parse(this.fixedODR);
        }
        catch (_a) {
            return;
        }
        const resultObject = {
            replayVersion: rawObject[0].version,
            folderName: rawObject[1],
            fileName: rawObject[2],
            hash: rawObject[3],
            cursorMovement: [],
            hitObjectData: [],
            accuracy: new osuBase.Accuracy({ n300: 0 }),
            rank: "D",
            convertedMods: new osuBase.ModMap(),
            hit100k: 0,
            hit300k: 0,
            isFullCombo: false,
            maxCombo: 0,
            playerName: "",
            score: 0,
            time: new Date(0),
        };
        if (resultObject.replayVersion >= 3) {
            resultObject.time.setTime(Number(rawObject[4].readBigUInt64BE(0)));
            resultObject.hit300k = rawObject[4].readInt32BE(8);
            resultObject.accuracy.n300 = rawObject[4].readInt32BE(12);
            resultObject.hit100k = rawObject[4].readInt32BE(16);
            resultObject.accuracy.n100 = rawObject[4].readInt32BE(20);
            resultObject.accuracy.n50 = rawObject[4].readInt32BE(24);
            resultObject.accuracy.nmiss = rawObject[4].readInt32BE(28);
            resultObject.score = rawObject[4].readInt32BE(32);
            resultObject.maxCombo = rawObject[4].readInt32BE(36);
            resultObject.isFullCombo = resultObject.accuracy.value() === 1;
            resultObject.playerName = rawObject[5];
            if (resultObject.replayVersion >= 7) {
                resultObject.convertedMods = osuBase.ModUtil.deserializeMods(rawObject[6]);
            }
            else {
                resultObject.convertedMods = this.convertDroidMods(resultObject.replayVersion, Object.values(rawObject[6].elements));
                if (resultObject.replayVersion >= 4) {
                    osuBase.DroidLegacyModConverter.parseExtraModString(resultObject.convertedMods, rawObject[7].split("|"));
                }
            }
            resultObject.rank = this.calculateRank(resultObject);
        }
        let bufferIndex;
        switch (resultObject.replayVersion) {
            case 1:
            case 2:
                bufferIndex = 4;
                break;
            case 3:
            case 7:
                bufferIndex = 7;
                break;
            case 4:
            case 5:
            case 6:
                bufferIndex = 8;
                break;
            default:
                throw new Error("Unsupported replay version: " + resultObject.replayVersion);
        }
        const replayDataBufferArray = [];
        while (bufferIndex < rawObject.length) {
            replayDataBufferArray.push(rawObject[bufferIndex++]);
        }
        // Merge all cursor movement and hit object data section into one for better control when parsing
        const replayDataBuffer = Buffer.concat(replayDataBufferArray);
        this.bufferOffset = 0;
        this.parseMovementData(resultObject, replayDataBuffer);
        this.parseHitObjectData(resultObject, replayDataBuffer);
        this.parseOldReplayInformation(resultObject);
        switch (resultObject.replayVersion) {
            case 1:
            case 2:
                this.data = new ReplayData(resultObject);
                break;
            default:
                this.data = new ReplayV3Data(resultObject);
        }
    }
    /**
     * Converts replay mods to droid mod string.
     */
    convertDroidMods(replayVersion, replayMods) {
        const replayModsConstants = {
            MOD_AUTO: osuBase.ModAuto,
            MOD_AUTOPILOT: osuBase.ModAutopilot,
            MOD_NOFAIL: osuBase.ModNoFail,
            MOD_EASY: osuBase.ModEasy,
            MOD_HIDDEN: osuBase.ModHidden,
            MOD_TRACEABLE: osuBase.ModTraceable,
            MOD_HARDROCK: osuBase.ModHardRock,
            MOD_DOUBLETIME: osuBase.ModDoubleTime,
            MOD_HALFTIME: osuBase.ModHalfTime,
            MOD_NIGHTCORE: osuBase.ModNightCore,
            MOD_PRECISE: osuBase.ModPrecise,
            MOD_SMALLCIRCLE: osuBase.ModSmallCircle,
            MOD_REALLYEASY: osuBase.ModReallyEasy,
            MOD_RELAX: osuBase.ModRelax,
            MOD_PERFECT: osuBase.ModPerfect,
            MOD_SUDDENDEATH: osuBase.ModSuddenDeath,
            MOD_SCOREV2: osuBase.ModScoreV2,
            MOD_FLASHLIGHT: osuBase.ModFlashlight,
        };
        const map = new osuBase.ModMap();
        for (const mod of replayMods) {
            for (const property in Object(replayModsConstants)) {
                if (!mod.includes(property)) {
                    continue;
                }
                if (replayVersion <= 3 && mod === "MOD_NIGHTCORE") {
                    // In replay v3, the NightCore mod is bugged. See ModOldNightCore's description.
                    map.set(new osuBase.ModOldNightCore());
                }
                else {
                    map.set(replayModsConstants[property]);
                }
                break;
            }
        }
        return map;
    }
    parseMovementData(resultObject, replayDataBuffer) {
        resultObject.cursorMovement.length = 0;
        const size = this.readInt(replayDataBuffer);
        for (let i = 0; i < size; i++) {
            const moveSize = this.readInt(replayDataBuffer);
            const time = [];
            const x = [];
            const y = [];
            const id = [];
            for (let j = 0; j < moveSize; j++) {
                time[j] = this.readInt(replayDataBuffer);
                id[j] = time[j] & 3;
                time[j] >>= 2;
                if (id[j] !== exports.MovementType.up) {
                    if (resultObject.replayVersion >= 5) {
                        x[j] = this.readFloat(replayDataBuffer);
                        y[j] = this.readFloat(replayDataBuffer);
                    }
                    else {
                        x[j] = this.readShort(replayDataBuffer);
                        y[j] = this.readShort(replayDataBuffer);
                    }
                }
                else {
                    x[j] = -1;
                    y[j] = -1;
                }
            }
            resultObject.cursorMovement.push(new CursorData({
                size: moveSize,
                time: time,
                x: x,
                y: y,
                id: id,
            }));
        }
    }
    parseHitObjectData(resultObject, replayDataBuffer) {
        resultObject.hitObjectData.length = 0;
        const replayObjectLength = this.readInt(replayDataBuffer);
        // Parse result data
        for (let i = 0; i < replayObjectLength; i++) {
            const replayObjectData = {
                accuracy: 0,
                tickset: [],
                result: exports.HitResult.miss,
            };
            replayObjectData.accuracy = this.readShort(replayDataBuffer);
            const len = this.readByte(replayDataBuffer);
            if (len > 0) {
                const bytes = [];
                for (let j = 0; j < len; j++) {
                    bytes.push(this.readByte(replayDataBuffer));
                }
                // Int/int division in Java; numbers must be truncated to get actual number
                for (let j = 0; j < len * 8; j++) {
                    replayObjectData.tickset.push((bytes[len - Math.trunc(j / 8) - 1] &
                        (1 << Math.trunc(j % 8))) !==
                        0);
                }
            }
            if (resultObject.replayVersion >= 1) {
                replayObjectData.result = this.readByte(replayDataBuffer);
            }
            resultObject.hitObjectData.push(replayObjectData);
        }
    }
    parseOldReplayInformation(resultObject) {
        var _a, _b, _c;
        // Parse max combo, hit results, and accuracy in old replay version
        if (resultObject.replayVersion >= 3) {
            return;
        }
        const objects = (_a = this.beatmap) === null || _a === void 0 ? void 0 : _a.hitObjects.objects;
        let grantsGekiOrKatu = true;
        for (let i = 0; i < resultObject.hitObjectData.length; ++i) {
            // Hit result
            const hitObjectData = resultObject.hitObjectData[i];
            const isNextNewCombo = objects
                ? i + 1 !== objects.length
                    ? objects[i + 1].isNewCombo
                    : true
                : false;
            switch (hitObjectData.result) {
                case exports.HitResult.miss:
                    ++resultObject.accuracy.nmiss;
                    grantsGekiOrKatu = false;
                    break;
                case exports.HitResult.meh:
                    ++resultObject.accuracy.n50;
                    grantsGekiOrKatu = false;
                    break;
                case exports.HitResult.good:
                    ++resultObject.accuracy.n100;
                    if (grantsGekiOrKatu && isNextNewCombo) {
                        (_b = resultObject.hit100k) !== null && _b !== void 0 ? _b : (resultObject.hit100k = 0);
                        ++resultObject.hit100k;
                    }
                    break;
                case exports.HitResult.great:
                    ++resultObject.accuracy.n300;
                    if (grantsGekiOrKatu && isNextNewCombo) {
                        (_c = resultObject.hit300k) !== null && _c !== void 0 ? _c : (resultObject.hit300k = 0);
                        ++resultObject.hit300k;
                    }
                    break;
            }
            if (isNextNewCombo) {
                grantsGekiOrKatu = true;
            }
        }
        resultObject.rank = this.calculateRank(resultObject);
    }
    calculateRank(resultObject) {
        var _a, _b, _c;
        const totalHits = resultObject.accuracy.n300 +
            resultObject.accuracy.n100 +
            resultObject.accuracy.n50 +
            resultObject.accuracy.nmiss;
        const isHidden = (_c = (((_a = resultObject.convertedMods) === null || _a === void 0 ? void 0 : _a.has(osuBase.ModHidden)) ||
            ((_b = resultObject.convertedMods) === null || _b === void 0 ? void 0 : _b.has(osuBase.ModFlashlight)))) !== null && _c !== void 0 ? _c : false;
        const hit300Ratio = resultObject.accuracy.n300 / totalHits;
        switch (true) {
            case resultObject.accuracy.value() === 1:
                return isHidden ? "XH" : "X";
            case hit300Ratio > 0.9 &&
                resultObject.accuracy.n50 / totalHits < 0.01 &&
                !resultObject.accuracy.nmiss:
                return isHidden ? "SH" : "S";
            case (hit300Ratio > 0.8 && !resultObject.accuracy.nmiss) ||
                hit300Ratio > 0.9:
                return "A";
            case (hit300Ratio > 0.7 && !resultObject.accuracy.nmiss) ||
                hit300Ratio > 0.8:
                return "B";
            case hit300Ratio > 0.6:
                return "C";
            default:
                return "D";
        }
    }
    constructPlayableBeatmap() {
        var _a;
        if (this.beatmap instanceof osuBase.DroidPlayableBeatmap) {
            return this.beatmap;
        }
        if (!this.beatmap || !this.data) {
            throw new Error("Beatmap and replay data must be defined.");
        }
        const mods = this.data.isReplayV3()
            ? this.data.convertedMods
            : (_a = this.difficultyAttributes) === null || _a === void 0 ? void 0 : _a.mods;
        return this.beatmap.createDroidPlayableBeatmap(mods);
    }
    readByte(buffer) {
        const num = buffer.readInt8(this.bufferOffset);
        this.bufferOffset += 1;
        return num;
    }
    readShort(buffer) {
        const num = buffer.readInt16BE(this.bufferOffset);
        this.bufferOffset += 2;
        return num;
    }
    readInt(buffer) {
        const num = buffer.readInt32BE(this.bufferOffset);
        this.bufferOffset += 4;
        return num;
    }
    readFloat(buffer) {
        const num = buffer.readFloatBE(this.bufferOffset);
        this.bufferOffset += 4;
        return num;
    }
}

/**
 * Represents a hitobject in an osu!droid replay.
 *
 * Stores information about hitobjects in an osu!droid replay such as hit offset, tickset, and hit result.
 *
 * This is used when analyzing replays using replay analyzer.
 */
class ReplayObjectData {
    constructor(values) {
        this.accuracy = values.accuracy;
        this.tickset = values.tickset;
        this.result = values.result;
    }
}

exports.CursorData = CursorData;
exports.CursorOccurrence = CursorOccurrence;
exports.CursorOccurrenceGroup = CursorOccurrenceGroup;
exports.RebalanceThreeFingerChecker = RebalanceThreeFingerChecker;
exports.ReplayAnalyzer = ReplayAnalyzer;
exports.ReplayData = ReplayData;
exports.ReplayObjectData = ReplayObjectData;
exports.ReplayV3Data = ReplayV3Data;
exports.SliderCheeseChecker = SliderCheeseChecker;
exports.ThreeFingerChecker = ThreeFingerChecker;
exports.TwoHandChecker = TwoHandChecker;
//# sourceMappingURL=index.js.map
